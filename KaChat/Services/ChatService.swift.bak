import Foundation
import Combine
import UIKit
import UserNotifications
import CryptoKit

/// RPC connection status for the status indicator
enum RpcConnectionStatus {
    case connected      // UTXO subscription confirmed (green)
    case connecting     // Connection is being established (orange)
    case disconnected   // Not connected (red)

    var color: String {
        switch self {
        case .connected: return "green"
        case .connecting: return "orange"
        case .disconnected: return "red"
        }
    }

    var description: String {
        switch self {
        case .connected: return "Connected"
        case .connecting: return "Connecting"
        case .disconnected: return "Disconnected"
        }
    }
}

enum CatchUpSyncTrigger: String {
    case appActive = "app-active"
    case subscriptionRestart = "subscription-restart"
    case rpcSubscriptionsRestored = "rpc-subscriptions-restored"
    case pushMarkedUnreliable = "push-marked-unreliable"
}

@MainActor
final class ChatService: ObservableObject {
    static let shared = ChatService()

    @Published var conversations: [Conversation] = [] {
        didSet {
            scheduleBadgeUpdate()
        }
    }
    @Published var isLoading = false
    @Published var error: KasiaError?
    @Published private(set) var declinedContacts: Set<String> = []
    var settingsViewModel: SettingsViewModel?
    private var cachedSettings = SettingsViewModel.loadSettings()
    @Published var activeConversationAddress: String?
    enum ChatFetchState {
        case loading
        case failed
    }
    @Published var chatFetchStates: [String: ChatFetchState] = [:]

    private enum ContactFetchResult {
        case success(added: Bool)
        case failure
    }

    private var chatFetchCounts: [String: Int] = [:]
    private var chatFetchFailed: Set<String> = []

    /// Pending navigation from notification tap (used when app launches from terminated state)
    @Published var pendingChatNavigation: String?

    // Connection status properties
    @Published private(set) var isRpcSubscribed = false
    @Published private(set) var lastSuccessfulSyncDate: Date?
    @Published private(set) var currentConnectedNode: String?
    @Published private(set) var currentNodeLatencyMs: Int?

    private struct QueuedUtxoNotification {
        let parsed: ParsedUtxosChangedNotification
        let txIds: Set<String>
    }

    private enum OutgoingAttemptPhase {
        case queued
        case submitting
        case submitted
        case failed
    }

    private struct OutgoingTxAttempt {
        let messageId: UUID
        let pendingTxId: String
        let contactAddress: String
        let messageType: ChatMessage.MessageType
        var txId: String?
        var phase: OutgoingAttemptPhase
        var updatedAt: Date
    }

    private struct SyncObjectCursor: Codable {
        var lastFetchedBlockTime: UInt64
    }

    private enum PushReliabilityState: String {
        case disabled
        case unknown
        case reliable
        case unreliable
    }

    private struct PendingPushObservation {
        let txId: String
        let senderAddress: String
        let observedAt: Date
    }

    /// Computed connection status based on node subscription state
    var connectionStatus: RpcConnectionStatus {
        let nodePoolState = NodePoolService.shared.subscriptionState
        switch nodePoolState {
        case .subscribed:
            return .connected
        case .connecting, .failover:
            return .connecting
        case .disconnected, .failed:
            break
        }
        if isRpcSubscribed {
            return .connected
        }
        return .disconnected
    }

    private let apiClient = KasiaAPIClient.shared
    private let contactsManager = ContactsManager.shared
    private let userDefaults = UserDefaults.standard
    private let messageStore = MessageStore.shared
    private var messageSyncTask: Task<Void, Never>?
    private var messageStoreReloadTask: Task<Void, Never>?
    private var messageStoreReloadPending = false
    private var lastMessageStoreReloadAt: Date = .distantPast
#if targetEnvironment(macCatalyst)
    private let messageStoreReloadMinInterval: TimeInterval = 2.5
#else
    private let messageStoreReloadMinInterval: TimeInterval = 1.0
#endif
    // Keep only a recent in-memory slice per conversation by default.
    // Older pages are loaded on demand in ChatDetailView.
    private let inMemoryConversationWindowSize = 160
    private struct PendingOutgoingRef {
        let txId: String
        let messageType: ChatMessage.MessageType
        let timestamp: Date
    }
    private var pendingOutgoingQueue: [String: [PendingOutgoingRef]] = [:]
    private var olderHistoryPageTasks: [String: Task<Int, Never>] = [:]
    private var olderHistoryExhaustedContacts: Set<String> = []
    private var needsMessageStoreSyncAfterBatch = false
    private var lastMessageStoreSyncScheduledAt: Date?
    private let messageStoreSyncMinInterval: TimeInterval = 5.0
    private var dirtyConversationAddresses = Set<String>()
    private var lastFullStoreMaintenanceAt: Date = .distantPast
    private let fullStoreMaintenanceInterval: TimeInterval = 600
    private var pendingCloudKitExport = false
    private var remoteChangeObserver: NSObjectProtocol?
    private var cloudRefreshTimer: Timer?
    private var legacyMigrationScheduled = false
    private var cloudKitImportFirstAttemptAt: [String: Date] = [:]
    private var cloudKitImportLastObservedAt: [String: Date] = [:]
    private var cloudKitImportRetryTokenByTxId: [String: UUID] = [:]
    private let cloudKitImportMaxWaitSeconds: TimeInterval = 180
    private var resolveRetryCounts: [String: Int] = [:]
    private var resolveRetryTasks: [String: Task<Void, Never>] = [:]
    private var incomingResolutionPendingTxIds = Set<String>()
    private var incomingResolutionWarningTxIds = Set<String>()
    private var incomingResolutionAmountHints: [String: UInt64] = [:]
    private let incomingResolutionMaxAdditionalRetries = 10
    private let incomingResolutionBaseDelayNs: UInt64 = 2_000_000_000
    private let incomingResolutionMaxDelayNs: UInt64 = 300_000_000_000
    private var selfStashRetryCounts: [String: Int] = [:]
    private var selfStashFirstAttemptAt: [String: Date] = [:]
    private var mempoolResolveInFlight = Set<String>()
    private var mempoolResolvedTxIds = Set<String>()
    private var mempoolPayloadByTxId: [String: String] = [:]
    private var contextualFetchInFlight = Set<String>()
    private var handshakeFetchTasks: [String: Task<[HandshakeResponse], Error>] = [:]
    private var paymentFetchTasks: [String: Task<[PaymentResponse], Error>] = [:]
    private let messagesKey = "kachat_messages"
    private let draftsKey = "kachat_message_drafts"
    private let aliasesKey = "kachat_conversation_aliases"
    private let ourAliasesKey = "kachat_our_aliases"
    private let conversationPrimaryAliasesKey = "kachat_conversation_aliases_primary"
    private let ourPrimaryAliasesKey = "kachat_our_aliases_primary"
    private let conversationAliasUpdatedAtKey = "kachat_conversation_aliases_updated_at"
    private let ourAliasUpdatedAtKey = "kachat_our_aliases_updated_at"
    private let conversationIdsKey = "kachat_conversation_ids"
    private let declinedContactsKey = "kachat_declined_contacts"
    private let lastPollTimeKey = "kachat_last_poll_time"
    private let syncCursorsKey = "kachat_sync_object_cursors"
    private let pendingSelfStashKey = "kachat_pending_self_stash"
    private let routingStatesKey = "kachat_routing_states"
    private let deterministicMigrationDoneKey = "kachat_deterministic_migration_done"
    private let pushReliabilityStateKey = "kachat_push_reliability_state"
    private let pushConsecutiveMissesKey = "kachat_push_consecutive_misses"
    private let pushLastCatchUpSyncAtKey = "kachat_push_last_catchup_sync_at"
    private let pushLastReregisterAtKey = "kachat_push_last_reregister_at"
    private let syncReorgBufferMs: UInt64 = 600_000

    private var activeContacts: [Contact] {
        contactsManager.activeContacts
    }

    private var currentSettings: AppSettings {
        settingsViewModel?.settings ?? cachedSettings
    }

    /// Delay between syncs when UTXO subscription is inactive (60 seconds after last sync completes)
    private let pollDelayAfterSync: TimeInterval = 60.0

    private var pollTask: Task<Void, Never>?
    private var lastPollTime: UInt64 = 0
    private var syncObjectCursors: [String: SyncObjectCursor] = [:]
    private var syncObjectCursorsDirty = false
    @Published private(set) var isSyncInProgress = false
    private var syncMaxBlockTime: UInt64?
    private var isConfigured = false
    /// True after startPolling() completes its full initial sync (Phases 1-4).
    /// Prevents redundant heavy re-sync on Mac Catalyst window reopen.
    private var hasCompletedInitialSync = false
    private var contactsCancellable: AnyCancellable?
    private var settingsCancellable: AnyCancellable?
    private var pingLatencyCancellable: AnyCancellable?
    private var nodePoolSubscriptionStateCancellable: AnyCancellable?
    private var nodePoolPrimaryEndpointCancellable: AnyCancellable?

    // UTXO subscription state for real-time payment notifications
    private var utxoSubscriptionToken: UUID?
    private var isUtxoSubscribed = false {
        didSet {
            isRpcSubscribed = isUtxoSubscribed
            if !isUtxoSubscribed {
                currentConnectedNode = nil
                currentNodeLatencyMs = nil
            }
        }
    }
    private var utxoFetchInFlight = false
    private var queuedUtxoNotifications: [QueuedUtxoNotification] = []
    private var lastPaymentFetchTime: UInt64 = 0

    // Track in-flight resolve operations to prevent duplicates from multiple UTXO notifications
    private let inFlightResolveTracker = InFlightResolveTracker()

    // Track if we've ever been subscribed (to detect restarts vs initial setup)
    private var hasEverBeenSubscribed = false

    // Track subscribed address count to detect when resubscription is needed
    private var lastSubscribedAddressCount = 0
    private var lastSubscribedAddresses: Set<String> = []
    private var pendingResubscriptionTask: Task<Void, Never>?
    private var needsResubscriptionAfterSync = false
    private var catchUpSyncInFlight = false

    // Push-channel reliability tracking (UTXO txId -> matching APNs delivery).
    private var pushReliabilityState: PushReliabilityState = .disabled
    private var pushConsecutiveMisses = 0
    private var pendingPushObservations: [String: PendingPushObservation] = [:]
    private var pushObservationTasks: [String: Task<Void, Never>] = [:]
    private var pushSeenByTxId: [String: Date] = [:]
    private var lastCatchUpSyncAt: Date?
    private var lastPushReregisterAt: Date?
    private let pushObservationGraceInterval: TimeInterval = 60
    private let pushLeadMatchTolerance: TimeInterval = 30
    private let pushObservationRetention: TimeInterval = 600
    private let reliablePushCatchUpDebounce: TimeInterval = 600
    private let pushReregisterCooldown: TimeInterval = 600

    private var badgeUpdateTask: Task<Void, Never>?
    private var pendingLastMessageUpdates: [UUID: Date] = [:]
    private var pendingLastMessageUpdateWorkItem: DispatchWorkItem?
    private let lastMessageBatchDelay: TimeInterval = 0.8

    // Serialize outgoing message sends to avoid UTXO double-spend/orphan errors.
    private var messageSendTail: Task<Void, Error>?
    private var reservedMessageOutpoints: [String: Date] = [:]
    private var pendingMessageUtxos: [String: (utxo: UTXO, expiresAt: Date)] = [:]
    private let pendingMessageUtxoTTL: TimeInterval = 120
    private var outgoingAttemptsByMessageId: [UUID: OutgoingTxAttempt] = [:]
    private var outgoingAttemptByPendingTxId: [String: UUID] = [:]
    private var outgoingAttemptByRealTxId: [String: UUID] = [:]
    private let outgoingAttemptTTL: TimeInterval = 900
    private var scheduledSendRetries = Set<String>()
    private let spendableFundsRetryAttempts = 5
    private let spendableFundsRetryBaseDelay: TimeInterval = 0.1

    // Spam detection: track irrelevant TX notifications per contact (20+ in 1 minute = noisy)
    private var contactTxNotifications: [String: [Date]] = [:]  // address -> timestamps
    private var dismissedSpamWarnings: Set<String> = []  // addresses dismissed until app restart
    @Published var noisyContactWarning: NoisyContactWarning?

    // Periodic polling for contacts with realtime updates disabled
    private var disabledContactsPollingTask: Task<Void, Never>?
    private let disabledContactsPollingInterval: TimeInterval = 60  // 1 minute

    // Suppress notifications during initial sync after wallet import/create
    private var suppressNotificationsUntilSynced = false

    // Maps contact address -> their aliases (for fetching their messages TO us)
    private var conversationAliases: [String: Set<String>] = [:]
    // Maps contact address -> most recent incoming alias
    private var conversationPrimaryAliases: [String: String] = [:]
    private var conversationAliasUpdatedAt: [String: UInt64] = [:]
    // Maps contact address -> OUR aliases (for fetching our messages TO them)
    private var ourAliases: [String: Set<String>] = [:]
    // Maps contact address -> most recent outgoing alias
    private var ourPrimaryAliases: [String: String] = [:]
    private var ourAliasUpdatedAt: [String: UInt64] = [:]
    // Deterministic alias routing state per contact
    private var routingStates: [String: ConversationRoutingState] = [:]
    // Maps contact address -> conversation id from handshake
    private var conversationIds: [String: String] = [:]
    // Drafts keyed by contact address
    private var messageDrafts: [String: String] = [:]
    // Pending self-stash jobs that couldn't be sent due to missing UTXOs
    private var pendingSelfStash: [PendingSelfStash] = []
    private var cachedUtxos: [UTXO] = []
    private var cachedUtxosTimestamp: Date?
    private let utxoCacheInterval: TimeInterval = 20

    private var rpcReconnectObserver: NSObjectProtocol?
    private var conversationCountCancellable: AnyCancellable?

    private init() {
        lastPollTime = UInt64(userDefaults.integer(forKey: lastPollTimeKey))
        migrateLegacyMessagesIfNeeded()
        Task { @MainActor [weak self] in
            self?.loadMessagesFromStoreIfNeeded(onlyIfEmpty: true)
        }
        loadMessageDrafts()
        loadConversationAliases()
        loadOurAliases()
        loadConversationIds()
        loadRoutingStates()
        loadSyncObjectCursors()
        loadPendingSelfStash()
        loadDeclinedContacts()
        loadPushReliabilityState()
        observeContacts()
        observeSettings()
        observeRpcReconnection()
        observePingLatency()
        observeNodePoolConnectionState()
        observeConversationCount()
        observeRemoteStoreChanges()
        messageStore.applyRetention(SettingsViewModel.loadSettings().messageRetention)
        cloudRefreshTimer = Timer.scheduledTimer(withTimeInterval: 300, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
            }
        }
    }

    /// Observe conversation count changes to trigger resubscription when new chats are added
    private func observeConversationCount() {
        conversationCountCancellable = $conversations
            .map { $0.count }
            .removeDuplicates()
            .dropFirst()  // Skip initial value
            .sink { [weak self] _ in
                self?.checkAndResubscribeIfNeeded()
            }
    }

    /// Observe NodePoolService ping latency for real-time latency updates
    private func observePingLatency() {
        pingLatencyCancellable = NodePoolService.shared.$lastPingLatencyMs
            .receive(on: DispatchQueue.main)
            .sink { [weak self] latencyMs in
                guard let latency = latencyMs else { return }
                self?.currentNodeLatencyMs = latency
            }
    }

    /// Observe NodePool subscription/primary endpoint as the source of truth for status UI
    private func observeNodePoolConnectionState() {
        nodePoolPrimaryEndpointCancellable = NodePoolService.shared.$primaryEndpoint
            .receive(on: DispatchQueue.main)
            .sink { [weak self] endpoint in
                self?.currentConnectedNode = endpoint?.url
            }

        nodePoolSubscriptionStateCancellable = NodePoolService.shared.$subscriptionState
            .receive(on: DispatchQueue.main)
            .sink { [weak self] state in
                guard let self else { return }
                switch state {
                case .subscribed:
                    if !self.isUtxoSubscribed {
                        self.isUtxoSubscribed = true
                    }
                case .disconnected, .failed:
                    if self.isUtxoSubscribed {
                        self.isUtxoSubscribed = false
                    }
                case .connecting, .failover:
                    break
                }
            }
    }

    /// Observe RPC reconnection to sync after connection is restored
    private var rpcReconnectedObserver: NSObjectProtocol?
    private let chatHistoryArchiveVersion = 1

    private func observeRpcReconnection() {
        // Listen for subscription restoration (fetch missed messages)
        rpcReconnectObserver = NotificationCenter.default.addObserver(
            forName: .rpcSubscriptionsRestored,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            NSLog("[ChatService] RPC subscriptions restored - syncing to catch any missed messages")
            Task { @MainActor in
                await self?.maybeRunCatchUpSync(trigger: .rpcSubscriptionsRestored)
            }
        }

        // Listen for connection restoration (re-subscribe)
        rpcReconnectedObserver = NotificationCenter.default.addObserver(
            forName: .rpcReconnected,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            NSLog("[ChatService] RPC reconnected - re-subscribing to UTXOs...")
            Task { @MainActor in
                self?.isUtxoSubscribed = false  // Reset subscription state
                await self?.setupUtxoSubscription()
            }
        }
    }

    /// Clear all chat data (called when clearing app data)
    /// - Parameter skipStoreClear: If true, skips calling messageStore.clearAll() (use when store was already cleared)
    func clearAllData(skipStoreClear: Bool = false) {
        stopPolling()
        resetForNewWallet(skipStoreClear: skipStoreClear)
        contactsCancellable?.cancel()
        contactsCancellable = nil
        settingsCancellable?.cancel()
        settingsCancellable = nil
        pingLatencyCancellable?.cancel()
        pingLatencyCancellable = nil
        nodePoolSubscriptionStateCancellable?.cancel()
        nodePoolSubscriptionStateCancellable = nil
        nodePoolPrimaryEndpointCancellable?.cancel()
        nodePoolPrimaryEndpointCancellable = nil
        conversationCountCancellable?.cancel()
        conversationCountCancellable = nil
        pendingResubscriptionTask?.cancel()
        pendingResubscriptionTask = nil
        if let observer = rpcReconnectObserver {
            NotificationCenter.default.removeObserver(observer)
            rpcReconnectObserver = nil
        }
    }

    func wipeIncomingMessagesAndResync() async {
        var updatedConversations = conversations
        for index in updatedConversations.indices {
            updatedConversations[index].messages.removeAll(where: { !$0.isOutgoing })
            updatedConversations[index].unreadCount = 0
        }
        conversations = updatedConversations
        MessageStore.shared.clearIncomingMessages()
        MessageStore.shared.clearDpiCorruptionWarning()
        lastPollTime = 0
        lastPaymentFetchTime = 0
        userDefaults.removeObject(forKey: lastPollTimeKey)
        clearSyncObjectCursors()
        saveMessages()
        await fetchNewMessages(forActiveOnly: nil)
    }

    /// Reset chat state for new/imported wallet - clears data but keeps polling active
    /// - Parameter skipStoreClear: If true, skips calling messageStore.clearAll() (use when switching to a fresh wallet store)
    func resetForNewWallet(skipStoreClear: Bool = false) {
        subscriptionRetryTask?.cancel()
        subscriptionRetryTask = nil
        pendingResubscriptionTask?.cancel()
        pendingResubscriptionTask = nil
        conversations = []
        lastSubscribedAddressCount = 0
        lastSubscribedAddresses = []
        needsResubscriptionAfterSync = false
        conversationAliases = [:]
        conversationPrimaryAliases = [:]
        conversationAliasUpdatedAt = [:]
        ourAliases = [:]
        ourPrimaryAliases = [:]
        ourAliasUpdatedAt = [:]
        conversationIds = [:]
        pendingSelfStash = []
        declinedContacts = []
        lastPollTime = 0
        syncObjectCursors = [:]
        syncObjectCursorsDirty = false
        lastPaymentFetchTime = 0
        isConfigured = false
        isUtxoSubscribed = false
        hasEverBeenSubscribed = false
        cachedUtxos = []
        cachedUtxosTimestamp = nil
        catchUpSyncInFlight = false
        pushReliabilityState = .disabled
        pushConsecutiveMisses = 0
        pendingPushObservations.removeAll()
        for task in pushObservationTasks.values {
            task.cancel()
        }
        pushObservationTasks.removeAll()
        pushSeenByTxId.removeAll()
        lastCatchUpSyncAt = nil
        lastPushReregisterAt = nil
        resolveRetryCounts = [:]
        for (_, task) in resolveRetryTasks {
            task.cancel()
        }
        resolveRetryTasks = [:]
        incomingResolutionPendingTxIds = []
        incomingResolutionWarningTxIds = []
        incomingResolutionAmountHints = [:]
        suppressNotificationsUntilSynced = true  // Suppress notifications during initial sync
        hasCompletedInitialSync = false  // Allow full re-sync for new wallet
        userDefaults.removeObject(forKey: lastPollTimeKey)
        userDefaults.removeObject(forKey: syncCursorsKey)
        userDefaults.removeObject(forKey: messagesKey)
        userDefaults.removeObject(forKey: aliasesKey)
        userDefaults.removeObject(forKey: conversationPrimaryAliasesKey)
        userDefaults.removeObject(forKey: conversationAliasUpdatedAtKey)
        userDefaults.removeObject(forKey: ourAliasesKey)
        userDefaults.removeObject(forKey: ourPrimaryAliasesKey)
        userDefaults.removeObject(forKey: ourAliasUpdatedAtKey)
        userDefaults.removeObject(forKey: conversationIdsKey)
        userDefaults.removeObject(forKey: pendingSelfStashKey)
        userDefaults.removeObject(forKey: declinedContactsKey)
        userDefaults.removeObject(forKey: routingStatesKey)
        userDefaults.removeObject(forKey: deterministicMigrationDoneKey)
        userDefaults.removeObject(forKey: pushReliabilityStateKey)
        userDefaults.removeObject(forKey: pushConsecutiveMissesKey)
        userDefaults.removeObject(forKey: pushLastCatchUpSyncAtKey)
        userDefaults.removeObject(forKey: pushLastReregisterAtKey)
        routingStates = [:]
        if !skipStoreClear {
            messageStore.clearAll()
        }
    }

    // MARK: - Public Methods

    /// Start message sync - uses RPC notifications when available, polling as fallback
    /// Start fallback polling loop when UTXO subscription is unavailable
    /// Waits 60 seconds after each sync completes before starting next one
    /// Setup UTXO subscription for real-time payment and message notifications
    /// Task for subscription retry
    private var subscriptionRetryTask: Task<Void, Never>?

    /// Retry RPC subscription with 1s wait when all nodes exhausted
    /// Public method to re-setup UTXO subscription after manual reconnect
    /// Pause UTXO subscription on iOS when remote push is enabled and app goes to background
    /// Resume UTXO subscription on iOS when app becomes active in remote push mode
    /// Update UTXO subscription to include a new contact address
    /// Force a one-contact historical contextual sync from genesis (`blockTime = 0`).
    /// Used after manually adding a new contact so old messages are not skipped by adaptive cursors.
    /// Check if resubscription is needed due to new conversations/contacts
    /// Defers resubscription until sync completes to avoid interrupting sync
    /// Called at the end of sync to trigger deferred resubscription if needed
    // MARK: - Push Notification Message Handling

    /// Add a message that was decrypted by the notification extension or fetched from push
    struct ChatHistoryImportSummary {
        let conversationCount: Int
        let messageCount: Int
        let filledSentContentCount: Int
    }

    enum ChatHistoryArchiveError: LocalizedError {
        case encryptionKeyUnavailable
        case unsupportedVersion(Int)
        case emptyArchive

        var errorDescription: String? {
            switch self {
            case .encryptionKeyUnavailable:
                return "Failed to access wallet encryption key."
            case .unsupportedVersion(let version):
                return "Unsupported chat history format (version \(version))."
            case .emptyArchive:
                return "No messages found in the selected archive."
            }
        }
    }

    func exportChatHistoryArchive() throws -> URL {
        guard let key = messageEncryptionKey() else {
            throw ChatHistoryArchiveError.encryptionKeyUnavailable
        }

        let storedMessages = messageStore.fetchAllMessages(decryptionKey: key)
        let metaByAddress = messageStore.fetchConversationMeta()
        var messagesByAddress: [String: [String: ChatMessage]] = [:]

        for stored in storedMessages {
            let contactAddress = stored.contactAddress
            let txId = stored.message.txId
            guard !contactAddress.isEmpty, !txId.isEmpty else { continue }
            var bucket = messagesByAddress[contactAddress, default: [:]]
            if let existing = bucket[txId] {
                bucket[txId] = preferMessage(existing, stored.message)
            } else {
                bucket[txId] = stored.message
            }
            messagesByAddress[contactAddress] = bucket
        }

        let allAddresses = Set(messagesByAddress.keys).union(metaByAddress.keys)
        let exportedConversations = allAddresses.map { contactAddress in
            let messages = Array(messagesByAddress[contactAddress, default: [:]].values)
                .sorted(by: isMessageOrderedBefore)
            let meta = metaByAddress[contactAddress]
            let inMemory = conversations.first(where: { $0.contact.address == contactAddress })
            let alias = contactsManager.getContact(byAddress: contactAddress)?.alias ?? inMemory?.contact.alias
            return ChatHistoryArchiveConversation(
                conversationId: meta?.id ?? inMemory?.id,
                contactAddress: contactAddress,
                contactAlias: alias,
                unreadCount: max(0, meta?.unreadCount ?? inMemory?.unreadCount ?? 0),
                messages: messages
            )
        }
        .sorted { $0.contactAddress < $1.contactAddress }

        let archive = ChatHistoryArchive(
            schemaVersion: chatHistoryArchiveVersion,
            exportedAt: Date(),
            walletAddress: WalletManager.shared.currentWallet?.publicAddress,
            conversations: exportedConversations
        )

        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        let data = try encoder.encode(archive)

        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = formatter.string(from: Date()).replacingOccurrences(of: ":", with: "-")
        let fileName = "kachat-history-\(timestamp).json"
        let fileURL = FileManager.default.temporaryDirectory.appendingPathComponent(fileName)
        if FileManager.default.fileExists(atPath: fileURL.path) {
            try FileManager.default.removeItem(at: fileURL)
        }
        try data.write(to: fileURL, options: .atomic)
        return fileURL
    }

    func importChatHistoryArchive(_ data: Data) async throws -> ChatHistoryImportSummary {
        guard let key = messageEncryptionKey() else {
            throw ChatHistoryArchiveError.encryptionKeyUnavailable
        }

        let archive: ChatHistoryArchive
        do {
            let isoDecoder = JSONDecoder()
            isoDecoder.dateDecodingStrategy = .iso8601
            archive = try isoDecoder.decode(ChatHistoryArchive.self, from: data)
        } catch {
            archive = try JSONDecoder().decode(ChatHistoryArchive.self, from: data)
        }
        guard archive.schemaVersion == chatHistoryArchiveVersion else {
            throw ChatHistoryArchiveError.unsupportedVersion(archive.schemaVersion)
        }

        let existingBefore = messageStore.fetchAllMessages(decryptionKey: key)
        let existingOutgoingPlaceholderTxIds = Set(
            existingBefore.compactMap { stored -> String? in
                guard stored.message.isOutgoing, isPlaceholderContent(stored.message.content) else { return nil }
                return stored.message.txId
            }
        )

        var importedByAddress: [String: Conversation] = [:]
        var importedOutgoingWithContentTxIds = Set<String>()

        for archivedConversation in archive.conversations {
            let contactAddress = archivedConversation.contactAddress.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !contactAddress.isEmpty else { continue }

            var importedMessages = archivedConversation.messages.filter { !$0.txId.isEmpty }
            guard !importedMessages.isEmpty else { continue }
            importedMessages = dedupeMessages(importedMessages)

            for message in importedMessages where message.isOutgoing && !isPlaceholderContent(message.content) {
                importedOutgoingWithContentTxIds.insert(message.txId)
            }

            let importedAlias = archivedConversation.contactAlias?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
            let contact = contactsManager.getOrCreateContact(address: contactAddress, alias: importedAlias)
            if !importedAlias.isEmpty {
                let autoAlias = Contact.generateDefaultAlias(from: contactAddress)
                if contact.alias == autoAlias && importedAlias != autoAlias {
                    var updated = contact
                    updated.alias = importedAlias
                    contactsManager.updateContact(updated)
                }
            }

            let archived = Conversation(
                id: archivedConversation.conversationId ?? UUID(),
                contact: contact,
                messages: importedMessages,
                unreadCount: max(0, archivedConversation.unreadCount)
            )

            if var existing = importedByAddress[contactAddress] {
                existing.messages = dedupeMessages(existing.messages + archived.messages)
                existing.unreadCount = max(existing.unreadCount, archived.unreadCount)
                importedByAddress[contactAddress] = existing
            } else {
                importedByAddress[contactAddress] = archived
            }
        }

        let importedConversations = Array(importedByAddress.values)
        guard !importedConversations.isEmpty else {
            throw ChatHistoryArchiveError.emptyArchive
        }

        let importedMessageCount = Set(
            importedConversations.flatMap { conversation in
                conversation.messages.map(\.txId)
            }
        ).count

        let retention = currentSettings.messageRetention
        let didWrite = await messageStore.syncFromConversations(
            importedConversations,
            encryptionKey: key,
            retention: retention,
            performMaintenance: false
        )
        if didWrite {
            recordLocalSave()
        }

        for conversation in importedConversations {
            if let lastDate = conversation.lastMessage?.timestamp {
                contactsManager.updateContactLastMessage(conversation.contact.id, at: lastDate)
            }
        }

        loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)

        let filledSentContentCount = existingOutgoingPlaceholderTxIds
            .intersection(importedOutgoingWithContentTxIds)
            .count

        return ChatHistoryImportSummary(
            conversationCount: importedConversations.count,
            messageCount: importedMessageCount,
            filledSentContentCount: filledSentContentCount
        )
    }

    func recordRemotePushDelivery(txId: String, sender: String, messageType: String?) {
        let normalizedTxId = txId.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !normalizedTxId.isEmpty else { return }

        prunePushReliabilityCaches(now: Date())
        pushSeenByTxId[normalizedTxId] = Date()

        guard let observation = pendingPushObservations.removeValue(forKey: normalizedTxId) else {
            return
        }
        if let task = pushObservationTasks.removeValue(forKey: normalizedTxId) {
            task.cancel()
        }

        NSLog("[ChatService] Push/UTXO matched tx=%@ sender=%@ type=%@",
              String(normalizedTxId.prefix(12)),
              String(sender.suffix(10)),
              messageType ?? "unknown")
        applyPushObservationOutcome(
            txId: normalizedTxId,
            senderAddress: observation.senderAddress,
            didReceivePush: true
        )
    }

    func maybeRunCatchUpSync(trigger: CatchUpSyncTrigger, force: Bool = false) async {
        refreshPushReliabilityPrerequisites()

        let shouldDebounce = !force &&
            isPushChannelOperational() &&
            pushReliabilityState == .reliable

        if shouldDebounce,
           let last = lastCatchUpSyncAt,
           Date().timeIntervalSince(last) < reliablePushCatchUpDebounce {
            NSLog("[ChatService] Skipping catch-up sync (%@) - push reliable and debounce active",
                  trigger.rawValue)
            return
        }

        if catchUpSyncInFlight {
            NSLog("[ChatService] Skipping catch-up sync (%@) - catch-up already in flight",
                  trigger.rawValue)
            return
        }

        catchUpSyncInFlight = true
        defer { catchUpSyncInFlight = false }

        NSLog("[ChatService] Running catch-up sync (%@), pushState=%@ force=%@",
              trigger.rawValue, pushReliabilityState.rawValue, force ? "true" : "false")
        await fetchNewMessages()
        lastCatchUpSyncAt = Date()
        persistPushReliabilityState()
    }

    func startPolling(interval: TimeInterval = 10.0) {
        // If initial sync already completed (e.g. Mac Catalyst window reopen),
        // just ensure subscription/polling is running â€” skip the heavy 4-phase sync.
        if hasCompletedInitialSync {
            NSLog("[ChatService] Initial sync already done, ensuring subscription/polling")
            let isRemotePushEnabled = settingsViewModel?.settings.notificationMode == .remotePush
            if !isRemotePushEnabled && !isUtxoSubscribed && pollTask == nil {
                startFallbackPolling()
            }
            return
        }

        stopPollingTimerOnly()
        subscriptionRetryTask?.cancel()
        subscriptionRetryTask = nil
        pendingResubscriptionTask?.cancel()
        pendingResubscriptionTask = nil
        needsResubscriptionAfterSync = false
        NSLog("[ChatService] Starting message sync...")

        Task {
            NSLog("[ChatService] Sync task started")
            let isRemotePushEnabled = settingsViewModel?.settings.notificationMode == .remotePush
            let settings = currentSettings
            let cloudKitEnabled = settings.storeMessagesInICloud

            NSLog("[ChatService] Configuring API...")
            await configureAPIIfNeeded()
            NSLog("[ChatService] API configured")

            // Phase 1: Fetch handshakes first (needed to decrypt messages)
            // This is lightweight and establishes encryption keys
            NSLog("[ChatService] Phase 1: Fetching handshakes...")
            await fetchHandshakesOnly()
            NSLog("[ChatService] Phase 1 complete")

            // Phase 2: Setup UTXO subscription for real-time updates
            // This can run while CloudKit syncs
            NSLog("[ChatService] Phase 2: Setting up UTXO subscription...")
            await setupUtxoSubscription()
            NSLog("[ChatService] Phase 2 complete, isUtxoSubscribed=%d", isUtxoSubscribed ? 1 : 0)

            // Phase 3: Wait for CloudKit to complete (no timeout)
            // CloudKit may have all our messages already
            if cloudKitEnabled {
                NSLog("[ChatService] Phase 3: Waiting for CloudKit sync to complete...")
                await messageStore.waitForCloudKitSync(timeout: 0) // 0 = no timeout
                NSLog("[ChatService] Phase 3 complete - CloudKit sync done")

                // Phase 3.5: Load CloudKit-synced messages BEFORE indexer sync
                // This ensures we have any messages sent from other devices before
                // the indexer creates placeholder entries for them
                NSLog("[ChatService] Phase 3.5: Loading CloudKit-synced messages...")
                loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)

                // Brief pause to allow any in-flight CloudKit syncs to complete
                try? await Task.sleep(nanoseconds: 500_000_000) // 0.5s
                NSLog("[ChatService] Phase 3.5 complete")
            } else {
                NSLog("[ChatService] Phase 3 skipped - CloudKit disabled")
            }

            // Phase 4: Full indexer sync (diff-only writes to reduce DB churn)
            // NOTE: syncFromConversations() will preserve CloudKit content and not
            // overwrite with placeholders thanks to the !isPlaceholder check
            NSLog("[ChatService] Phase 4: Full indexer sync...")
            await fetchNewMessages()
            NSLog("[ChatService] Phase 4 complete")

            // After initial sync, enable notifications (they were suppressed during wallet import)
            suppressNotificationsUntilSynced = false
            hasCompletedInitialSync = true

            if isRemotePushEnabled {
                NSLog("[ChatService] Remote push enabled - skipping local polling")
                return
            }

            if isUtxoSubscribed {
                // RPC subscription active - no polling needed, rely on notifications
                let protocolName = NodePoolService.shared.activeProtocol
                NSLog("[ChatService] %@ subscription active - using real-time notifications (no polling)", protocolName)
            } else {
                // RPC subscription failed - use polling as fallback
                // Poll with 60s delay after each sync completes (not fixed interval)
                self.startFallbackPolling()
                NSLog("[ChatService] RPC unavailable - using fallback polling (%.0fs delay after each sync)", pollDelayAfterSync)
            }
        }
    }

    private func startFallbackPolling() {
        pollTask?.cancel()
        pollTask = Task { @MainActor [weak self] in
            guard let self = self else { return }

            while !Task.isCancelled {
                // Wait before next sync
                try? await Task.sleep(nanoseconds: UInt64(self.pollDelayAfterSync * 1_000_000_000))

                guard !Task.isCancelled else { break }

                // Perform sync
                await self.fetchNewMessages()
            }
        }
    }

    private func setupUtxoSubscription() async {
        guard let wallet = WalletManager.shared.currentWallet else {
            NSLog("[ChatService] setupUtxoSubscription: No wallet available")
            subscriptionRetryTask?.cancel()
            subscriptionRetryTask = nil
            return
        }

        NSLog("[ChatService] setupUtxoSubscription: Starting, isConnected=%@",
              NodePoolService.shared.isConnected ? "true" : "false")

        // Remove old subscription handler if any
        if let token = utxoSubscriptionToken {
            NodePoolService.shared.removeNotificationHandler(token)
            utxoSubscriptionToken = nil
        }
        isUtxoSubscribed = false

        do {
            try await connectRpcIfNeeded()
            let nodePool = NodePoolService.shared
            NSLog("[ChatService] setupUtxoSubscription: RPC connected=%@", nodePool.isConnected ? "true" : "false")

            // Collect all addresses to subscribe: our wallet + active contacts
            var addressesToSubscribe = Set<String>()
            addressesToSubscribe.insert(wallet.publicAddress)

            let contacts = await MainActor.run { contactsManager.activeContacts }
            let contactCount = contacts.count
            for contact in contacts {
                addressesToSubscribe.insert(contact.address)
            }

            NSLog("[ChatService] Subscription setup: %d active contacts", contactCount)

            // TODO: Fix realtimeUpdatesDisabled feature - re-enable polling when fixed
            // Start/restart polling for contacts with realtime disabled
            // startDisabledContactsPolling()

            let addressList = Array(addressesToSubscribe)
            try await nodePool.subscribeUtxosChanged(addresses: addressList)

            // Add notification handler for UTXO changes
            utxoSubscriptionToken = nodePool.addNotificationHandler { [weak self] notification, payload in
                guard let self = self, notification == .utxosChanged else { return }
                self.handleUtxoChangeNotification(payload: payload)
            }

            // Detect if this is a restart (was subscribed before, got disconnected, now resubscribed)
            let isRestart = hasEverBeenSubscribed

            isUtxoSubscribed = true
            hasEverBeenSubscribed = true
            subscriptionRetryTask?.cancel()
            subscriptionRetryTask = nil

            // Stop polling task since we have real-time notifications now
            if pollTask != nil {
                pollTask?.cancel()
                pollTask = nil
                NSLog("[ChatService] Stopped fallback polling - using real-time notifications")
            }

            // Update connected node info
            currentConnectedNode = nodePool.connectedNodeURL
            currentNodeLatencyMs = nodePool.lastPingLatencyMs

            // Track subscribed address count for resubscription detection
            lastSubscribedAddressCount = addressList.count
            lastSubscribedAddresses = Set(addressList)
            NSLog("[ChatService] Real-time notifications active for %d addresses", addressList.count)

            // If this is a restart, sync messages/payments to catch anything missed during downtime
            if isRestart {
                NSLog("[ChatService] Subscription restarted - evaluating catch-up sync policy")
                Task {
                    await self.maybeRunCatchUpSync(trigger: .subscriptionRestart)
                }
            }

        } catch {
            NSLog("[ChatService] RPC subscription failed: %@", error.localizedDescription)
            isUtxoSubscribed = false

            // Start retry loop with 1s wait between full pool attempts
            scheduleSubscriptionRetry()
        }
    }

    private func scheduleSubscriptionRetry() {
        guard WalletManager.shared.currentWallet != nil else {
            subscriptionRetryTask?.cancel()
            subscriptionRetryTask = nil
            return
        }

        // Cancel existing retry if any
        subscriptionRetryTask?.cancel()

        subscriptionRetryTask = Task {
            // Wait 1 second before retrying with all nodes from pool again
            try? await Task.sleep(nanoseconds: 1_000_000_000)

            guard !Task.isCancelled else { return }

            NSLog("[ChatService] Retrying RPC subscription with all pool nodes...")
            await setupUtxoSubscription()

            guard !Task.isCancelled else { return }

            // If still not subscribed after retry, schedule another retry
            if !isUtxoSubscribed {
                NSLog("[ChatService] All pool nodes failed, retrying in 1s...")
                scheduleSubscriptionRetry()
            }
        }
    }

    func setupUtxoSubscriptionAfterReconnect() async {
        await setupUtxoSubscription()
    }

    func pauseUtxoSubscriptionForRemotePush() {
#if targetEnvironment(macCatalyst)
        // Keep realtime subscriptions active on desktop while app focus changes.
        return
#else
        guard settingsViewModel?.settings.notificationMode == .remotePush else { return }

        if let token = utxoSubscriptionToken {
            NodePoolService.shared.removeNotificationHandler(token)
            utxoSubscriptionToken = nil
        }
        NodePoolService.shared.unsubscribeUtxosChanged()
        isUtxoSubscribed = false
        NSLog("[ChatService] Remote push active - UTXO subscription paused for background")
#endif
    }

    func resumeUtxoSubscriptionForRemotePush() async {
#if targetEnvironment(macCatalyst)
        // No-op: Catalyst does not pause on focus loss.
        return
#else
        guard settingsViewModel?.settings.notificationMode == .remotePush else { return }
        guard utxoSubscriptionToken == nil && !isUtxoSubscribed else { return }

        await setupUtxoSubscription()
#endif
    }

    func addContactToUtxoSubscription(_ contactAddress: String) async {
        guard isUtxoSubscribed else { return }
        guard let wallet = WalletManager.shared.currentWallet else { return }

        // Rebuild subscription with all active addresses including the new one
        var addressesToSubscribe = Set<String>()
        addressesToSubscribe.insert(wallet.publicAddress)

        let contactAddresses = await MainActor.run { contactsManager.activeContacts.map { $0.address } }
        for address in contactAddresses {
            addressesToSubscribe.insert(address)
        }
        if !(contactsManager.getContact(byAddress: contactAddress)?.isArchived ?? false) {
            addressesToSubscribe.insert(contactAddress)
        }

        let addressList = Array(addressesToSubscribe)
        lastSubscribedAddressCount = addressList.count
        lastSubscribedAddresses = Set(addressList)
        let _ = try? await NodePoolService.shared.subscribeUtxosChanged(addresses: addressList)
    }

    func syncContactHistoryFromGenesis(_ contactAddress: String) async {
        guard let wallet = WalletManager.shared.currentWallet else { return }

        await configureAPIIfNeeded()
        guard isConfigured else { return }

        let privateKey = WalletManager.shared.getPrivateKey()
        ensureRoutingState(for: contactAddress, privateKey: privateKey)

        // Ensure realtime updates include this new contact as soon as possible.
        await addContactToUtxoSubscription(contactAddress)

        let completed = await fetchContextualMessagesForActive(
            contactAddress: contactAddress,
            myAddress: wallet.publicAddress,
            privateKey: privateKey,
            fallbackSince: 0,
            nowMs: currentTimeMs(),
            forceExactBlockTime: true
        )
        guard completed else { return }

        saveMessages()
    }

    func checkAndResubscribeIfNeeded() {
        guard isUtxoSubscribed else { return }
        guard let wallet = WalletManager.shared.currentWallet else { return }

        // Calculate current active address set
        var addressesToSubscribe = Set<String>()
        addressesToSubscribe.insert(wallet.publicAddress)
        for contact in activeContacts {
            addressesToSubscribe.insert(contact.address)
        }

        let currentAddressCount = addressesToSubscribe.count

        // Resubscribe whenever active address set changes (additions or removals)
        guard addressesToSubscribe != lastSubscribedAddresses else { return }

        // If sync is in progress, mark for resubscription after sync completes
        if isLoading {
            needsResubscriptionAfterSync = true
            NSLog("[ChatService] Address count changed: %d -> %d, deferring resubscription until sync completes",
                  lastSubscribedAddressCount, currentAddressCount)
            return
        }

        NSLog("[ChatService] Address count changed: %d -> %d, executing resubscription",
              lastSubscribedAddressCount, currentAddressCount)

        // Cancel any pending resubscription task
        pendingResubscriptionTask?.cancel()

        // Execute resubscription
        pendingResubscriptionTask = Task {
            await setupUtxoSubscription()
        }
    }

    private func executeResubscriptionIfNeeded() {
        guard needsResubscriptionAfterSync else { return }
        needsResubscriptionAfterSync = false

        NSLog("[ChatService] Sync complete, executing deferred resubscription")

        pendingResubscriptionTask?.cancel()
        pendingResubscriptionTask = Task {
            await setupUtxoSubscription()
        }
    }

    func addMessageFromPush(txId: String, sender: String, content: String, timestamp: Int64) async {
        guard let wallet = WalletManager.shared.currentWallet else {
            NSLog("[ChatService] No wallet for push message")
            return
        }

        // Check if message already exists
        if findLocalMessage(txId: txId) != nil {
            NSLog("[ChatService] Push message already exists: %@", txId)
            return
        }

        // Determine message type
        let msgType: ChatMessage.MessageType = content.hasPrefix("{\"type\":\"audio\"") ? .audio : .contextual

        // Create message using the correct ChatMessage initializer
        let message = ChatMessage(
            txId: txId,
            senderAddress: sender,
            receiverAddress: wallet.publicAddress,
            content: content,
            timestamp: Date(timeIntervalSince1970: TimeInterval(timestamp) / 1000),
            blockTime: UInt64(timestamp),
            acceptingBlock: nil,
            isOutgoing: false,
            messageType: msgType
        )

        // Add to conversation using existing method
        addMessageToConversation(message, contactAddress: sender)
        saveMessages()

        NSLog("[ChatService] Added message from push: %@ from %@", txId, String(sender.suffix(10)))
    }

    /// Add a payment notification received from push
    func addPaymentFromPush(
        txId: String,
        sender: String,
        amount: UInt64?,
        payload: String?,
        timestamp: Int64
    ) async -> Bool {
        guard let wallet = WalletManager.shared.currentWallet else {
            NSLog("[ChatService] No wallet for push payment")
            return false
        }

        if findLocalMessage(txId: txId) != nil {
            NSLog("[ChatService] Push payment already exists: %@", txId)
            return true
        }

        let myAddress = wallet.publicAddress
        let isOutgoing = sender == myAddress
        let privateKey = WalletManager.shared.getPrivateKey()

        if let payload, !payload.isEmpty {
            if isContextualPayload(payload) || isSelfStashPayload(payload) {
                NSLog("[ChatService] Push payment %@ has non-payment payload prefix, skipping", String(txId.prefix(12)))
                return false
            }
        }

        var decryptedPayment: PaymentPayload?
        if let payload, let privateKey {
            if let sealed = await decryptPaymentPayloadFromSealedHex(payload, privateKey: privateKey) {
                decryptedPayment = sealed
            } else {
                decryptedPayment = await decryptPaymentPayloadFromRawPayload(payload, privateKey: privateKey)
            }
        }

        var resolvedAmount = amount ?? decryptedPayment?.amount
        var messagePayloadHex: String?
        if let decryptedPayment,
           let data = try? JSONEncoder().encode(decryptedPayment) {
            messagePayloadHex = data.hexString
        }

        var receiver = myAddress
        if isOutgoing || resolvedAmount == nil {
            if let details = await resolvePaymentDetailsFromKaspa(
                txId: txId,
                senderHint: sender,
                myAddress: myAddress
            ) {
                receiver = details.receiver
                if resolvedAmount == nil {
                    resolvedAmount = details.amount
                }
                if decryptedPayment == nil,
                   let privateKey,
                   let payloadHex = details.payload,
                   let decrypted = await decryptPaymentPayloadFromRawPayload(payloadHex, privateKey: privateKey) {
                    decryptedPayment = decrypted
                    if resolvedAmount == nil {
                        resolvedAmount = decrypted.amount
                    }
                    if let data = try? JSONEncoder().encode(decrypted) {
                        messagePayloadHex = data.hexString
                    }
                }
            } else if isOutgoing {
                NSLog("[ChatService] Outgoing payment push: unable to resolve receiver for %@", txId)
                return false
            }
        }

        let blockTime = timestamp > 0 ? UInt64(timestamp) : nil
        let payment = PaymentResponse(
            txId: txId,
            sender: sender,
            receiver: receiver,
            amount: resolvedAmount,
            message: nil,
            blockTime: blockTime,
            acceptingBlock: nil,
            acceptingDaaScore: nil,
            messagePayload: messagePayloadHex
        )

        await processPayments(
            [payment],
            isOutgoing: isOutgoing,
            myAddress: myAddress,
            privateKey: privateKey
        )
        return true
    }

    /// Fetch a payment by txId (used when push payload is missing)
    func fetchPaymentByTxId(
        _ txId: String,
        sender: String,
        amount: UInt64?,
        timestamp: Int64
    ) async -> Bool {
        guard let wallet = WalletManager.shared.currentWallet else {
            NSLog("[ChatService] No wallet for fetching push payment")
            return false
        }

        if findLocalMessage(txId: txId) != nil {
            NSLog("[ChatService] Payment already exists: %@", txId)
            return true
        }

        let myAddress = wallet.publicAddress
        let isOutgoing = sender == myAddress

        if !isOutgoing, let amount {
            return await addPaymentFromPush(
                txId: txId,
                sender: sender,
                amount: amount,
                payload: nil,
                timestamp: timestamp
            )
        }

        if let entry = await NodePoolService.shared.getMempoolEntry(txId: txId, attempt: 1) {
            if !entry.payload.isEmpty, Self.isPaymentRawPayload(entry.payload) {
                if await addPaymentFromPush(
                    txId: txId,
                    sender: sender,
                    amount: amount,
                    payload: entry.payload,
                    timestamp: timestamp
                ) {
                    return true
                }
            }
        }

        if let fullTx = await fetchKaspaTransaction(txId: txId) {
            return await addPaymentFromPush(
                txId: txId,
                sender: sender,
                amount: amount,
                payload: fullTx.payload,
                timestamp: timestamp
            )
        }

        return false
    }

    /// Fetch a specific message by txId (for large payloads not included in push)
    func fetchMessageByTxId(_ txId: String, sender: String) async -> Bool {
        guard let _ = WalletManager.shared.currentWallet,
              let privateKey = WalletManager.shared.getPrivateKey() else {
            NSLog("[ChatService] No wallet for fetching push message")
            return false
        }

        // Check if already exists
        if findLocalMessage(txId: txId) != nil {
            NSLog("[ChatService] Message already exists: %@", txId)
            return true
        }

        let startTime = Date()

        // 1) Try mempool immediately
        if await fetchMessageByTxIdFromMempool(txId: txId, sender: sender, privateKey: privateKey) {
            return true
        }

        // 2) After 1.5s, try indexer
        let elapsed1 = Date().timeIntervalSince(startTime)
        if elapsed1 < 1.5 {
            let delayNs = UInt64((1.5 - elapsed1) * 1_000_000_000)
            try? await Task.sleep(nanoseconds: delayNs)
        }
        if await fetchMessageByTxIdFromIndexer(txId: txId, sender: sender, privateKey: privateKey) {
            return true
        }

        // 3) After 3s from start, try Kaspa REST
        let elapsed2 = Date().timeIntervalSince(startTime)
        if elapsed2 < 3.0 {
            let delayNs = UInt64((3.0 - elapsed2) * 1_000_000_000)
            try? await Task.sleep(nanoseconds: delayNs)
        }
        return await fetchMessageByTxIdFromKaspaRest(txId: txId, sender: sender, privateKey: privateKey)
    }

    private func fetchMessageByTxIdFromMempool(
        txId: String,
        sender: String,
        privateKey: Data
    ) async -> Bool {
        if let entry = await NodePoolService.shared.getMempoolEntry(txId: txId, attempt: 1),
           !entry.payload.isEmpty {
            if Self.isPaymentRawPayload(entry.payload) {
                let timestamp = Int64(Date().timeIntervalSince1970 * 1000)
                return await addPaymentFromPush(
                    txId: txId,
                    sender: sender,
                    amount: nil,
                    payload: entry.payload,
                    timestamp: timestamp
                )
            }
            if let decrypted = await decryptContextualMessageFromRawPayload(entry.payload, privateKey: privateKey) {
                let timestamp = Int64(Date().timeIntervalSince1970 * 1000)
                await addMessageFromPush(txId: txId, sender: sender, content: decrypted, timestamp: timestamp)
                return true
            }
        }
        return false
    }

    private func fetchMessageByTxIdFromIndexer(
        txId: String,
        sender: String,
        privateKey: Data
    ) async -> Bool {
        let settings = currentSettings
        guard let url = URL(string: "\(settings.indexerURL)/v1/messages/tx/\(txId)") else {
            NSLog("[ChatService] Invalid URL for fetching message")
            return false
        }

        do {
            let (data, response) = try await URLSession.shared.data(from: url)

            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                let status = (response as? HTTPURLResponse)?.statusCode ?? -1
                NSLog("[ChatService] Failed to fetch message tx: %@ (status=%d, bytes=%d)",
                      txId, status, data.count)
                return false
            }

            // Parse response and decrypt using existing method
            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let payload = json["payload"] as? String {
                NSLog("[ChatService] Indexer payload len=%d for %@", payload.count, String(txId.prefix(10)))
                if let decrypted = await decryptContextualMessage(payload, privateKey: privateKey) {
                    let timestamp = (json["timestamp"] as? Int64) ?? Int64(Date().timeIntervalSince1970 * 1000)
                    await addMessageFromPush(txId: txId, sender: sender, content: decrypted, timestamp: timestamp)
                    return true
                }

                if let decrypted = await decryptContextualMessageFromRawPayload(payload, privateKey: privateKey) {
                    let timestamp = (json["timestamp"] as? Int64) ?? Int64(Date().timeIntervalSince1970 * 1000)
                    await addMessageFromPush(txId: txId, sender: sender, content: decrypted, timestamp: timestamp)
                    return true
                }

                let prefix = payload.prefix(80)
                NSLog("[ChatService] Failed to decrypt push message: %@ (prefix=%@)",
                      txId, String(prefix))
            } else {
                let snippet = String(data: data.prefix(200), encoding: .utf8) ?? "<non-utf8>"
                NSLog("[ChatService] Indexer tx response missing payload for %@ (body=%@)", txId, snippet)
            }
        } catch {
            NSLog("[ChatService] Error fetching push message: %@", error.localizedDescription)
        }
        return false
    }

    private func fetchMessageByTxIdFromKaspaRest(
        txId: String,
        sender: String,
        privateKey: Data
    ) async -> Bool {
        guard let fullTx = await fetchKaspaTransaction(txId: txId) else {
            return false
        }

        if let payload = fullTx.payload, !payload.isEmpty {
            NSLog("[ChatService] Kaspa payload len=%d for %@", payload.count, String(txId.prefix(10)))
            if Self.isPaymentRawPayload(payload) {
                let ts = fullTx.blockTime ?? fullTx.acceptingBlockTime ?? UInt64(Date().timeIntervalSince1970 * 1000)
                return await addPaymentFromPush(
                    txId: txId,
                    sender: sender,
                    amount: nil,
                    payload: payload,
                    timestamp: Int64(ts)
                )
            }
            if let decrypted = await decryptContextualMessageFromRawPayload(payload, privateKey: privateKey) {
                let ts = fullTx.blockTime ?? fullTx.acceptingBlockTime ?? UInt64(Date().timeIntervalSince1970 * 1000)
                await addMessageFromPush(txId: txId, sender: sender, content: decrypted, timestamp: Int64(ts))
                return true
            } else {
                NSLog("[ChatService] Kaspa payload decrypt failed: %@", txId)
            }
        }

        return false
    }

    /// Build a Kaspa REST API URL using URLComponents for safe encoding.
    private func kaspaRestURL(path: String, queryItems: [URLQueryItem] = []) -> URL? {
        let settings = currentSettings
        guard var components = URLComponents(string: settings.kaspaRestAPIURL) else { return nil }
        components.path += path
        if !queryItems.isEmpty {
            components.queryItems = queryItems
        }
        return components.url
    }

    private func fetchKaspaTransaction(txId: String) async -> KaspaFullTransactionResponse? {
        guard let url = kaspaRestURL(
            path: "/transactions/\(txId)",
            queryItems: [URLQueryItem(name: "resolve_previous_outpoints", value: "light")]
        ) else {
            NSLog("[ChatService] Invalid Kaspa URL for tx fetch: %@", txId)
            return nil
        }

        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                NSLog("[ChatService] Kaspa API failed to fetch tx: %@", txId)
                return nil
            }
            return try? JSONDecoder().decode(KaspaFullTransactionResponse.self, from: data)
        } catch {
            NSLog("[ChatService] Kaspa tx fetch error: %@ (%@)", txId, error.localizedDescription)
            return nil
        }
    }

    private func resolvePaymentDetailsFromKaspa(
        txId: String,
        senderHint: String,
        myAddress: String
    ) async -> (receiver: String, amount: UInt64, payload: String?)? {
        guard let fullTx = await fetchKaspaTransaction(txId: txId) else {
            return nil
        }

        var totalToUs: UInt64 = 0
        var outputsToOthers: [(address: String, amount: UInt64)] = []

        for output in fullTx.outputs {
            guard let addr = output.scriptPublicKeyAddress, !addr.isEmpty else { continue }
            if addr == myAddress {
                totalToUs += output.amount
            } else {
                outputsToOthers.append((address: addr, amount: output.amount))
            }
        }

        if senderHint == myAddress {
            guard let recipient = outputsToOthers.min(by: { $0.amount < $1.amount }) else {
                return nil
            }
            return (receiver: recipient.address, amount: recipient.amount, payload: fullTx.payload)
        }

        guard totalToUs > 0 else {
            return nil
        }
        return (receiver: myAddress, amount: totalToUs, payload: fullTx.payload)
    }

    // MARK: - Realtime Updates Management
    // TODO: Fix realtimeUpdatesDisabled feature - currently broken, all functions in this section are unused until fixed

    /// Called when a contact's realtime updates setting is changed
    /// NOTE: Currently unused - feature disabled
    func updateUtxoSubscriptionForRealtimeChange() async {
        NSLog("[ChatService] Realtime setting changed, updating UTXO subscription")
        await setupUtxoSubscription()
    }

    /// Disable realtime updates for a contact (called from warning popup)
    /// NOTE: Currently unused - feature disabled
    func disableRealtimeForContact(_ contactAddress: String) {
        // Update in contactsManager
        if var contact = contactsManager.contacts.first(where: { $0.address == contactAddress }) {
            contact.realtimeUpdatesDisabled = true
            contactsManager.updateContact(contact)
            NSLog("[ChatService] Disabled realtime updates for %@", String(contactAddress.suffix(10)))

            // Update subscription
            Task {
                await updateUtxoSubscriptionForRealtimeChange()
            }
        }

        // Also update in conversations (need to create new conversation since contact is let)
        if let index = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            var updatedContact = conversations[index].contact
            updatedContact.realtimeUpdatesDisabled = true
            conversations[index] = Conversation(
                id: conversations[index].id,
                contact: updatedContact,
                messages: conversations[index].messages,
                unreadCount: conversations[index].unreadCount
            )
        }

        // Clear warning
        noisyContactWarning = nil
    }

    /// Dismiss the noisy contact warning without disabling
    /// NOTE: Currently unused - feature disabled
    func dismissNoisyContactWarning() {
        if let warning = noisyContactWarning {
            dismissedSpamWarnings.insert(warning.contactAddress)
            NSLog("[ChatService] Dismissed noisy contact warning for %@", String(warning.contactAddress.suffix(10)))
        }
        noisyContactWarning = nil
    }

    // MARK: - Disabled Contacts Polling
    // TODO: Fix realtimeUpdatesDisabled feature - currently broken, all functions in this section are unused until fixed

    /// Start periodic polling for contacts with realtime updates disabled
    /// NOTE: Currently unused - feature disabled
    private func startDisabledContactsPolling() {
        disabledContactsPollingTask?.cancel()

        // Get contacts with realtime disabled
        let disabledContacts = activeContacts.filter { $0.realtimeUpdatesDisabled }
        guard !disabledContacts.isEmpty else {
            NSLog("[ChatService] No contacts with realtime disabled, skipping polling setup")
            return
        }

        NSLog("[ChatService] Starting periodic polling for %d contacts with realtime disabled", disabledContacts.count)

        disabledContactsPollingTask = Task {
            while !Task.isCancelled {
                // Wait for polling interval
                try? await Task.sleep(nanoseconds: UInt64(disabledContactsPollingInterval * 1_000_000_000))

                guard !Task.isCancelled else { break }

                await pollDisabledContacts()
            }
        }
    }

    /// Poll messages for contacts with realtime updates disabled
    /// NOTE: Currently unused - feature disabled
    private func pollDisabledContacts() async {
        guard let wallet = WalletManager.shared.currentWallet else { return }
        let privateKey = WalletManager.shared.getPrivateKey()
        let nowMs = currentTimeMs()
        let fallbackSince = lastPollTime > syncReorgBufferMs ? lastPollTime - syncReorgBufferMs : lastPollTime

        let disabledContacts = await MainActor.run { contactsManager.activeContacts.filter { $0.realtimeUpdatesDisabled } }
        guard !disabledContacts.isEmpty else { return }

        NSLog("[ChatService] Polling %d contacts with realtime disabled", disabledContacts.count)

        for contact in disabledContacts {
            let contactAddress = contact.address
            let myAddress = wallet.publicAddress

            // Fetch contextual messages (incoming to us)
            let pollAliases = incomingAliases(for: contactAddress)
            if !pollAliases.isEmpty {
                for alias in pollAliases {
                    do {
                        let syncObjectKey = contextualSyncObjectKey(
                            direction: "in",
                            queryAddress: contactAddress,
                            alias: alias,
                            contactAddress: contactAddress
                        )
                        let startBlockTime = syncStartBlockTime(
                            for: syncObjectKey,
                            fallbackBlockTime: fallbackSince,
                            nowMs: nowMs
                        )
                        let effectiveSince = applyMessageRetention(to: startBlockTime)
                        let messages = try await KasiaAPIClient.shared.getContextualMessagesBySender(
                            address: contactAddress,
                            alias: alias,
                            limit: 50,
                            blockTime: effectiveSince
                        )
                        advanceSyncCursor(for: syncObjectKey, maxBlockTime: messages.compactMap { $0.blockTime }.max())

                        for contextMsg in messages {
                            var content = "[Encrypted message]"
                            if let privKey = privateKey {
                                if let decrypted = await decryptContextualMessage(contextMsg.messagePayload, privateKey: privKey) {
                                    content = decrypted
                                }
                            }
                            let msgType = messageType(for: content)

                            let message = ChatMessage(
                                txId: contextMsg.txId,
                                senderAddress: contextMsg.sender,
                                receiverAddress: myAddress,
                                content: content,
                                timestamp: Date(timeIntervalSince1970: TimeInterval((contextMsg.blockTime ?? 0) / 1000)),
                                blockTime: contextMsg.blockTime ?? 0,
                                acceptingBlock: contextMsg.acceptingBlock,
                                isOutgoing: false,
                                messageType: msgType
                            )

                            await MainActor.run {
                                addMessageToConversation(message, contactAddress: contactAddress)
                                if let blockTime = contextMsg.blockTime, blockTime > lastPollTime {
                                    updateLastPollTime(blockTime)
                                }
                            }
                        }
                    } catch {
                        if ChatService.handleDpiPaginationFailure(error, context: "disabled contacts contextual") {
                            continue
                        }
                        NSLog("[ChatService] Failed to poll messages from %@: %@", String(contactAddress.suffix(10)), error.localizedDescription)
                    }
                }
            }

            // Fetch incoming handshakes
            do {
                let handshakeKey = handshakeSyncObjectKey(direction: "in", address: myAddress)
                let handshakeSince = syncStartBlockTime(
                    for: handshakeKey,
                    fallbackBlockTime: fallbackSince,
                    nowMs: nowMs
                )
                let incoming = try await KasiaAPIClient.shared.getHandshakesByReceiver(
                    address: myAddress,
                    limit: 50,
                    blockTime: handshakeSince
                )
                advanceSyncCursor(for: handshakeKey, maxBlockTime: incoming.compactMap { $0.blockTime }.max())
                // Filter to only this contact's handshakes
                let contactHandshakes = incoming.filter { $0.sender == contactAddress }
                if !contactHandshakes.isEmpty, let privateKey = privateKey {
                    await processHandshakes(contactHandshakes, isOutgoing: false, myAddress: myAddress, privateKey: privateKey)
                }
            } catch {
                if ChatService.handleDpiPaginationFailure(error, context: "disabled contacts handshakes") {
                    continue
                }
                NSLog("[ChatService] Failed to poll handshakes from %@: %@", String(contactAddress.suffix(10)), error.localizedDescription)
            }
        }
    }

    // MARK: - Spam Detection
    // TODO: Fix realtimeUpdatesDisabled feature - currently broken, all functions in this section are unused until fixed

    /// Record an irrelevant TX notification for a contact address and check for spam
    /// NOTE: Currently unused - feature disabled
    private func recordIrrelevantTxNotification(contactAddress: String) {
        let now = Date()
        let oneMinuteAgo = now.addingTimeInterval(-60)

        // Add current timestamp
        var timestamps = contactTxNotifications[contactAddress] ?? []
        timestamps.append(now)

        // Remove timestamps older than 1 minute
        timestamps = timestamps.filter { $0 > oneMinuteAgo }
        contactTxNotifications[contactAddress] = timestamps

        // Check if threshold exceeded
        let spamThreshold = 20
        if timestamps.count >= spamThreshold {
            // Check if we've already dismissed this warning
            guard !dismissedSpamWarnings.contains(contactAddress) else { return }

            // Check if contact already has realtime disabled
            if let contact = contactsManager.activeContacts.first(where: { $0.address == contactAddress }) {
                guard !contact.realtimeUpdatesDisabled else { return }

                // Show warning
                NSLog("[ChatService] Contact %@ produced %d irrelevant TX notifications in 1 minute - showing warning",
                      String(contactAddress.suffix(10)), timestamps.count)

                noisyContactWarning = NoisyContactWarning(
                    contactAddress: contactAddress,
                    contactAlias: contact.alias,
                    txCount: timestamps.count
                )

                // Clear the timestamps to avoid repeated warnings
                contactTxNotifications[contactAddress] = []
            }
        }
    }

    /// Handle UTXO change notification - show payments immediately, resolve details in background
    private func handleUtxoChangeNotification(payload: Data) {
        guard let parsed = GrpcNotificationParser.parseUtxosChangedNotification(payload) else { return }
        enqueueUtxoNotification(parsed)
        processQueuedUtxoNotificationsIfNeeded()
    }

    private func enqueueUtxoNotification(_ parsed: ParsedUtxosChangedNotification) {
        let txIds = Set(parsed.added.map(\.transactionId)).union(parsed.removed.map(\.transactionId))
        guard !txIds.isEmpty else { return }

        if let existingIndex = queuedUtxoNotifications.firstIndex(where: { !$0.txIds.isDisjoint(with: txIds) }) {
            let existing = queuedUtxoNotifications[existingIndex]
            let merged = ParsedUtxosChangedNotification(
                added: existing.parsed.added + parsed.added,
                removed: existing.parsed.removed + parsed.removed
            )
            let mergedTxIds = existing.txIds.union(txIds)
            queuedUtxoNotifications[existingIndex] = QueuedUtxoNotification(parsed: merged, txIds: mergedTxIds)
        } else {
            queuedUtxoNotifications.append(QueuedUtxoNotification(parsed: parsed, txIds: txIds))
        }
    }

    private func processQueuedUtxoNotificationsIfNeeded() {
        guard !utxoFetchInFlight else { return }
        guard !queuedUtxoNotifications.isEmpty else { return }

        utxoFetchInFlight = true
        let queued = queuedUtxoNotifications.removeFirst()
        Task { @MainActor [weak self] in
            guard let self else { return }
            defer {
                self.utxoFetchInFlight = false
                self.processQueuedUtxoNotificationsIfNeeded()
            }
            await self.processParsedUtxoChangeNotification(queued.parsed)
        }
    }

    private func processParsedUtxoChangeNotification(_ parsed: ParsedUtxosChangedNotification) async {
        guard let wallet = WalletManager.shared.currentWallet else { return }
        let myAddress = wallet.publicAddress
        let privateKey = WalletManager.shared.getPrivateKey()

        // Collect contact addresses for quick lookup (exclude our own address)
        let contactAddresses = Set(activeContacts.map { $0.address }).subtracting([myAddress])

        // Build per-transaction address maps for sender inference
        var addedByTxId: [String: Set<String>] = [:]
        var removedByTxId: [String: Set<String>] = [:]
        for entry in parsed.added {
            if let address = entry.address {
                addedByTxId[entry.transactionId, default: []].insert(address)
            }
        }
        for entry in parsed.removed {
            if let address = entry.address {
                removedByTxId[entry.transactionId, default: []].insert(address)
            }
        }
        let allRemovedAddresses = Set(parsed.removed.compactMap { $0.address })

        // Log all UTXO notifications (added/removed) with amounts for debugging
        let groupedAdded = Dictionary(grouping: parsed.added, by: { $0.transactionId })
        let groupedRemoved = Dictionary(grouping: parsed.removed, by: { $0.transactionId })
        let allTxIds = Set(groupedAdded.keys).union(groupedRemoved.keys)
        for txId in allTxIds {
            let addedDesc = (groupedAdded[txId] ?? []).map { entry -> String in
                let addr = entry.address ?? "unknown"
                return "\(addr.suffix(10)):\(entry.amount)@\(entry.outputIndex)"
            }.joined(separator: ",")
            let removedDesc = (groupedRemoved[txId] ?? []).map { entry -> String in
                let addr = entry.address ?? "unknown"
                return "\(addr.suffix(10)):\(entry.amount)@\(entry.outputIndex)"
            }.joined(separator: ",")
            NSLog("[ChatService] UTXO notif %@ added=[%@] removed=[%@]",
                  String(txId.prefix(12)), addedDesc, removedDesc)
        }

        // Precompute txs that have both our output and a contact output but no spend info yet.
        var ambiguousDirectionTxIds = Set<String>()
        for (txId, addedAddresses) in addedByTxId {
            let hasMyOutput = addedAddresses.contains(myAddress)
            let hasContactOutput = !addedAddresses.intersection(contactAddresses).isEmpty
            let hasSpendInfo = !(removedByTxId[txId] ?? []).isEmpty
            if hasMyOutput && hasContactOutput && !hasSpendInfo {
                ambiguousDirectionTxIds.insert(txId)
            }
        }

        // Track txs we decided to resolve direction for, to skip other outputs in same batch.
        var deferredTxIds = Set<String>()
        var processedTxIds = Set<String>()

        // Fast-path is intentionally restricted to known local outgoing tx IDs.
        // Removed entries in UTXO notifications may reference previous outpoints and
        // are not reliable for generic sender/receiver inference.
        let txIdsForDirection = Set(groupedAdded.keys).union(groupedRemoved.keys)
        for txId in txIdsForDirection {
            if processedTxIds.contains(txId) { continue }
            guard isKnownOutgoingAttemptTxId(txId) else { continue }
            let addedEntries = groupedAdded[txId] ?? []
            let removedEntries = groupedRemoved[txId] ?? []
            if addedEntries.isEmpty || removedEntries.isEmpty { continue }

            let addedAddresses = Set(addedEntries.compactMap { $0.address })
            let removedAddresses = Set(removedEntries.compactMap { $0.address })

            let removedHasMy = removedAddresses.contains(myAddress)
            let removedContacts = removedAddresses.intersection(contactAddresses)
            let removedHasContact = !removedContacts.isEmpty
            let addedContacts = addedAddresses.intersection(contactAddresses)
            let addedHasContact = !addedContacts.isEmpty

            if removedHasMy && !removedHasContact && addedHasContact {
                // Outgoing payment from us to a known contact.
                if let receiver = addedContacts.first {
                    let amountToContact = addedEntries
                        .filter { $0.address == receiver }
                        .reduce(UInt64(0)) { $0 + $1.amount }
                    if amountToContact > 0 {
                        let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)
                        let payment = PaymentResponse(
                            txId: txId,
                            sender: myAddress,
                            receiver: receiver,
                            amount: amountToContact,
                            message: nil,
                            blockTime: nowMs,
                            acceptingBlock: nil,
                            acceptingDaaScore: addedEntries.first?.blockDaaScore ?? 0,
                            messagePayload: nil
                        )
                        await processPayments([payment], isOutgoing: true, myAddress: myAddress, deliveryStatus: .pending)
                        processedTxIds.insert(txId)
                    }
                }
            }
        }

        // Process added UTXOs
        for entry in parsed.added {
            // Skip coinbase transactions
            if entry.isCoinbase { continue }

            let utxoAddress = entry.address ?? ""
            let txId = entry.transactionId

            if processedTxIds.contains(txId) {
                continue
            }

            if ambiguousDirectionTxIds.contains(txId) {
                if !deferredTxIds.contains(txId) {
                    deferredTxIds.insert(txId)
                    NSLog("[ChatService] Incoming UTXO %@ has outputs to us and contact without spend info - resolving direction",
                          String(txId.prefix(12)))
                    if selfStashFirstAttemptAt[txId] == nil {
                        selfStashFirstAttemptAt[txId] = Date()
                    }
                    Task { @MainActor [weak self] in
                        await self?.startMempoolResolveIfNeeded(
                            txId: txId,
                            myAddress: myAddress,
                            contactAddresses: contactAddresses,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey
                        )
                        await self?.resolveSelfStashCandidate(
                            txId: txId,
                            myAddress: myAddress,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey,
                            retryDelayNs: 5_000_000_000
                        )
                    }
                }
                continue
            }

            if deferredTxIds.contains(txId) && utxoAddress != myAddress {
                continue
            }

            // Skip if we already have this transaction
            if let existing = findLocalMessage(txId: txId) {
                if !(existing.isOutgoing && existing.messageType == .payment) {
                    continue
                }
            }

            let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)

            let txAddedAddresses = addedByTxId[txId, default: []]
            let txRemovedAddresses = removedByTxId[txId, default: []]
            let weAreSpendingInTx = txRemovedAddresses.contains(myAddress)

            if shouldDeferClassification(
                txId: txId,
                txAddedAddresses: txAddedAddresses,
                contactAddresses: contactAddresses
            ) {
                if !deferredTxIds.contains(txId) {
                    deferredTxIds.insert(txId)
                    NSLog("[ChatService] Deferring realtime classification for %@ while local send is in-flight",
                          String(txId.prefix(12)))
                }
                continue
            }

            // Case 1: UTXO is to our address - incoming payment or handshake
            if utxoAddress == myAddress && !weAreSpendingInTx {
                // Infer sender from addresses in the SAME transaction only
                let possibleSenders = txAddedAddresses.subtracting([myAddress]).intersection(contactAddresses)
                let onlySelfOutput = txAddedAddresses.count == 1 && txAddedAddresses.contains(myAddress)
                let hasContactOutput = !txAddedAddresses.intersection(contactAddresses).isEmpty
                if onlySelfOutput {
                    NSLog("[ChatService] Incoming UTXO %@ has only self output - resolving before showing payment",
                          String(txId.prefix(12)))
                    deferredTxIds.insert(txId)
                    if selfStashFirstAttemptAt[txId] == nil {
                        selfStashFirstAttemptAt[txId] = Date()
                    }
                    Task { @MainActor [weak self] in
                        await self?.startMempoolResolveIfNeeded(
                            txId: txId,
                            myAddress: myAddress,
                            contactAddresses: contactAddresses,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey
                        )
                        await self?.resolveSelfStashCandidate(
                            txId: txId,
                            myAddress: myAddress,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey,
                            retryDelayNs: 5_000_000_000
                        )
                    }
                    continue
                }
                if hasContactOutput && !weAreSpendingInTx {
                    NSLog("[ChatService] Incoming UTXO %@ has contact output without spend info - resolving direction",
                          String(txId.prefix(12)))
                    deferredTxIds.insert(txId)
                    if selfStashFirstAttemptAt[txId] == nil {
                        selfStashFirstAttemptAt[txId] = Date()
                    }
                    Task { @MainActor [weak self] in
                        await self?.startMempoolResolveIfNeeded(
                            txId: txId,
                            myAddress: myAddress,
                            contactAddresses: contactAddresses,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey
                        )
                        await self?.resolveSelfStashCandidate(
                            txId: txId,
                            myAddress: myAddress,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey,
                            retryDelayNs: 5_000_000_000
                        )
                    }
                    continue
                }
                let outputSender = onlySelfOutput ? nil : possibleSenders.first
                let removedSender = txRemovedAddresses.intersection(contactAddresses).first
                let inferredSender = outputSender ?? removedSender

                if let sender = inferredSender {
                    // Skip self-stash transactions (sender == receiver) - these are handled as contextual messages
                    if sender == myAddress {
                        NSLog("[ChatService] Skipping self-stash payment %@ - handled as contextual message",
                              String(txId.prefix(12)))
                        continue
                    }

                    if outputSender != nil && removedSender == nil && !weAreSpendingInTx {
                        NSLog("[ChatService] Incoming UTXO %@ has ambiguous sender (output-only) - resolving before showing payment",
                              String(txId.prefix(12)))
                        enqueueIncomingPaymentResolution(
                            txId: txId,
                            amount: entry.amount,
                            myAddress: myAddress,
                            blockDaaScore: entry.blockDaaScore,
                            privateKey: privateKey
                        )
                        continue
                    }

                    // We have handshake with this contact - show payment immediately
                    NSLog("[ChatService] Incoming payment from %@ (%.2f KAS) - showing immediately",
                          String(sender.suffix(10)), Double(entry.amount) / 100_000_000)

                    let payment = PaymentResponse(
                        txId: txId,
                        sender: sender,
                        receiver: myAddress,
                        amount: entry.amount,
                        message: nil,
                        blockTime: nowMs,
                        acceptingBlock: nil,
                        acceptingDaaScore: entry.blockDaaScore,
                        messagePayload: nil
                    )

                    trackIncomingUtxoForPushReliability(txId: txId, senderAddress: sender)
                    await processPayments([payment], isOutgoing: false, myAddress: myAddress, deliveryStatus: .pending)
                    enqueueIncomingPaymentResolution(
                        txId: txId,
                        amount: entry.amount,
                        myAddress: myAddress,
                        blockDaaScore: entry.blockDaaScore,
                        privateKey: privateKey,
                        senderHint: sender
                    )
                } else {
                    // Unknown sender - need to resolve from REST API
                    NSLog("[ChatService] Incoming payment from unknown sender (tx: %@) - resolving...", String(txId.prefix(12)))
                    enqueueIncomingPaymentResolution(
                        txId: txId,
                        amount: entry.amount,
                        myAddress: myAddress,
                        blockDaaScore: entry.blockDaaScore,
                        privateKey: privateKey
                    )
                }
            }
            // Case 2: UTXO is to a contact address
            else if contactAddresses.contains(utxoAddress) {
                if weAreSpendingInTx {
                    // If outputs include our own address but we have no pending outgoing message,
                    // defer direction resolution to avoid misclassifying incoming payments.
                    let hasMyOutputInTx = txAddedAddresses.contains(myAddress)
                    let pendingOutgoingForContact = conversations
                        .first(where: { $0.contact.address == utxoAddress })?
                        .messages.filter { $0.isOutgoing && $0.deliveryStatus == .pending } ?? []

                    if promoteKnownOutgoingAttempt(contactAddress: utxoAddress, newTxId: txId) {
                        NSLog("[ChatService] Outgoing tx matched tracked pending message: %@", String(txId.prefix(12)))
                        continue
                    }

                    if hasMyOutputInTx && pendingOutgoingForContact.isEmpty {
                        NSLog("[ChatService] Outgoing-looking tx %@ has self output without pending message - resolving direction",
                              String(txId.prefix(12)))
                        if selfStashFirstAttemptAt[txId] == nil {
                            selfStashFirstAttemptAt[txId] = Date()
                        }
                        Task { @MainActor [weak self] in
                            await self?.startMempoolResolveIfNeeded(
                                txId: txId,
                                myAddress: myAddress,
                                contactAddresses: contactAddresses,
                                blockDaaScore: entry.blockDaaScore,
                                privateKey: privateKey
                            )
                            await self?.resolveSelfStashCandidate(
                                txId: txId,
                                myAddress: myAddress,
                                blockDaaScore: entry.blockDaaScore,
                                privateKey: privateKey,
                                retryDelayNs: 5_000_000_000
                            )
                        }
                        continue
                    }

                    // Skip if there's a pending outgoing handshake/message for this contact
                    // (race condition: UTXO notification arrives before pending txId is updated)
                    let hasNonPaymentPending = pendingOutgoingForContact.contains { $0.messageType != .payment }
                    if hasNonPaymentPending {
                        NSLog("[ChatService] Skipping outgoing payment to %@ - non-payment message in flight",
                              String(utxoAddress.suffix(10)))
                        continue
                    }

                    // Own self-stash transactions: contextual messages we sent to a contact
                    // If we have this message locally (we sent it from this device), skip
                    // Otherwise, trigger CloudKit import (sent from another device with same wallet)
                    if utxoAddress == myAddress {
                        if findLocalMessage(txId: txId) != nil {
                            NSLog("[ChatService] Own self-stash %@ already exists locally - skipping",
                                  String(txId.prefix(12)))
                            continue
                        }

                        // Message sent from another device - trigger CloudKit import to get message text
                        // (indexer only has encrypted payload we can't decrypt)
                        NSLog("[ChatService] Own self-stash %@ not found locally - triggering CloudKit import for multi-device sync",
                              String(txId.prefix(12)))
                        Task { @MainActor [weak self] in
                            let importAfter = Date()
                            let didImport = await MessageStore.shared.fetchCloudKitChanges(
                                reason: "self-stash-missing-\(String(txId.prefix(12)))",
                                after: importAfter,
                                timeout: 12.0
                            )
                            self?.loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
                            await self?.handleCloudKitImportResult(txId: txId, didImport: didImport)
                        }
                        continue
                    }

                    // We sent this - outgoing payment to contact
                    NSLog("[ChatService] Outgoing payment to %@ (%.2f KAS) - showing immediately",
                          String(utxoAddress.suffix(10)), Double(entry.amount) / 100_000_000)

                    let payment = PaymentResponse(
                        txId: txId,
                        sender: myAddress,
                        receiver: utxoAddress,
                        amount: entry.amount,
                        message: nil,
                        blockTime: nowMs,
                        acceptingBlock: nil,
                        acceptingDaaScore: entry.blockDaaScore,
                        messagePayload: nil
                    )

                    await processPayments([payment], isOutgoing: true, myAddress: myAddress)
                } else {
                    // Contact's self-stash - might be a message to us
                    // Check if sender is the same as receiver (self-stash pattern)
                    let contactIsSpending = txRemovedAddresses.contains(utxoAddress) || allRemovedAddresses.contains(utxoAddress)
                    if contactIsSpending {
                        if findLocalMessage(txId: txId) != nil {
                            continue
                        }
                        trackIncomingUtxoForPushReliability(txId: txId, senderAddress: utxoAddress)
                        // Skip if we already have a resolve in flight for this txId
                        guard !(await inFlightResolveTracker.contains(txId)) else {
                            continue
                        }
                        await inFlightResolveTracker.insert(txId)

                        NSLog("[ChatService] Self-stash from %@ detected (tx: %@) - resolving for message...",
                              String(utxoAddress.suffix(10)), String(txId.prefix(12)))

                        // Need to resolve TX to get payload for decryption
                        Task.detached { [weak self] in
                            await self?.resolveAndProcessSelfStash(
                                txId: txId,
                                contactAddress: utxoAddress,
                                myAddress: myAddress,
                                blockDaaScore: entry.blockDaaScore,
                                privateKey: privateKey
                            )
                            await self?.inFlightResolveTracker.remove(txId)
                        }
                    } else {
                        // Third party sent to contact - not relevant to us
                        // TODO: Fix realtimeUpdatesDisabled feature - re-enable spam detection when fixed
                        // recordIrrelevantTxNotification(contactAddress: utxoAddress)
                    }
                }
            }
            // Case 3: UTXO to unknown address (e.g., change) - skip silently
        }

        if !parsed.added.isEmpty {
            saveMessages()
        }

        // Refresh balance to reflect UTXO changes
        _ = try? await WalletManager.shared.refreshBalance()
    }

    private func enqueueIncomingPaymentResolution(
        txId: String,
        amount: UInt64,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?,
        senderHint: String? = nil
    ) {
        incomingResolutionAmountHints[txId] = amount
        incomingResolutionPendingTxIds.insert(txId)
        incomingResolutionWarningTxIds.remove(txId)
        if let retryTask = resolveRetryTasks.removeValue(forKey: txId) {
            retryTask.cancel()
        }

        Task.detached { [weak self] in
            guard let self else { return }
            await self.runIncomingPaymentResolution(
                txId: txId,
                amount: amount,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                senderHint: senderHint
            )
        }
    }

    private func runIncomingPaymentResolution(
        txId: String,
        amount: UInt64,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?,
        senderHint: String? = nil
    ) async {
        guard !(await inFlightResolveTracker.contains(txId)) else {
            NSLog("[ChatService] Incoming resolve already in flight for %@", String(txId.prefix(12)))
            return
        }
        await inFlightResolveTracker.insert(txId)
        await resolveAndProcessIncomingPayment(
            txId: txId,
            amount: amount,
            myAddress: myAddress,
            blockDaaScore: blockDaaScore,
            privateKey: privateKey,
            senderHint: senderHint
        )
        await inFlightResolveTracker.remove(txId)
    }

    /// Resolve and process incoming payment when sender/payload may be incomplete.
    /// Keeps provisional UTXO fast-path payments pending until classification is finalized.
    private func resolveAndProcessIncomingPayment(
        txId: String,
        amount: UInt64,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?,
        senderHint: String? = nil
    ) async {
        incomingResolutionAmountHints[txId] = amount
        incomingResolutionPendingTxIds.insert(txId)

        if let existing = findLocalMessage(txId: txId) {
            if existing.isOutgoing || existing.messageType != .payment {
                clearIncomingResolutionTracking(txId: txId)
                return
            }
        }

        let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)
        let attempt = resolveRetryCounts[txId, default: 0] + 1

        var payloadHint = mempoolPayloadByTxId[txId]
        if (payloadHint?.isEmpty ?? true),
           let mempoolEntry = await NodePoolService.shared.getMempoolEntry(txId: txId, attempt: attempt),
           !mempoolEntry.payload.isEmpty {
            payloadHint = mempoolEntry.payload
            mempoolPayloadByTxId[txId] = mempoolEntry.payload
        }

        let txInfo = await resolveTransactionInfo(txId: txId, ourAddress: myAddress)
        let infoSender = txInfo?.sender
        let fallbackSender = senderHint
        let senderFromInfoOrHint = (infoSender?.isEmpty == false ? infoSender : fallbackSender)
        let blockTimeMs = txInfo?.blockTimeMs ?? nowMs

        var payloadHex = payloadHint
        if (payloadHex?.isEmpty ?? true),
           let infoPayload = txInfo?.payload,
           !infoPayload.isEmpty {
            payloadHex = infoPayload
        }

        if let payloadHex, !payloadHex.isEmpty {
            if await handleIncomingSpecialPayload(
                txId: txId,
                payloadHex: payloadHex,
                senderAddress: senderFromInfoOrHint,
                myAddress: myAddress,
                blockTimeMs: blockTimeMs,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey
            ) {
                clearIncomingResolutionTracking(txId: txId)
                return
            }
        }

        // Fallback handshake check from indexer if payload is still missing from tx endpoints.
        if let handshake = await checkIndexerForHandshake(txId: txId, myAddress: myAddress) {
            NSLog("[ChatService] Handshake detected from indexer for %@", String(txId.prefix(12)))
            removeMessage(txId: txId)
            if let privateKey = privateKey {
                await processHandshakes([handshake], isOutgoing: false, myAddress: myAddress, privateKey: privateKey)
                saveMessages()
                saveConversationAliases()
            }
            clearIncomingResolutionTracking(txId: txId)
            return
        }

        guard let info = txInfo else {
            NSLog("[ChatService] Failed to resolve incoming payment %@ from mempool/indexer/REST - scheduling retry", String(txId.prefix(12)))
            scheduleResolveRetry(
                txId: txId,
                amount: amount,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                senderHint: senderHint
            )
            return
        }

        var fullTx = (payloadHex?.isEmpty ?? true || info.sender == myAddress)
            ? await fetchKaspaFullTransaction(txId: txId, retries: 2, delayNs: 800_000_000)
            : nil

        if (payloadHex?.isEmpty ?? true),
           let fullPayload = fullTx?.payload,
           !fullPayload.isEmpty {
            payloadHex = fullPayload
            let senderFromFullTx = deriveSenderFromFullTx(fullTx!, excluding: myAddress)
            if await handleIncomingSpecialPayload(
                txId: txId,
                payloadHex: fullPayload,
                senderAddress: senderFromInfoOrHint ?? senderFromFullTx,
                myAddress: myAddress,
                blockTimeMs: fullTx?.acceptingBlockTime ?? fullTx?.blockTime ?? blockTimeMs,
                blockDaaScore: fullTx?.acceptingBlockBlueScore ?? blockDaaScore,
                privateKey: privateKey
            ) {
                clearIncomingResolutionTracking(txId: txId)
                return
            }
        }

        // If sender is our address, this may still be an incoming payment if sender was mis-resolved.
        if info.sender == myAddress {
            if fullTx == nil {
                fullTx = await fetchKaspaFullTransaction(txId: txId, retries: 3, delayNs: 800_000_000)
            }

            if let fullTx,
               let derivedSender = deriveSenderFromFullTx(fullTx, excluding: myAddress) {
                NSLog("[ChatService] Sender mismatch for %@ - treating as incoming from %@",
                      String(txId.prefix(12)), String(derivedSender.suffix(10)))
                let resolvedAmount = amount > 0 ? amount : sumOutputsToAddress(fullTx.outputs, address: myAddress)
                incomingResolutionPendingTxIds.remove(txId)
                let incoming = PaymentResponse(
                    txId: txId,
                    sender: derivedSender,
                    receiver: myAddress,
                    amount: resolvedAmount,
                    message: nil,
                    blockTime: fullTx.acceptingBlockTime ?? fullTx.blockTime ?? nowMs,
                    acceptingBlock: fullTx.acceptingBlockHash,
                    acceptingDaaScore: fullTx.acceptingBlockBlueScore ?? blockDaaScore,
                    messagePayload: fullTx.payload
                )
                await processPayments([incoming], isOutgoing: false, myAddress: myAddress, deliveryStatus: .sent)
                clearIncomingResolutionTracking(txId: txId)
                return
            }

            if let fullTx {
                let contacts = Set(activeContacts.map { $0.address }).subtracting([myAddress])
                if let output = fullTx.outputs.first(where: { output in
                    guard let addr = output.scriptPublicKeyAddress else { return false }
                    return contacts.contains(addr)
                }) {
                    let receiver = output.scriptPublicKeyAddress ?? ""
                    incomingResolutionPendingTxIds.remove(txId)
                    let payment = PaymentResponse(
                        txId: txId,
                        sender: myAddress,
                        receiver: receiver,
                        amount: output.amount,
                        message: nil,
                        blockTime: fullTx.acceptingBlockTime ?? fullTx.blockTime ?? nowMs,
                        acceptingBlock: fullTx.acceptingBlockHash,
                        acceptingDaaScore: fullTx.acceptingBlockBlueScore ?? blockDaaScore,
                        messagePayload: fullTx.payload
                    )
                    await processPayments([payment], isOutgoing: true, myAddress: myAddress, deliveryStatus: .sent)
                    clearIncomingResolutionTracking(txId: txId)
                    return
                }
            }

            NSLog("[ChatService] Incoming payment %@ still ambiguous (sender=self) - scheduling retry",
                  String(txId.prefix(12)))
            scheduleResolveRetry(
                txId: txId,
                amount: amount,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                senderHint: senderHint
            )
            return
        }

        // We still don't have a payload/fullTx. Keep pending and retry rather than misclassifying.
        if (payloadHex?.isEmpty ?? true) && fullTx == nil {
            NSLog("[ChatService] Incoming payment %@ missing payload/fullTx after resolution attempt - scheduling retry",
                  String(txId.prefix(12)))
            scheduleResolveRetry(
                txId: txId,
                amount: amount,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                senderHint: senderHint
            )
            return
        }

        // Confirmed as regular payment.
        incomingResolutionPendingTxIds.remove(txId)
        let finalSender = isValidKaspaAddress(info.sender) ? info.sender : (senderFromInfoOrHint ?? info.sender)
        let payment = PaymentResponse(
            txId: txId,
            sender: finalSender,
            receiver: myAddress,
            amount: amount,
            message: nil,
            blockTime: fullTx?.acceptingBlockTime ?? fullTx?.blockTime ?? info.blockTimeMs,
            acceptingBlock: fullTx?.acceptingBlockHash,
            acceptingDaaScore: fullTx?.acceptingBlockBlueScore ?? blockDaaScore,
            messagePayload: payloadHex ?? info.payload
        )
        trackIncomingUtxoForPushReliability(txId: txId, senderAddress: finalSender)
        await processPayments([payment], isOutgoing: false, myAddress: myAddress, deliveryStatus: .sent)
        clearIncomingResolutionTracking(txId: txId)
    }

    private func scheduleResolveRetry(
        txId: String,
        amount: UInt64,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?,
        senderHint: String? = nil
    ) {
        if let existing = findLocalMessage(txId: txId),
           !existing.isOutgoing,
           existing.messageType == .payment {
            incomingResolutionPendingTxIds.insert(txId)
        }
        incomingResolutionAmountHints[txId] = amount

        let current = resolveRetryCounts[txId, default: 0]
        if current >= incomingResolutionMaxAdditionalRetries {
            NSLog("[ChatService] Incoming payment %@ unresolved after %d retries - marking warning",
                  String(txId.prefix(12)), current)
            if let existing = findLocalMessage(txId: txId),
               !existing.isOutgoing,
               existing.messageType == .payment {
                markIncomingResolutionWarning(txId: txId)
            } else {
                clearIncomingResolutionTracking(txId: txId)
            }
            return
        }

        let nextAttempt = current + 1
        resolveRetryCounts[txId] = nextAttempt
        let delayNs = resolveRetryDelayNs(forAttempt: nextAttempt)

        if let task = resolveRetryTasks.removeValue(forKey: txId) {
            task.cancel()
        }

        resolveRetryTasks[txId] = Task { [weak self] in
            try? await Task.sleep(nanoseconds: delayNs)
            guard let self else { return }
            guard !Task.isCancelled else { return }
            await MainActor.run {
                _ = self.resolveRetryTasks.removeValue(forKey: txId)
            }

            await self.runIncomingPaymentResolution(
                txId: txId,
                amount: amount,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                senderHint: senderHint
            )
        }
    }

    private func resolveRetryDelayNs(forAttempt attempt: Int) -> UInt64 {
        let exponent = max(0, attempt - 1)
        let multiplier = UInt64(1) << min(exponent, 30)
        let rawDelay = incomingResolutionBaseDelayNs > UInt64.max / multiplier
            ? UInt64.max
            : incomingResolutionBaseDelayNs * multiplier
        return min(rawDelay, incomingResolutionMaxDelayNs)
    }

    private func markIncomingResolutionWarning(txId: String) {
        incomingResolutionPendingTxIds.remove(txId)
        incomingResolutionWarningTxIds.insert(txId)
        resolveRetryCounts.removeValue(forKey: txId)
        if let task = resolveRetryTasks.removeValue(forKey: txId) {
            task.cancel()
        }

        guard let existing = findLocalMessage(txId: txId), !existing.isOutgoing, existing.messageType == .payment else {
            clearIncomingResolutionTracking(txId: txId)
            return
        }

        if updateIncomingPaymentDeliveryStatus(txId: txId, deliveryStatus: .warning) {
            saveMessages()
        }
    }

    private func clearIncomingResolutionTracking(txId: String) {
        incomingResolutionPendingTxIds.remove(txId)
        incomingResolutionWarningTxIds.remove(txId)
        incomingResolutionAmountHints.removeValue(forKey: txId)
        resolveRetryCounts.removeValue(forKey: txId)
        if let task = resolveRetryTasks.removeValue(forKey: txId) {
            task.cancel()
        }
        mempoolPayloadByTxId.removeValue(forKey: txId)
    }

    private func incomingAmountHint(txId: String) -> UInt64? {
        if let hint = incomingResolutionAmountHints[txId] {
            return hint
        }
        guard let existing = findLocalMessage(txId: txId), !existing.isOutgoing else { return nil }
        return parseKasAmountFromPaymentContent(existing.content)
    }

    private func parseKasAmountFromPaymentContent(_ content: String) -> UInt64? {
        let pattern = "(?:Received|Sent)\\s+([0-9][0-9,]*(?:\\.[0-9]{1,8})?)\\s+KAS"
        guard let regex = try? NSRegularExpression(pattern: pattern) else { return nil }
        let range = NSRange(content.startIndex..<content.endIndex, in: content)
        guard let match = regex.firstMatch(in: content, options: [], range: range),
              match.numberOfRanges > 1,
              let amountRange = Range(match.range(at: 1), in: content) else {
            return nil
        }
        let normalized = content[amountRange].replacingOccurrences(of: ",", with: "")
        guard let kas = Double(normalized) else { return nil }
        return UInt64((kas * 100_000_000).rounded())
    }

    private func updateIncomingPaymentDeliveryStatus(
        txId: String,
        deliveryStatus: ChatMessage.DeliveryStatus
    ) -> Bool {
        for index in conversations.indices {
            if let msgIndex = conversations[index].messages.firstIndex(where: { $0.txId == txId && !$0.isOutgoing }) {
                let existing = conversations[index].messages[msgIndex]
                if existing.deliveryStatus == deliveryStatus {
                    return false
                }
                let updated = ChatMessage(
                    id: existing.id,
                    txId: existing.txId,
                    senderAddress: existing.senderAddress,
                    receiverAddress: existing.receiverAddress,
                    content: existing.content,
                    timestamp: existing.timestamp,
                    blockTime: existing.blockTime,
                    acceptingBlock: existing.acceptingBlock,
                    isOutgoing: existing.isOutgoing,
                    messageType: existing.messageType,
                    deliveryStatus: deliveryStatus
                )
                conversations[index].messages[msgIndex] = updated
                return true
            }
        }
        return false
    }

    private func handleIncomingSpecialPayload(
        txId: String,
        payloadHex: String,
        senderAddress: String?,
        myAddress: String,
        blockTimeMs: UInt64,
        blockDaaScore: UInt64,
        privateKey: Data?
    ) async -> Bool {
        if isHandshakePayload(payloadHex) {
            guard let senderAddress, !senderAddress.isEmpty, senderAddress != myAddress else {
                return false
            }
            NSLog("[ChatService] Incoming payment %@ resolved as handshake", String(txId.prefix(12)))
            removeMessage(txId: txId)
            let handshake = HandshakeResponse(
                txId: txId,
                sender: senderAddress,
                receiver: myAddress,
                blockTime: blockTimeMs,
                acceptingBlock: nil,
                acceptingDaaScore: blockDaaScore,
                messagePayload: payloadHex
            )
            if let privateKey = privateKey {
                await processHandshakes([handshake], isOutgoing: false, myAddress: myAddress, privateKey: privateKey)
                saveMessages()
                saveConversationAliases()
            }
            return true
        }

        if isContextualPayload(payloadHex) {
            NSLog("[ChatService] Incoming payment %@ resolved as contextual - replacing", String(txId.prefix(12)))
            removeMessage(txId: txId)
            if let privateKey,
               let senderAddress,
               shouldAttemptSelfStashDecryption(payloadHex: payloadHex, contactAddress: senderAddress),
               let decrypted = await decryptContextualMessageFromRawPayload(payloadHex, privateKey: privateKey) {
                let ts = Int64(blockTimeMs > 0 ? blockTimeMs : UInt64(Date().timeIntervalSince1970 * 1000))
                await addMessageFromPush(txId: txId, sender: senderAddress, content: decrypted, timestamp: ts)
            }
            return true
        }

        if isSelfStashPayload(payloadHex) {
            NSLog("[ChatService] Incoming payment %@ resolved as self-stash - removing", String(txId.prefix(12)))
            removeMessage(txId: txId)
            return true
        }

        return false
    }

    private func retryIncomingWarningResolutionsOnSync(
        myAddress: String,
        privateKey: Data?
    ) async {
        var warningTxIds = incomingResolutionWarningTxIds
        for conversation in conversations {
            for message in conversation.messages where !message.isOutgoing && message.messageType == .payment && message.deliveryStatus == .warning {
                warningTxIds.insert(message.txId)
            }
        }
        incomingResolutionWarningTxIds.formUnion(warningTxIds)

        let candidates = warningTxIds.filter { txId in
            guard let message = findLocalMessage(txId: txId) else { return false }
            return !message.isOutgoing && message.messageType == .payment && message.deliveryStatus == .warning
        }

        guard !candidates.isEmpty else { return }
        NSLog("[ChatService] Retrying %d unresolved incoming payment(s) on sync", candidates.count)

        for txId in candidates.sorted() {
            guard let amount = incomingAmountHint(txId: txId), amount > 0 else {
                NSLog("[ChatService] Skipping warning tx %@ on sync retry - missing amount hint", String(txId.prefix(12)))
                continue
            }
            resolveRetryCounts.removeValue(forKey: txId)
            if let retryTask = resolveRetryTasks.removeValue(forKey: txId) {
                retryTask.cancel()
            }
            incomingResolutionWarningTxIds.remove(txId)
            incomingResolutionPendingTxIds.insert(txId)
            if updateIncomingPaymentDeliveryStatus(txId: txId, deliveryStatus: .pending) {
                saveMessages()
            }
            enqueueIncomingPaymentResolution(
                txId: txId,
                amount: amount,
                myAddress: myAddress,
                blockDaaScore: 0,
                privateKey: privateKey
            )
        }
    }

    private func resolveSelfStashCandidate(
        txId: String,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?,
        retryDelayNs: UInt64 = 30_000_000_000
    ) async {
        let now = Date()
        if selfStashFirstAttemptAt[txId] == nil {
            selfStashFirstAttemptAt[txId] = now
        }
        let elapsed = now.timeIntervalSince(selfStashFirstAttemptAt[txId] ?? now)
        if mempoolResolvedTxIds.contains(txId) {
            clearSelfStashRetryState(txId: txId)
            return
        }
        if elapsed < 2.5 {
            let delayNs = UInt64(max(0.1, 2.5 - elapsed) * 1_000_000_000)
            scheduleSelfStashRetry(
                txId: txId,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                delayNs: delayNs
            )
            return
        }

        if let fullTx = await fetchKaspaFullTransaction(txId: txId, retries: 3, delayNs: 800_000_000) {
            let inputAddresses = (fullTx.inputs ?? []).compactMap { $0.previousOutpointAddress }.filter { !$0.isEmpty }
            let outputAddresses = fullTx.outputs.compactMap { $0.scriptPublicKeyAddress }.filter { !$0.isEmpty }

            let allInputsSelf = !inputAddresses.isEmpty && inputAddresses.allSatisfy { $0 == myAddress }
            let allOutputsSelf = !outputAddresses.isEmpty && outputAddresses.allSatisfy { $0 == myAddress }
            let uniqueInputs = Set(inputAddresses)
            let uniqueOutputs = Set(outputAddresses)
            let hasSelfInput = uniqueInputs.contains(myAddress)
            let hasSelfOutput = uniqueOutputs.contains(myAddress)
            NSLog("[ChatService] Tx %@ inputs=%d (self=%d) outputs=%d (self=%d)",
                  String(txId.prefix(12)), uniqueInputs.count, hasSelfInput ? 1 : 0,
                  uniqueOutputs.count, hasSelfOutput ? 1 : 0)

            if allInputsSelf && allOutputsSelf {
                if findLocalMessage(txId: txId) != nil {
                    return
                }
                NSLog("[ChatService] Verified self-stash %@ - triggering CloudKit import", String(txId.prefix(12)))
                let importAfter = Date()
                let didImport = await MessageStore.shared.fetchCloudKitChanges(
                    reason: "self-stash-verified-\(String(txId.prefix(12)))",
                    after: importAfter,
                    timeout: 12.0
                )
                await MainActor.run {
                    self.loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
                }
                await handleCloudKitImportResult(txId: txId, didImport: didImport)
                clearSelfStashRetryState(txId: txId)
                return
            }

            // If we are spending, treat as outgoing payment (change back to self is common).
            if allInputsSelf {
                let contacts = Set(activeContacts.map { $0.address }).subtracting([myAddress])
                let contactOutputs = fullTx.outputs.filter { output in
                    guard let addr = output.scriptPublicKeyAddress else { return false }
                    return contacts.contains(addr)
                }
                if let contactOutput = contactOutputs.max(by: { $0.amount < $1.amount }) {
                    let receiver = contactOutput.scriptPublicKeyAddress ?? ""
                    let payment = PaymentResponse(
                        txId: txId,
                        sender: myAddress,
                        receiver: receiver,
                        amount: contactOutput.amount,
                        message: nil,
                        blockTime: fullTx.acceptingBlockTime ?? fullTx.blockTime ?? UInt64(Date().timeIntervalSince1970 * 1000),
                        acceptingBlock: fullTx.acceptingBlockHash,
                        acceptingDaaScore: fullTx.acceptingBlockBlueScore ?? blockDaaScore,
                        messagePayload: fullTx.payload
                    )
                    await processPayments([payment], isOutgoing: true, myAddress: myAddress)
                } else {
                    NSLog("[ChatService] Resolved %@ as outgoing with no contact output - ignoring", String(txId.prefix(12)))
                }
                clearSelfStashRetryState(txId: txId)
                return
            }

            // Inputs are not all ours: treat as incoming payment to our address.
            let amountToMe = sumOutputsToAddress(fullTx.outputs, address: myAddress)
            guard amountToMe > 0 else {
                NSLog("[ChatService] Resolved %@ without output to us - ignoring", String(txId.prefix(12)))
                return
            }

            var sender = deriveSenderFromFullTx(fullTx, excluding: myAddress)
            if sender == nil {
                sender = await fetchAnyInputAddress(txId: txId, excludeAddress: myAddress)
            }
            guard let resolvedSender = sender else {
                NSLog("[ChatService] Resolved %@ without sender - scheduling retry", String(txId.prefix(12)))
                scheduleSelfStashRetry(
                    txId: txId,
                    myAddress: myAddress,
                    blockDaaScore: blockDaaScore,
                    privateKey: privateKey,
                    delayNs: retryDelayNs
                )
                return
            }

            if let existing = findLocalMessage(txId: txId) {
                if existing.isOutgoing {
                    NSLog("[ChatService] Removing outgoing message for %@ - resolved as incoming", String(txId.prefix(12)))
                    removeMessage(txId: txId)
                } else {
                    return
                }
            }

            let payment = PaymentResponse(
                txId: txId,
                sender: resolvedSender,
                receiver: myAddress,
                amount: amountToMe,
                message: nil,
                blockTime: fullTx.acceptingBlockTime ?? fullTx.blockTime ?? UInt64(Date().timeIntervalSince1970 * 1000),
                acceptingBlock: fullTx.acceptingBlockHash,
                acceptingDaaScore: fullTx.acceptingBlockBlueScore ?? blockDaaScore,
                messagePayload: fullTx.payload
            )
            await processPayments([payment], isOutgoing: false, myAddress: myAddress)
            clearSelfStashRetryState(txId: txId)
            return
        }

        scheduleSelfStashRetry(
            txId: txId,
            myAddress: myAddress,
            blockDaaScore: blockDaaScore,
            privateKey: privateKey,
            delayNs: retryDelayNs
        )
    }

    private func clearSelfStashRetryState(txId: String) {
        selfStashRetryCounts.removeValue(forKey: txId)
        selfStashFirstAttemptAt.removeValue(forKey: txId)
        mempoolResolvedTxIds.remove(txId)
        mempoolPayloadByTxId.removeValue(forKey: txId)
        cloudKitImportFirstAttemptAt.removeValue(forKey: txId)
        cloudKitImportLastObservedAt.removeValue(forKey: txId)
        cloudKitImportRetryTokenByTxId.removeValue(forKey: txId)
    }


    private func sumOutputsToAddress(_ outputs: [KaspaFullTxOutput], address: String) -> UInt64 {
        outputs.reduce(0) { partial, output in
            guard let addr = output.scriptPublicKeyAddress, addr == address else { return partial }
            return partial + output.amount
        }
    }

    private func startMempoolResolveIfNeeded(
        txId: String,
        myAddress: String,
        contactAddresses: Set<String>,
        blockDaaScore: UInt64,
        privateKey: Data?
    ) async {
        if mempoolResolveInFlight.contains(txId) {
            return
        }
        mempoolResolveInFlight.insert(txId)
        defer { mempoolResolveInFlight.remove(txId) }

        NSLog("[ChatService] Mempool lookup start for %@", String(txId.prefix(12)))
        let entry = await NodePoolService.shared.getMempoolEntry(txId: txId, attempt: 1)
        if entry == nil {
            NSLog("[ChatService] Mempool lookup miss for %@", String(txId.prefix(12)))
            return
        }
        guard let entry else { return }
        if !entry.payload.isEmpty {
            mempoolPayloadByTxId[txId] = entry.payload
        }

        // Avoid REST if we can classify using mempool + our UTXO set
        if mempoolResolvedTxIds.contains(txId) {
            return
        }

        let outputsByAddress = Dictionary(grouping: entry.outputs, by: { $0.address })
        let hasMyOutput = outputsByAddress.keys.contains(myAddress)
        let contactOutputAddresses = outputsByAddress.keys.filter { contactAddresses.contains($0) }
        guard hasMyOutput && !contactOutputAddresses.isEmpty else {
            if hasMyOutput && contactOutputAddresses.isEmpty {
                let utxos = (try? await fetchCachedUtxos(for: myAddress)) ?? []
                let outpointKeys = Set(utxos.map { "\($0.outpoint.transactionId):\($0.outpoint.index)" })
                let allInputsAreOurs = !entry.inputs.isEmpty && entry.inputs.allSatisfy { input in
                    outpointKeys.contains("\(input.txId):\(input.index)")
                }
                if allInputsAreOurs {
                    if !entry.payload.isEmpty {
                        let payload = entry.payload
                        if isContextualPayload(payload) || isSelfStashPayload(payload) {
                            NSLog("[ChatService] Mempool resolved %@ as self-stash (inputs=ours, outputs=self) - triggering CloudKit import",
                                  String(txId.prefix(12)))
                            let importAfter = Date()
                            let didImport = await MessageStore.shared.fetchCloudKitChanges(
                                reason: "self-stash-mempool-\(String(txId.prefix(12)))",
                                after: importAfter,
                                timeout: 12.0
                            )
                            await MainActor.run {
                                self.loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
                            }
                            await handleCloudKitImportResult(txId: txId, didImport: didImport)
                        } else {
                            NSLog("[ChatService] Mempool resolved %@ as self-spend (inputs=ours, outputs=self) - ignoring",
                                  String(txId.prefix(12)))
                        }
                    } else {
                        NSLog("[ChatService] Mempool resolved %@ as self-spend (inputs=ours, outputs=self) - ignoring",
                              String(txId.prefix(12)))
                    }
                    mempoolResolvedTxIds.insert(txId)
                }
            }
            return
        }

        let utxos = (try? await fetchCachedUtxos(for: myAddress)) ?? []
        let outpointKeys = Set(utxos.map { "\($0.outpoint.transactionId):\($0.outpoint.index)" })
        let hasMyInput = entry.inputs.contains { input in
            outpointKeys.contains("\(input.txId):\(input.index)")
        }

        if hasMyInput {
            // Outgoing payment from us to a known contact
            if let receiver = contactOutputAddresses.first,
               let outputs = outputsByAddress[receiver] {
                let amountToContact = outputs.reduce(UInt64(0)) { $0 + $1.amount }
                if amountToContact > 0 {
                    NSLog("[ChatService] Mempool resolved %@ as outgoing to %@",
                          String(txId.prefix(12)), String(receiver.suffix(10)))
                    let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)
                    let payment = PaymentResponse(
                        txId: txId,
                        sender: myAddress,
                        receiver: receiver,
                        amount: amountToContact,
                        message: nil,
                        blockTime: nowMs,
                        acceptingBlock: nil,
                        acceptingDaaScore: blockDaaScore,
                        messagePayload: entry.payload
                    )
                    await processPayments([payment], isOutgoing: true, myAddress: myAddress, privateKey: privateKey, deliveryStatus: .sent)
                    mempoolResolvedTxIds.insert(txId)
                }
            }
            return
        }

        // Incoming payment to us; infer sender from contact output (change address)
        if contactOutputAddresses.count == 1,
           let sender = contactOutputAddresses.first,
           let myOutputs = outputsByAddress[myAddress] {
            let amountToMe = myOutputs.reduce(UInt64(0)) { $0 + $1.amount }
            if amountToMe > 0 {
                NSLog("[ChatService] Mempool resolved %@ as incoming from %@",
                      String(txId.prefix(12)), String(sender.suffix(10)))
                let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)
                let payment = PaymentResponse(
                    txId: txId,
                    sender: sender,
                    receiver: myAddress,
                    amount: amountToMe,
                    message: nil,
                    blockTime: nowMs,
                    acceptingBlock: nil,
                    acceptingDaaScore: blockDaaScore,
                    messagePayload: entry.payload
                )
                await processPayments([payment], isOutgoing: false, myAddress: myAddress, privateKey: privateKey, deliveryStatus: .sent)
                mempoolResolvedTxIds.insert(txId)
            }
        }
    }

    private func scheduleSelfStashRetry(
        txId: String,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?,
        delayNs: UInt64 = 30_000_000_000
    ) {
        let now = Date()
        if selfStashFirstAttemptAt[txId] == nil {
            selfStashFirstAttemptAt[txId] = now
        }
        let elapsed = now.timeIntervalSince(selfStashFirstAttemptAt[txId] ?? now)
        let current = selfStashRetryCounts[txId, default: 0]
        if elapsed >= 30.0 && current >= 1 {
            NSLog("[ChatService] Self-stash %@ unresolved after %.0fs - triggering full sync",
                  String(txId.prefix(12)), elapsed)
            Task { @MainActor in
                await fetchNewMessages()
            }
            selfStashRetryCounts.removeValue(forKey: txId)
            selfStashFirstAttemptAt.removeValue(forKey: txId)
            return
        }

        selfStashRetryCounts[txId] = current + 1
        Task { @MainActor [weak self] in
            try? await Task.sleep(nanoseconds: delayNs)
            await self?.resolveSelfStashCandidate(
                txId: txId,
                myAddress: myAddress,
                blockDaaScore: blockDaaScore,
                privateKey: privateKey,
                retryDelayNs: delayNs
            )
        }
    }

    /// Resolve and process self-stash (contextual message) from contact
    /// Uses fast mempool RPC racing against REST API since sender is already known
    private func resolveAndProcessSelfStash(
        txId: String,
        contactAddress: String,
        myAddress: String,
        blockDaaScore: UInt64,
        privateKey: Data?
    ) async {
        if findLocalMessage(txId: txId) != nil {
            return
        }
        guard let privateKey = privateKey else { return }

        // Race mempool RPC vs REST API for payload
        // For self-stash, we already know the sender - just need payload
        let payload = await resolvePayloadOnly(txId: txId)

        guard let payloadHex = payload, !payloadHex.isEmpty else {
            if findLocalMessage(txId: txId) != nil {
                return
            }
            NSLog("[ChatService] Failed to resolve payload for self-stash %@ - scheduling retry", String(txId.prefix(12)))
            scheduleSelfStashRetry(txId: txId, myAddress: myAddress, blockDaaScore: blockDaaScore, privateKey: privateKey)
            return
        }

        if findLocalMessage(txId: txId) != nil {
            return
        }

        guard shouldAttemptSelfStashDecryption(payloadHex: payloadHex, contactAddress: contactAddress) else {
            return
        }

        // Try to decrypt the payload
        if let decrypted = await decryptContextualMessageFromRawPayload(payloadHex, privateKey: privateKey) {
            await MainActor.run {
                // Skip if already processed
                if findLocalMessage(txId: txId) != nil { return }

                let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)
                NSLog("[ChatService] Decrypted message from %@ via fast resolve", String(contactAddress.suffix(10)))

                let message = ChatMessage(
                    txId: txId,
                    senderAddress: contactAddress,
                    receiverAddress: myAddress,
                    content: decrypted,
                    timestamp: Date(),
                    blockTime: nowMs,
                    acceptingBlock: nil,
                    isOutgoing: false,
                    messageType: messageType(for: decrypted)
                )

                addMessageToConversation(message, contactAddress: contactAddress)

                if nowMs > lastPollTime {
                    updateLastPollTime(nowMs)
                }

                saveMessages()
            }
        } else {
            // Decryption failed - this self-stash is not for us (different recipient)
            // TODO: Fix realtimeUpdatesDisabled feature - re-enable spam detection when fixed
            // await MainActor.run {
            //     recordIrrelevantTxNotification(contactAddress: contactAddress)
            // }
        }
    }

    private func shouldAttemptSelfStashDecryption(payloadHex: String, contactAddress: String) -> Bool {
        guard let payloadData = Self.hexStringToData(payloadHex),
              let payloadString = String(data: payloadData, encoding: .utf8) else {
            NSLog("[ChatService] Raw payload: failed to decode hex to string")
            return false
        }

        guard let alias = Self.extractContextualAlias(fromRawPayloadString: payloadString) else {
            return false
        }

        // Check both legacy and deterministic aliases
        let expectedAliases = incomingAliases(for: contactAddress)
        if !expectedAliases.isEmpty {
            if expectedAliases.contains(alias) {
                return true
            }
            let expectedPrimary = primaryConversationAlias(for: contactAddress) ?? routingStates[contactAddress]?.deterministicMyAlias ?? "-"
            NSLog("[ChatService] Raw payload: alias mismatch for %@ (expected %@, got %@) - skipping",
                  String(contactAddress.suffix(10)), expectedPrimary, alias)
            return false
        }

        if aliasBelongsToAnotherContact(alias, excluding: contactAddress) {
            NSLog("[ChatService] Raw payload: alias belongs to another contact (%@) - skipping", alias)
            return false
        }

        // Unknown alias: allow decrypt attempt to avoid dropping messages for new contacts.
        return true
    }

    private func primaryConversationAlias(for address: String) -> String? {
        if let primary = conversationPrimaryAliases[address] {
            return primary
        }
        return conversationAliases[address]?.sorted().first
    }

    private func primaryOurAlias(for address: String) -> String? {
        if let primary = ourPrimaryAliases[address] {
            return primary
        }
        return ourAliases[address]?.sorted().first
    }

    private func addConversationAlias(_ alias: String, for address: String, blockTime: UInt64?) {
        var set = conversationAliases[address] ?? []
        set.insert(alias)
        conversationAliases[address] = set

        if let time = blockTime {
            let current = conversationAliasUpdatedAt[address] ?? 0
            if time >= current {
                conversationPrimaryAliases[address] = alias
                conversationAliasUpdatedAt[address] = time
            }
        } else if conversationPrimaryAliases[address] == nil {
            conversationPrimaryAliases[address] = alias
        }

        // Keep routing state legacy set in sync; upgrade to hybrid if needed
        if routingStates[address] != nil {
            routingStates[address]?.legacyIncomingAliases.insert(alias)
            if routingStates[address]?.mode == .deterministicOnly {
                routingStates[address]?.mode = .hybrid
            }
        }
    }

    private func addOurAlias(_ alias: String, for address: String, blockTime: UInt64?) {
        var set = ourAliases[address] ?? []
        set.insert(alias)
        ourAliases[address] = set

        if let time = blockTime {
            let current = ourAliasUpdatedAt[address] ?? 0
            if time >= current {
                ourPrimaryAliases[address] = alias
                ourAliasUpdatedAt[address] = time
            }
        } else if ourPrimaryAliases[address] == nil {
            ourPrimaryAliases[address] = alias
        }

        // Keep routing state legacy set in sync; upgrade to hybrid if needed
        if routingStates[address] != nil {
            routingStates[address]?.legacyOutgoingAliases.insert(alias)
            if routingStates[address]?.mode == .deterministicOnly {
                routingStates[address]?.mode = .hybrid
            }
        }
    }

    private func aliasBelongsToAnotherContact(_ alias: String, excluding contactAddress: String) -> Bool {
        for (address, aliases) in conversationAliases where address != contactAddress {
            if aliases.contains(alias) {
                return true
            }
        }
        return false
    }

    /// Fast payload resolution: try mempool first, fall back to REST API
    /// Used for self-stash messages where sender is already known
    private func resolvePayloadOnly(txId: String) async -> String? {
        let startTime = Date()

        if findLocalMessage(txId: txId) != nil {
            return nil
        }

        // Step 1: Single immediate mempool query to all active nodes
        NSLog("[ChatService] Mempool lookup start for self-stash %@", String(txId.prefix(12)))
        if let entry = await NodePoolService.shared.getMempoolEntry(txId: txId, attempt: 1) {
            if !entry.payload.isEmpty {
                mempoolPayloadByTxId[txId] = entry.payload
                if findLocalMessage(txId: txId) != nil {
                    return nil
                }
                let elapsed = Date().timeIntervalSince(startTime) * 1000
                NSLog("[ChatService] Payload resolved from mempool in %.0fms for %@",
                      elapsed, String(txId.prefix(12)))
                return entry.payload
            }
        }
        NSLog("[ChatService] Mempool lookup miss for self-stash %@", String(txId.prefix(12)))

        // Step 2: Fall back to REST API with polling
        guard let url = kaspaRestURL(path: "/transactions/\(txId)") else { return nil }

        for attempt in 1...30 {
            if findLocalMessage(txId: txId) != nil {
                return nil
            }
            // Exponential backoff: first 10 attempts = 500ms, then doubles (capped at 5s)
            let delayMs: UInt64
            if attempt <= 10 {
                delayMs = 500
            } else {
                let exponent = attempt - 11
                delayMs = min(UInt64(1000 * (1 << exponent)), 5000)
            }

            do {
                let (data, response) = try await URLSession.shared.data(from: url)

                guard let httpResponse = response as? HTTPURLResponse,
                      (200...299).contains(httpResponse.statusCode) else {
                    try? await Task.sleep(nanoseconds: delayMs * 1_000_000)
                    continue
                }

                // Parse just the payload field
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let payloadHex = json["payload"] as? String,
                   !payloadHex.isEmpty {
                    if findLocalMessage(txId: txId) != nil {
                        return nil
                    }
                    let elapsed = Date().timeIntervalSince(startTime) * 1000
                    NSLog("[ChatService] Payload resolved from REST in %.0fms (attempt %d) for %@",
                          elapsed, attempt, String(txId.prefix(12)))
                    return payloadHex
                }

                try? await Task.sleep(nanoseconds: delayMs * 1_000_000)
            } catch {
                try? await Task.sleep(nanoseconds: delayMs * 1_000_000)
            }
        }

        let elapsed = Date().timeIntervalSince(startTime) * 1000
        NSLog("[ChatService] Payload resolution timeout after %.0fms for %@",
              elapsed, String(txId.prefix(12)))
        return nil
    }

    /// Remove a message by txId (used when payment turns out to be handshake)
    private func removeMessage(txId: String) {
        clearIncomingResolutionTracking(txId: txId)
        for i in 0..<conversations.count {
            if let msgIndex = conversations[i].messages.firstIndex(where: { $0.txId == txId }) {
                markConversationDirty(conversations[i].contact.address)
                conversations[i].messages.remove(at: msgIndex)
                saveMessages()
                return
            }
        }
    }

    private func configureAPIIfNeeded() async {
        // KasiaAPIClient now reads from settings directly
        // No explicit configuration needed
        if !isConfigured {
            isConfigured = true
            NSLog("[ChatService] Configuring API with indexer URL: %@", apiClient.currentBaseURL ?? "unknown")

            // Only load messages if store is ready (don't block on fresh imports)
            if messageStore.isStoreLoaded {
                loadMessagesFromStoreIfNeeded(onlyIfEmpty: true)
            } else {
                NSLog("[ChatService] Store not loaded yet, skipping message load from store")
            }
        }
    }

    func stopPolling() {
        pollTask?.cancel()
        pollTask = nil
        subscriptionRetryTask?.cancel()
        subscriptionRetryTask = nil
        pendingResubscriptionTask?.cancel()
        pendingResubscriptionTask = nil
        needsResubscriptionAfterSync = false

        // Clean up UTXO subscription
        if let token = utxoSubscriptionToken {
            NodePoolService.shared.removeNotificationHandler(token)
            utxoSubscriptionToken = nil
        }
        NodePoolService.shared.unsubscribeUtxosChanged()
        isUtxoSubscribed = false
        NSLog("[ChatService] Polling and UTXO subscription stopped")
    }

    func stopPollingTimerOnly() {
        pollTask?.cancel()
        pollTask = nil
        NSLog("[ChatService] Polling task stopped")
    }

    /// Called when entering a chat view - sets active conversation for unread tracking
    /// Local state is already synced on startup, real-time updates come from RPC notifications
    func enterConversation(for address: String) {
        activeConversationAddress = address
        NSLog("[ChatService] Entered conversation for %@", String(address.suffix(12)))
    }

    /// Returns total number of stored messages for a contact in current wallet scope.
    func storedMessageCount(for contactAddress: String) -> Int {
        messageStore.countMessages(contactAddress: contactAddress)
    }

    /// Returns total number of stored messages using a background worker to avoid
    /// blocking the main actor during expensive Core Data count queries.
    func storedMessageCountAsync(for contactAddress: String) async -> Int {
        await Task.detached(priority: .utility) {
            MessageStore.shared.countMessages(contactAddress: contactAddress)
        }.value
    }

    /// Read cursor for a conversation, preferring effective CloudKit marker status.
    /// Falls back to local conversation read status if no markers are available.
    func readCursor(for contactAddress: String) -> (txId: String?, blockTime: Int64)? {
        if let effective = messageStore.recomputeEffectiveReadStatus(conversationId: contactAddress) {
            return (effective.lastReadTxId, effective.lastReadBlockTime)
        }
        if let status = messageStore.fetchReadStatus(contactAddress: contactAddress) {
            return (status.lastReadTxId, status.lastReadBlockTime)
        }
        return nil
    }

    /// Loads the next older page of messages for a conversation from persistent store.
    /// This avoids holding full history in memory while still allowing on-demand scrolling.
    /// - Returns: number of messages loaded into the in-memory conversation.
    @discardableResult
    func loadOlderMessagesPage(for contactAddress: String, pageSize: Int) -> Int {
        guard pageSize > 0 else { return 0 }
        guard let index = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else { return 0 }
        guard let key = messageEncryptionKey() else { return 0 }
        guard !olderHistoryExhaustedContacts.contains(contactAddress) else { return 0 }

        let cursor = oldestLoadedCursor(in: conversations[index])
        let page = messageStore.fetchMessagesPage(
            contactAddress: contactAddress,
            decryptionKey: key,
            limit: pageSize,
            olderThan: cursor
        )
        guard !page.messages.isEmpty else {
            olderHistoryExhaustedContacts.insert(contactAddress)
            return 0
        }

        var updatedConversations = conversations
        var conversation = updatedConversations[index]
        let beforeCount = conversation.messages.count
        conversation.messages = dedupeMessages(page.messages + conversation.messages)
        let loadedCount = max(0, conversation.messages.count - beforeCount)
        if page.hasMore {
            olderHistoryExhaustedContacts.remove(contactAddress)
        } else {
            olderHistoryExhaustedContacts.insert(contactAddress)
        }

        updatedConversations[index] = conversation
        conversations = updatedConversations
        return loadedCount
    }

    /// Async/background fetch variant of `loadOlderMessagesPage` that keeps Core Data page
    /// reads and decrypt work off the main actor. The final in-memory merge still happens on
    /// the main actor for published state consistency.
    @discardableResult
    func loadOlderMessagesPageAsync(for contactAddress: String, pageSize: Int) async -> Int {
        guard pageSize > 0 else { return 0 }
        guard !olderHistoryExhaustedContacts.contains(contactAddress) else { return 0 }
        if let inFlight = olderHistoryPageTasks[contactAddress] {
            return await inFlight.value
        }

        let task = Task { @MainActor [weak self] in
            guard let self else { return 0 }
            return await self.loadOlderMessagesPageInternal(for: contactAddress, pageSize: pageSize)
        }
        olderHistoryPageTasks[contactAddress] = task
        let loaded = await task.value
        olderHistoryPageTasks[contactAddress] = nil
        return loaded
    }

    private func loadOlderMessagesPageInternal(for contactAddress: String, pageSize: Int) async -> Int {
        guard let index = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else { return 0 }
        guard let key = messageEncryptionKey() else { return 0 }
        let cursor = oldestLoadedCursor(in: conversations[index])

        let page = await messageStore.fetchMessagesPageAsync(
            contactAddress: contactAddress,
            decryptionKey: key,
            limit: pageSize,
            olderThan: cursor
        )
        guard !page.messages.isEmpty else {
            olderHistoryExhaustedContacts.insert(contactAddress)
            return 0
        }

        guard let conversationIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return 0
        }
        var updatedConversations = conversations
        var conversation = updatedConversations[conversationIndex]
        let beforeCount = conversation.messages.count
        conversation.messages = dedupeMessages(page.messages + conversation.messages)
        let loadedCount = max(0, conversation.messages.count - beforeCount)

        if page.hasMore {
            olderHistoryExhaustedContacts.remove(contactAddress)
        } else {
            olderHistoryExhaustedContacts.insert(contactAddress)
        }

        updatedConversations[conversationIndex] = conversation
        conversations = updatedConversations
        return loadedCount
    }

    private func oldestLoadedCursor(in conversation: Conversation) -> MessageStore.MessagePageCursor? {
        guard let oldest = conversation.messages.min(by: isMessageOrderedBefore) else { return nil }
        return MessageStore.MessagePageCursor(
            blockTime: Int64(oldest.blockTime),
            timestamp: oldest.timestamp,
            txId: oldest.txId
        )
    }

    /// Called when leaving a chat view - clears active conversation and flushes read status
    func leaveConversation() {
        // Flush read status for this conversation before clearing
        if let address = activeConversationAddress {
            ReadStatusSyncManager.shared.userLeftConversation(address)
        }
        activeConversationAddress = nil
        NSLog("[ChatService] Left conversation")
    }

    /// Fetch only handshakes (lightweight, needed to establish encryption keys)
    /// Call this before CloudKit sync so we have aliases ready
    /// NOTE: Assumes configureAPIIfNeeded() was already called by startup flow
    private func fetchHandshakesOnly() async {
        guard let wallet = WalletManager.shared.currentWallet else {
            NSLog("[ChatService] fetchHandshakesOnly: No wallet")
            return
        }

        guard isConfigured else {
            NSLog("[ChatService] fetchHandshakesOnly: API not configured")
            return
        }

        let nowMs = currentTimeMs()
        let fallbackSince = lastPollTime > syncReorgBufferMs ? lastPollTime - syncReorgBufferMs : lastPollTime
        let incomingHandshakeKey = handshakeSyncObjectKey(direction: "in", address: wallet.publicAddress)
        let outgoingHandshakeKey = handshakeSyncObjectKey(direction: "out", address: wallet.publicAddress)
        let incomingSince = syncStartBlockTime(
            for: incomingHandshakeKey,
            fallbackBlockTime: fallbackSince,
            nowMs: nowMs
        )
        let outgoingSince = syncStartBlockTime(
            for: outgoingHandshakeKey,
            fallbackBlockTime: fallbackSince,
            nowMs: nowMs
        )
        let privateKey = WalletManager.shared.getPrivateKey()

        NSLog("[ChatService] Fetching incoming handshakes (since=%llu)...", incomingSince)
        // Fetch incoming handshakes
        guard let incoming = await retryUntilSuccess(
            label: "fetch incoming handshakes (bootstrap)",
            operation: { [self] in try await fetchIncomingHandshakes(for: wallet.publicAddress, blockTime: incomingSince) }
        ) else {
            NSLog("[ChatService] Failed to fetch incoming handshakes")
            return
        }
        advanceSyncCursor(for: incomingHandshakeKey, maxBlockTime: incoming.compactMap { $0.blockTime }.max())
        NSLog("[ChatService] Fetched %d incoming handshakes", incoming.count)

        NSLog("[ChatService] Fetching outgoing handshakes...")


        guard let outgoing = await retryUntilSuccess(
            label: "fetch outgoing handshakes (bootstrap)",
            operation: { [self] in try await fetchOutgoingHandshakes(for: wallet.publicAddress, blockTime: outgoingSince) }
        ) else {
            NSLog("[ChatService] Failed to fetch outgoing handshakes")
            return
        }
        advanceSyncCursor(for: outgoingHandshakeKey, maxBlockTime: outgoing.compactMap { $0.blockTime }.max())
        NSLog("[ChatService] Fetched %d outgoing handshakes", outgoing.count)

        NSLog("[ChatService] Handshake bootstrap: %d incoming, %d outgoing", incoming.count, outgoing.count)

        // Process handshakes to extract aliases
        NSLog("[ChatService] Processing handshakes...")
        await processHandshakes(incoming, isOutgoing: false, myAddress: wallet.publicAddress, privateKey: privateKey)
        await processHandshakes(outgoing, isOutgoing: true, myAddress: wallet.publicAddress, privateKey: privateKey)
        NSLog("[ChatService] Handshakes processed")

        // Fetch saved handshakes from self-stash
        NSLog("[ChatService] Fetching saved handshakes from self-stash...")
        _ = await retryUntilSuccess(
            label: "fetch saved handshakes (bootstrap)",
            operation: { [self] in try await fetchSavedHandshakes(myAddress: wallet.publicAddress, privateKey: privateKey) }
        )
        NSLog("[ChatService] Self-stash fetch complete")

        saveConversationAliases()
        saveOurAliases()
        saveConversationIds()
        saveRoutingStates()

        NSLog("[ChatService] Handshake bootstrap complete. Aliases: %d, Our aliases: %d, Routing: %d", conversationAliases.count, ourAliases.count, routingStates.count)
    }

    func fetchNewMessages(forActiveOnly activeAddress: String? = nil) async {
        guard let wallet = WalletManager.shared.currentWallet else {
            print("[ChatService] Skipping fetch - no wallet")
            return
        }

        // Ensure API is configured
        await configureAPIIfNeeded()
        guard isConfigured else {
            print("[ChatService] Skipping fetch - API not configured")
            return
        }

        // Try to flush pending self-stash transactions if any
        await attemptPendingSelfStashSends()

        var activeFetchSucceeded = false
        if let active = activeAddress {
            chatFetchStates[active] = .loading
        } else {
            isLoading = true
        }
        beginSyncBlockTime()
        isSyncInProgress = true  // Enable batching for Core Data writes
        var syncSucceeded = false
        let shouldSuppressNotifications = activeAddress == nil && lastPollTime == 0
        let previousSuppress = suppressNotificationsUntilSynced
        if shouldSuppressNotifications {
            suppressNotificationsUntilSynced = true
        }
        defer {
            if shouldSuppressNotifications {
                suppressNotificationsUntilSynced = previousSuppress
            }
            isSyncInProgress = false  // Disable batching before final save
            if let active = activeAddress {
                if activeFetchSucceeded {
                    chatFetchStates.removeValue(forKey: active)
                } else {
                    chatFetchStates[active] = .failed
                }
            }
            isLoading = false
            // Check if resubscription was deferred during sync
            executeResubscriptionIfNeeded()
            endSyncBlockTime(success: syncSucceeded)  // This handles batched save
        }

        let isFullFetch = activeAddress == nil
        print("[ChatService] Fetching messages for: \(wallet.publicAddress.suffix(10)), fullFetch=\(isFullFetch), lastPollTime=\(lastPollTime)")

        // Fetch handshakes first (they establish aliases) with per-object cursors.
        let nowMs = currentTimeMs()
        let fallbackSince = lastPollTime > syncReorgBufferMs ? lastPollTime - syncReorgBufferMs : lastPollTime
        let messageSince = applyMessageRetention(to: fallbackSince)
        let incomingHandshakeKey = handshakeSyncObjectKey(direction: "in", address: wallet.publicAddress)
        let outgoingHandshakeKey = handshakeSyncObjectKey(direction: "out", address: wallet.publicAddress)
        let incomingHandshakeSince = syncStartBlockTime(
            for: incomingHandshakeKey,
            fallbackBlockTime: fallbackSince,
            nowMs: nowMs
        )
        let outgoingHandshakeSince = syncStartBlockTime(
            for: outgoingHandshakeKey,
            fallbackBlockTime: fallbackSince,
            nowMs: nowMs
        )

        guard let incoming = await retryUntilSuccess(
            label: "fetch incoming handshakes",
            operation: { [self] in try await fetchIncomingHandshakes(for: wallet.publicAddress, blockTime: incomingHandshakeSince) }
        ) else {
            return
        }
        advanceSyncCursor(for: incomingHandshakeKey, maxBlockTime: incoming.compactMap { $0.blockTime }.max())

        guard let outgoing = await retryUntilSuccess(
            label: "fetch outgoing handshakes",
            operation: { [self] in try await fetchOutgoingHandshakes(for: wallet.publicAddress, blockTime: outgoingHandshakeSince) }
        ) else {
            return
        }
        advanceSyncCursor(for: outgoingHandshakeKey, maxBlockTime: outgoing.compactMap { $0.blockTime }.max())

        var inPayments: [PaymentResponse] = []
        var outPayments: [PaymentResponse] = []
        // Fetch payments only on full fetch AND when not using UTXO subscription
        // (or on initial sync when lastPaymentFetchTime is 0)
        let shouldFetchPayments = activeAddress == nil && (!isUtxoSubscribed || lastPaymentFetchTime == 0)
        if shouldFetchPayments {
            NSLog("[ChatService] === FETCHING PAYMENTS (full fetch, utxoSubscribed=%d) ===", isUtxoSubscribed ? 1 : 0)
            guard let incomingPayments = await retryUntilSuccess(
                label: "fetch incoming payments",
                operation: { [self] in try await fetchIncomingPayments(for: wallet.publicAddress, blockTime: messageSince) }
            ) else {
                return
            }
            inPayments = incomingPayments

            guard let outgoingPayments = await retryUntilSuccess(
                label: "fetch outgoing payments",
                operation: { [self] in try await fetchOutgoingPayments(for: wallet.publicAddress, blockTime: messageSince) }
            ) else {
                return
            }
            outPayments = outgoingPayments
            NSLog("[ChatService] === PAYMENT FETCH COMPLETE: in=%d, out=%d ===", inPayments.count, outPayments.count)

            // Update last payment fetch time for UTXO subscription
            if !inPayments.isEmpty || !outPayments.isEmpty {
                let maxInTime = inPayments.compactMap { $0.blockTime }.max() ?? 0
                let maxOutTime = outPayments.compactMap { $0.blockTime }.max() ?? 0
                lastPaymentFetchTime = max(maxInTime, maxOutTime, lastPaymentFetchTime)
            } else if lastPaymentFetchTime == 0 {
                // Set to current time if no payments found on initial sync
                lastPaymentFetchTime = fallbackSince > 0 ? fallbackSince : UInt64(Date().timeIntervalSince1970 * 1000)
            }
        } else if activeAddress != nil {
            NSLog("[ChatService] Skipping payment fetch - active conversation only")
        } else {
            NSLog("[ChatService] Skipping payment fetch - UTXO subscription active")
        }

        NSLog("[ChatService] Fetched: %d incoming handshakes, %d outgoing handshakes", incoming.count, outgoing.count)
        if shouldFetchPayments {
            NSLog("[ChatService] Fetched: %d incoming payments, %d outgoing payments", inPayments.count, outPayments.count)
        }

        // Get private key for decryption
        let privateKey = WalletManager.shared.getPrivateKey()

        // Process handshakes - this extracts aliases
        await processHandshakes(incoming, isOutgoing: false, myAddress: wallet.publicAddress, privateKey: privateKey)
        await processHandshakes(outgoing, isOutgoing: true, myAddress: wallet.publicAddress, privateKey: privateKey)
        if shouldFetchPayments {
            // Filter out handshake transactions from payment lists to prevent
            // handshakes being duplicated as payment messages (Bug 4: wallet re-import)
            let handshakeTxIds = Set(incoming.map { $0.txId } + outgoing.map { $0.txId })
            if !handshakeTxIds.isEmpty {
                let inBefore = inPayments.count
                let outBefore = outPayments.count
                inPayments = inPayments.filter { !handshakeTxIds.contains($0.txId) }
                outPayments = outPayments.filter { !handshakeTxIds.contains($0.txId) }
                let filtered = (inBefore - inPayments.count) + (outBefore - outPayments.count)
                if filtered > 0 {
                    NSLog("[ChatService] Filtered %d handshake txs from payment results", filtered)
                }
            }
            await processPayments(inPayments, isOutgoing: false, myAddress: wallet.publicAddress, privateKey: privateKey)
            await processPayments(outPayments, isOutgoing: true, myAddress: wallet.publicAddress, privateKey: privateKey)
        }

        // Fetch saved handshakes from self-stash to get our aliases for outgoing messages
        guard let _ = await retryUntilSuccess(
            label: "fetch saved handshakes",
            operation: { [self] in try await fetchSavedHandshakes(myAddress: wallet.publicAddress, privateKey: privateKey) }
        ) else {
            return
        }

        // Reclassify misidentified handshakes:
        // If self-stash confirms we have handshakes with a contact but conversation has
        // no handshake messages, the earliest payment is likely the handshake (Bug 4 fix)
        reclassifyMisidentifiedHandshakes()

        // Migrate legacy aliases to deterministic routing states (one-time)
        if let privKey = privateKey {
            migrateToDeterministicAliases(privateKey: privKey)
        }

        // Now fetch contextual messages for all known aliases
        print("[ChatService] Current aliases: \(conversationAliases)")
        print("[ChatService] Our aliases: \(ourAliases)")
        print("[ChatService] Routing states: \(routingStates.count)")
        if let active = activeAddress {
            let completed = await fetchContextualMessagesForActive(
                contactAddress: active,
                myAddress: wallet.publicAddress,
                privateKey: privateKey,
                fallbackSince: fallbackSince,
                nowMs: nowMs
            )
            guard completed else { return }
            activeFetchSucceeded = true
        } else {
            let completed = await fetchContextualMessages(
                myAddress: wallet.publicAddress,
                privateKey: privateKey,
                fallbackSince: fallbackSince,
                nowMs: nowMs
            )
            guard completed else { return }
        }

        await retryIncomingWarningResolutionsOnSync(
            myAddress: wallet.publicAddress,
            privateKey: privateKey
        )

        // Note: saveMessages() is handled by defer block via endSyncBlockTime() to leverage batching
        // Only save metadata that doesn't go through MessageStore
        saveConversationAliases()
        saveOurAliases()
        saveConversationIds()
        saveRoutingStates()

        // Update last successful sync date for connection status
        lastSuccessfulSyncDate = Date()
        if isFullFetch {
            await apiClient.recordIndexerSyncSuccess()
        }

        syncSucceeded = true
        print("[ChatService] Fetch complete. Total conversations: \(conversations.count), lastPollTime updated to: \(lastPollTime)")
    }

    func getConversation(for contact: Contact) -> Conversation? {
        return conversations.first { $0.contact.id == contact.id }
    }

    func getOrCreateConversation(for contact: Contact) -> Conversation {
        if let existing = getConversation(for: contact) {
            return existing
        }

        let conversation = Conversation(contact: contact)
        conversations.append(conversation)
        markConversationDirty(contact.address)
        saveMessages()
        return conversation
    }

    func sendMessage(to contact: Contact, content: String, messageType: ChatMessage.MessageType = .contextual) async throws {
        let trimmed = content.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }
        guard let wallet = WalletManager.shared.currentWallet else {
            throw KasiaError.walletNotFound
        }

        let pendingTxId = "pending_\(UUID().uuidString)"
        let pendingTimestamp = Date()
        let pendingMessage = ChatMessage(
            txId: pendingTxId,
            senderAddress: wallet.publicAddress,
            receiverAddress: contact.address,
            content: trimmed,
            timestamp: pendingTimestamp,
            blockTime: UInt64(pendingTimestamp.timeIntervalSince1970 * 1000),
            isOutgoing: true,
            messageType: messageType,
            deliveryStatus: .pending
        )
        addMessageToConversation(pendingMessage, contactAddress: contact.address)
        enqueuePendingOutgoing(contactAddress: contact.address, pendingTxId: pendingTxId, messageType: messageType, timestamp: pendingTimestamp)
        saveMessages()

        let previous = messageSendTail
        let task = Task { @MainActor in
            if let previous {
                _ = try? await previous.value
            }
            try await sendMessageInternal(
                to: contact,
                content: trimmed,
                messageType: messageType,
                pendingTxId: pendingTxId,
                pendingMessageId: pendingMessage.id
            )
        }
        messageSendTail = task
        try await task.value
    }

    func retryOutgoingMessage(_ message: ChatMessage, contact: Contact) async throws {
        guard message.isOutgoing else { return }
        switch message.messageType {
        case .contextual, .audio:
            let previous = messageSendTail
            let task = Task { @MainActor in
                if let previous {
                    _ = try? await previous.value
                }
                try await sendMessageInternal(
                    to: contact,
                    content: message.content,
                    messageType: message.messageType,
                    pendingTxId: message.txId,
                    pendingMessageId: message.id
                )
            }
            messageSendTail = task
            try await task.value
        case .handshake:
            let isResponse = shouldRetryHandshakeAsResponse(for: contact.address)
            let pendingTxId = message.txId.hasPrefix("pending_") ? message.txId : nil
            try await sendHandshake(to: contact, isResponse: isResponse, pendingTxId: pendingTxId)
        case .payment:
            return
        }
    }

    private func sendMessageInternal(
        to contact: Contact,
        content: String,
        messageType: ChatMessage.MessageType,
        pendingTxId: String?,
        pendingMessageId: UUID? = nil,
        spendableFundsRetryAttempt: Int = 0
    ) async throws {
        guard let wallet = WalletManager.shared.currentWallet else {
            throw KasiaError.walletNotFound
        }

        guard let privateKey = WalletManager.shared.getPrivateKey() else {
            throw KasiaError.keychainError("Could not get private key")
        }

        // Get recipient's public key from their address
        guard let recipientPublicKey = KaspaAddress.publicKey(from: contact.address) else {
            throw KasiaError.invalidAddress
        }
        guard let senderScriptPubKey = KaspaAddress.scriptPublicKey(from: wallet.publicAddress) else {
            throw KasiaError.invalidAddress
        }

        // Ensure routing state exists, then get our alias (deterministic preferred)
        ensureRoutingState(for: contact.address, privateKey: privateKey)
        let alias = outgoingAlias(for: contact.address)

        let resolvedPendingTxId = pendingTxId ?? "pending_\(UUID().uuidString)"
        var activePendingMessageId = pendingMessageId
        if pendingTxId == nil {
            let pendingTimestamp = Date()
            let pendingMessage = ChatMessage(
                txId: resolvedPendingTxId,
                senderAddress: wallet.publicAddress,
                receiverAddress: contact.address,
                content: content,
                timestamp: pendingTimestamp,
                blockTime: UInt64(pendingTimestamp.timeIntervalSince1970 * 1000),
                isOutgoing: true,
                messageType: messageType,
                deliveryStatus: .pending
            )
            addMessageToConversation(pendingMessage, contactAddress: contact.address)
            enqueuePendingOutgoing(contactAddress: contact.address, pendingTxId: resolvedPendingTxId, messageType: messageType, timestamp: pendingTimestamp)
            activePendingMessageId = pendingMessage.id
        } else {
            resetPendingMessage(resolvedPendingTxId, contactAddress: contact.address)
        }
        saveMessages()

        let activePendingTxId = resolvedPendingTxId
        if activePendingMessageId == nil {
            activePendingMessageId = resolveMessageIdForPending(contactAddress: contact.address, pendingTxId: activePendingTxId)
        }
        if let activePendingMessageId {
            registerOutgoingAttempt(
                messageId: activePendingMessageId,
                pendingTxId: activePendingTxId,
                contactAddress: contact.address,
                messageType: messageType
            )
            markOutgoingAttemptSubmitting(messageId: activePendingMessageId)
        }

        do {
            // Connect to Kaspa node
            let rpcManager = NodePoolService.shared
            let settings = currentSettings

            print("[ChatService] Starting message send to \(contact.address.suffix(10))")

            // Connect via gRPC manager
            if !rpcManager.isConnected {
                print("[ChatService] RPC not connected, connecting...")
                try await rpcManager.connect(network: settings.networkType)
            } else {
                print("[ChatService] RPC already connected")
            }

            // Fetch UTXOs for our address
            let utxos = try await rpcManager.getUtxosByAddresses([wallet.publicAddress])
            updateWalletBalanceIfNeeded(address: wallet.publicAddress, utxos: utxos)
            let availableUtxos = prepareMessageUtxos(confirmed: utxos)
            guard !availableUtxos.isEmpty else {
                let totalBalanceSompi = utxos.reduce(UInt64(0)) { $0 + $1.amount }
                if totalBalanceSompi == 0 {
                    NSLog("[ChatService] No confirmed UTXOs available - wallet balance is zero for %@",
                          String(activePendingTxId.prefix(12)))
                    throw KasiaError.networkError("Zero balance: add funds to your wallet and try again.")
                }

                NSLog("[ChatService] No confirmed spendable UTXOs available for %@",
                      String(activePendingTxId.prefix(12)))
                throw KasiaError.networkError("No spendable funds available yet. Wait for confirmations and try again.")
            }

            print("[ChatService] Found \(availableUtxos.count) available UTXOs for sending")

            // Build the transaction
            let transaction = try KasiaTransactionBuilder.buildContextualMessageTx(
                from: wallet.publicAddress,
                to: contact.address,
                alias: alias,
                message: content,
                senderPrivateKey: privateKey,
                recipientPublicKey: recipientPublicKey,
                utxos: availableUtxos
            )
            // Submit the transaction
            let (txId, endpoint) = try await rpcManager.submitTransaction(transaction, allowOrphan: false)
            print("[ChatService] Transaction submitted: \(txId) via \(endpoint)")

            reserveMessageOutpoints(availableUtxos)
            consumePendingUtxos(availableUtxos)
            addPendingOutputs(from: transaction, txId: txId, senderScriptPubKey: senderScriptPubKey)

            // Update the pending message with the real transaction ID
            if let activePendingMessageId {
                _ = updatePendingMessageById(
                    activePendingMessageId,
                    newTxId: txId,
                    contactAddress: contact.address
                )
            } else {
                _ = updatePendingMessage(activePendingTxId, withRealTxId: txId, contactAddress: contact.address)
            }
            markOutgoingAttemptSubmitted(
                messageId: activePendingMessageId,
                pendingTxId: activePendingTxId,
                contactAddress: contact.address,
                messageType: messageType,
                txId: txId
            )

            // Store our alias for future messages
            addOurAlias(alias, for: contact.address, blockTime: nil)
            saveOurAliases()
            if conversationIds[contact.address] == nil, let pendingConvId = conversationIds["pending_\(contact.address)"] {
                conversationIds[contact.address] = pendingConvId
                conversationIds.removeValue(forKey: "pending_\(contact.address)")
                saveConversationIds()
            }

            saveMessages(triggerExport: true)

        } catch {
            releaseMessageOutpoints()
            if let acceptedTxId = acceptedTransactionId(from: error) {
                NSLog("[ChatService] Message already accepted by consensus for %@ -> promoting pending to %@",
                      String(activePendingTxId.prefix(12)),
                      String(acceptedTxId.prefix(12)))
                if let activePendingMessageId {
                    _ = updatePendingMessageById(
                        activePendingMessageId,
                        newTxId: acceptedTxId,
                        contactAddress: contact.address
                    )
                } else {
                    _ = updatePendingMessage(activePendingTxId, withRealTxId: acceptedTxId, contactAddress: contact.address)
                }
                markOutgoingAttemptSubmitted(
                    messageId: activePendingMessageId,
                    pendingTxId: activePendingTxId,
                    contactAddress: contact.address,
                    messageType: messageType,
                    txId: acceptedTxId
                )
                saveMessages(triggerExport: true)
                return
            }
            if shouldRetryNoSpendableFundsError(error),
               spendableFundsRetryAttempt < spendableFundsRetryAttempts {
                let retryNumber = spendableFundsRetryAttempt + 1
                let retryDelay = spendableFundsRetryDelay(for: retryNumber)
                if let jitterRatio = retryDelay.jitterRatio {
                    NSLog(
                        "[ChatService] Retrying send (no spendable funds) for %@ (%d/%d) in %.0fms (+%.0f%% jitter)",
                        String(activePendingTxId.prefix(12)),
                        retryNumber,
                        spendableFundsRetryAttempts,
                        retryDelay.seconds * 1000,
                        jitterRatio * 100
                    )
                } else {
                    NSLog(
                        "[ChatService] Retrying send (no spendable funds) for %@ (%d/%d) in %.0fms",
                        String(activePendingTxId.prefix(12)),
                        retryNumber,
                        spendableFundsRetryAttempts,
                        retryDelay.seconds * 1000
                    )
                }
                try await Task.sleep(nanoseconds: UInt64(retryDelay.seconds * 1_000_000_000))
                try await sendMessageInternal(
                    to: contact,
                    content: content,
                    messageType: messageType,
                    pendingTxId: activePendingTxId,
                    pendingMessageId: activePendingMessageId,
                    spendableFundsRetryAttempt: retryNumber
                )
                return
            }
            if shouldRetrySendError(error) {
                NSLog("[ChatService] Message send retry scheduled for %@: %@",
                      String(activePendingTxId.prefix(12)), error.localizedDescription)
                scheduleOutgoingRetry(
                    contact: contact,
                    pendingTxId: activePendingTxId,
                    pendingMessageId: activePendingMessageId,
                    messageType: messageType,
                    delaySeconds: 4
                )
                return
            }
            markOutgoingAttemptFailed(
                messageId: activePendingMessageId,
                pendingTxId: activePendingTxId
            )
            markPendingMessageFailed(activePendingTxId, contactAddress: contact.address)
            saveMessages()
            throw error
        }
    }

    private func resolveMessageIdForPending(contactAddress: String, pendingTxId: String) -> UUID? {
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return nil
        }
        return conversations[convIndex].messages.first(where: { $0.txId == pendingTxId })?.id
    }

    private func resolveMessageIdForTx(contactAddress: String, txId: String) -> UUID? {
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return nil
        }
        return conversations[convIndex].messages.first(where: { $0.txId == txId })?.id
    }

    private func pruneOutgoingAttempts(now: Date = Date()) {
        let staleIds = outgoingAttemptsByMessageId.compactMap { messageId, attempt -> UUID? in
            if now.timeIntervalSince(attempt.updatedAt) > outgoingAttemptTTL {
                return messageId
            }
            return nil
        }

        for staleId in staleIds {
            guard let attempt = outgoingAttemptsByMessageId.removeValue(forKey: staleId) else { continue }
            outgoingAttemptByPendingTxId.removeValue(forKey: attempt.pendingTxId)
            if let txId = attempt.txId {
                outgoingAttemptByRealTxId.removeValue(forKey: txId)
            }
        }
    }

    private func registerOutgoingAttempt(
        messageId: UUID,
        pendingTxId: String,
        contactAddress: String,
        messageType: ChatMessage.MessageType
    ) {
        pruneOutgoingAttempts()
        if let existing = outgoingAttemptsByMessageId[messageId] {
            outgoingAttemptByPendingTxId.removeValue(forKey: existing.pendingTxId)
            if let txId = existing.txId {
                outgoingAttemptByRealTxId.removeValue(forKey: txId)
            }
        }
        let now = Date()
        let attempt = OutgoingTxAttempt(
            messageId: messageId,
            pendingTxId: pendingTxId,
            contactAddress: contactAddress,
            messageType: messageType,
            txId: nil,
            phase: .queued,
            updatedAt: now
        )
        outgoingAttemptsByMessageId[messageId] = attempt
        outgoingAttemptByPendingTxId[pendingTxId] = messageId
    }

    private func markOutgoingAttemptSubmitting(messageId: UUID?) {
        guard let messageId else { return }
        pruneOutgoingAttempts()
        guard var attempt = outgoingAttemptsByMessageId[messageId] else { return }
        attempt.phase = .submitting
        attempt.updatedAt = Date()
        outgoingAttemptsByMessageId[messageId] = attempt
    }

    private func markOutgoingAttemptSubmitted(
        messageId: UUID?,
        pendingTxId: String,
        contactAddress: String,
        messageType: ChatMessage.MessageType,
        txId: String
    ) {
        pruneOutgoingAttempts()
        let resolvedMessageId = messageId
            ?? outgoingAttemptByPendingTxId[pendingTxId]
            ?? resolveMessageIdForTx(contactAddress: contactAddress, txId: txId)
            ?? resolveMessageIdForPending(contactAddress: contactAddress, pendingTxId: pendingTxId)

        guard let resolvedMessageId else { return }

        if let existing = outgoingAttemptsByMessageId[resolvedMessageId] {
            outgoingAttemptByPendingTxId.removeValue(forKey: existing.pendingTxId)
            if let existingTxId = existing.txId {
                outgoingAttemptByRealTxId.removeValue(forKey: existingTxId)
            }
        }

        let attempt = OutgoingTxAttempt(
            messageId: resolvedMessageId,
            pendingTxId: pendingTxId,
            contactAddress: contactAddress,
            messageType: messageType,
            txId: txId,
            phase: .submitted,
            updatedAt: Date()
        )
        outgoingAttemptsByMessageId[resolvedMessageId] = attempt
        outgoingAttemptByRealTxId[txId] = resolvedMessageId
    }

    private func markOutgoingAttemptFailed(messageId: UUID?, pendingTxId: String?) {
        pruneOutgoingAttempts()

        if let messageId,
           let existing = outgoingAttemptsByMessageId.removeValue(forKey: messageId) {
            outgoingAttemptByPendingTxId.removeValue(forKey: existing.pendingTxId)
            if let existingTxId = existing.txId {
                outgoingAttemptByRealTxId.removeValue(forKey: existingTxId)
            }
            return
        }

        if let pendingTxId,
           let mappedMessageId = outgoingAttemptByPendingTxId.removeValue(forKey: pendingTxId),
           let existing = outgoingAttemptsByMessageId.removeValue(forKey: mappedMessageId),
           let existingTxId = existing.txId {
            outgoingAttemptByRealTxId.removeValue(forKey: existingTxId)
        }
    }

    private func hasInFlightOutgoingAttemptWithoutTxId(for contactAddress: String) -> Bool {
        pruneOutgoingAttempts()
        return outgoingAttemptsByMessageId.values.contains {
            $0.contactAddress == contactAddress &&
            $0.txId == nil &&
            ($0.phase == .queued || $0.phase == .submitting)
        }
    }

    private func isKnownOutgoingAttemptTxId(_ txId: String) -> Bool {
        pruneOutgoingAttempts()
        return outgoingAttemptByRealTxId[txId] != nil
    }

    private func shouldDeferClassification(
        txId: String,
        txAddedAddresses: Set<String>,
        contactAddresses: Set<String>
    ) -> Bool {
        if isKnownOutgoingAttemptTxId(txId) {
            return false
        }

        let touchedContacts = txAddedAddresses.intersection(contactAddresses)
        guard !touchedContacts.isEmpty else { return false }

        for contact in touchedContacts {
            if hasInFlightOutgoingAttemptWithoutTxId(for: contact) {
                return true
            }
        }
        return false
    }

    private func promoteKnownOutgoingAttempt(contactAddress: String, newTxId: String) -> Bool {
        pruneOutgoingAttempts()

        if let attemptId = outgoingAttemptByRealTxId[newTxId],
           let existing = outgoingAttemptsByMessageId[attemptId],
           existing.contactAddress == contactAddress {
            return true
        }

        let candidate = outgoingAttemptsByMessageId.values
            .filter {
                $0.contactAddress == contactAddress &&
                $0.txId == nil &&
                ($0.phase == .queued || $0.phase == .submitting)
            }
            .sorted { $0.updatedAt < $1.updatedAt }
            .first

        if let candidate,
           updatePendingMessageById(candidate.messageId, newTxId: newTxId, contactAddress: contactAddress) {
            markOutgoingAttemptSubmitted(
                messageId: candidate.messageId,
                pendingTxId: candidate.pendingTxId,
                contactAddress: contactAddress,
                messageType: candidate.messageType,
                txId: newTxId
            )
            saveMessages()
            return true
        }

        if updatePendingFromQueue(contactAddress: contactAddress, newTxId: newTxId, messageType: .payment) ||
            updateOldestPendingOutgoingMessage(contactAddress: contactAddress, newTxId: newTxId, messageType: .payment) {
            return true
        }

        return false
    }

    private func outpointKey(_ outpoint: UTXO.Outpoint) -> String {
        "\(outpoint.transactionId):\(outpoint.index)"
    }

    private func prepareMessageUtxos(confirmed: [UTXO]) -> [UTXO] {
        let now = Date()
        pruneMessageUtxoCaches(confirmed: confirmed, now: now)
        return confirmed
            .filter { $0.blockDaaScore > 0 && !$0.isCoinbase }
            .filter { reservedMessageOutpoints[outpointKey($0.outpoint)] == nil }
    }

    private func pruneMessageUtxoCaches(confirmed: [UTXO], now: Date) {
        reservedMessageOutpoints = reservedMessageOutpoints.filter { $0.value > now }
        let confirmedKeys = Set(confirmed.map { outpointKey($0.outpoint) })
        pendingMessageUtxos = pendingMessageUtxos.filter { key, entry in
            entry.expiresAt > now && !confirmedKeys.contains(key)
        }
    }

    private func reserveMessageOutpoints(_ utxos: [UTXO]) {
        let expiration = Date().addingTimeInterval(pendingMessageUtxoTTL)
        for utxo in utxos {
            reservedMessageOutpoints[outpointKey(utxo.outpoint)] = expiration
        }
    }

    private func consumePendingUtxos(_ utxos: [UTXO]) {
        for utxo in utxos {
            pendingMessageUtxos.removeValue(forKey: outpointKey(utxo.outpoint))
        }
    }

    private func addPendingOutputs(from transaction: KaspaRpcTransaction, txId: String, senderScriptPubKey: Data) {
        let expiration = Date().addingTimeInterval(pendingMessageUtxoTTL)
        for (index, output) in transaction.outputs.enumerated() {
            guard output.scriptPublicKey.script == senderScriptPubKey else { continue }
            let utxo = UTXO(
                address: "",
                outpoint: UTXO.Outpoint(transactionId: txId, index: UInt32(index)),
                amount: output.value,
                scriptPublicKey: senderScriptPubKey,
                blockDaaScore: 0,
                isCoinbase: false
            )
            pendingMessageUtxos[outpointKey(utxo.outpoint)] = (utxo, expiration)
        }
    }

    private func releaseMessageOutpoints() {
        let now = Date()
        reservedMessageOutpoints = reservedMessageOutpoints.filter { $0.value > now }
        pendingMessageUtxos = pendingMessageUtxos.filter { $0.value.expiresAt > now }
    }

    private func shouldRetrySendError(_ error: Error) -> Bool {
        let message = error.localizedDescription.lowercased()
        return message.contains("orphan") || message.contains("already spent")
    }

    private func shouldRetryNoSpendableFundsError(_ error: Error) -> Bool {
        if case let KasiaError.networkError(message) = error {
            let lowered = message.lowercased()
            if lowered.contains("no spendable funds available yet") {
                return true
            }
        }
        let message = error.localizedDescription.lowercased()
        return message.contains("no spendable funds available yet") ||
               message.contains("no confirmed spendable utxos available")
    }

    private func spendableFundsRetryDelay(for retryNumber: Int) -> (seconds: TimeInterval, jitterRatio: Double?) {
        let normalizedRetry = max(1, retryNumber)
        let baseDelay = spendableFundsRetryBaseDelay * pow(2.0, Double(normalizedRetry - 1))
        guard normalizedRetry > 2 else {
            return (baseDelay, nil)
        }

        let jitterRatio = Double.random(in: 0.10...0.40)
        let jitterDelay = baseDelay * jitterRatio
        return (baseDelay + jitterDelay, jitterRatio)
    }

    private func acceptedTransactionId(from error: Error) -> String? {
        let message = error.localizedDescription
        guard message.lowercased().contains("already accepted by the consensus") else { return nil }
        return extractLikelyTxId(from: message)
    }

    private func extractLikelyTxId(from text: String) -> String? {
        if let txIdAfterKeyword = extractTxId(after: "transaction", in: text) {
            return txIdAfterKeyword
        }
        return extractFirstHex64(in: text)
    }

    private func extractTxId(after keyword: String, in text: String) -> String? {
        let lowered = text.lowercased()
        guard let range = lowered.range(of: keyword) else { return nil }
        let tail = String(lowered[range.upperBound...])
        return extractFirstHex64AllowingWhitespace(in: tail)
    }

    private func extractFirstHex64(in text: String) -> String? {
        guard let regex = try? NSRegularExpression(pattern: "[0-9a-fA-F]{64}") else { return nil }
        let full = text as NSString
        let range = NSRange(location: 0, length: full.length)
        guard let match = regex.firstMatch(in: text, options: [], range: range) else { return nil }
        return full.substring(with: match.range).lowercased()
    }

    private func extractFirstHex64AllowingWhitespace(in text: String) -> String? {
        // Some node errors wrap txId across newlines/spaces. Accept and compact it.
        guard let regex = try? NSRegularExpression(pattern: "([0-9a-fA-F][0-9a-fA-F\\s]{63,200})") else { return nil }
        let full = text as NSString
        let range = NSRange(location: 0, length: full.length)
        guard let match = regex.firstMatch(in: text, options: [], range: range) else { return nil }
        let raw = full.substring(with: match.range)
        let compact = raw.filter { $0.isHexDigit }
        guard compact.count >= 64 else { return nil }
        return String(compact.prefix(64)).lowercased()
    }

    private func scheduleOutgoingRetry(
        contact: Contact,
        pendingTxId: String,
        pendingMessageId: UUID?,
        messageType: ChatMessage.MessageType,
        delaySeconds: TimeInterval
    ) {
        guard !scheduledSendRetries.contains(pendingTxId) else { return }
        scheduledSendRetries.insert(pendingTxId)
        Task { @MainActor [weak self] in
            try? await Task.sleep(nanoseconds: UInt64(delaySeconds * 1_000_000_000))
            guard let self else { return }
            self.scheduledSendRetries.remove(pendingTxId)
            guard let convIndex = self.conversations.firstIndex(where: { $0.contact.address == contact.address }),
                  let message = self.conversations[convIndex].messages.first(where: { $0.txId == pendingTxId || $0.id == pendingMessageId }) else {
                return
            }
            guard message.deliveryStatus != .sent else { return }
            let previous = self.messageSendTail
            let task = Task { @MainActor in
                if let previous {
                    _ = try? await previous.value
                }
                try await self.sendMessageInternal(
                    to: contact,
                    content: message.content,
                    messageType: messageType,
                    pendingTxId: message.txId,
                    pendingMessageId: message.id
                )
            }
            self.messageSendTail = task
            _ = try? await task.value
        }
    }

    func sendPayment(to contact: Contact, amountSompi: UInt64, note: String = "") async throws {
        guard amountSompi > 0 else {
            throw KasiaError.networkError("Amount must be greater than zero")
        }
        guard let wallet = WalletManager.shared.currentWallet else {
            throw KasiaError.walletNotFound
        }
        guard let privateKey = WalletManager.shared.getPrivateKey() else {
            throw KasiaError.keychainError("Could not get private key")
        }

        let formattedAmount = formatKasAmount(amountSompi)
        let pendingTxId = "pending_\(UUID().uuidString)"
        let pendingTimestamp = Date()
        let pendingMessage = ChatMessage(
            txId: pendingTxId,
            senderAddress: wallet.publicAddress,
            receiverAddress: contact.address,
            content: "Sent \(formattedAmount) KAS",
            timestamp: pendingTimestamp,
            blockTime: UInt64(pendingTimestamp.timeIntervalSince1970 * 1000),
            acceptingBlock: nil,
            isOutgoing: true,
            messageType: .payment,
            deliveryStatus: .pending
        )
        let pendingMessageId = pendingMessage.id
        addMessageToConversation(pendingMessage, contactAddress: contact.address)
        enqueuePendingOutgoing(contactAddress: contact.address, pendingTxId: pendingTxId, messageType: .payment, timestamp: pendingTimestamp)
        saveMessages()
        registerOutgoingAttempt(
            messageId: pendingMessageId,
            pendingTxId: pendingTxId,
            contactAddress: contact.address,
            messageType: .payment
        )
        markOutgoingAttemptSubmitting(messageId: pendingMessageId)

        do {
            let rpcManager = NodePoolService.shared
            let settings = currentSettings

            if !rpcManager.isConnected {
                try await rpcManager.connect(network: settings.networkType)
            }

            let utxos = try await rpcManager.getUtxosByAddresses([wallet.publicAddress])
            updateWalletBalanceIfNeeded(address: wallet.publicAddress, utxos: utxos)
            let spendable = utxos.filter { $0.blockDaaScore > 0 && !$0.isCoinbase }
            guard !spendable.isEmpty else {
                throw KasiaError.networkError("No spendable UTXOs available")
            }

            guard let recipientPublicKey = KaspaAddress.publicKey(from: contact.address) else {
                throw KasiaError.invalidAddress
            }

            let tx = try KasiaTransactionBuilder.buildPaymentTx(
                from: wallet.publicAddress,
                to: contact.address,
                amount: amountSompi,
                note: note,
                senderPrivateKey: privateKey,
                recipientPublicKey: recipientPublicKey,
                utxos: spendable
            )

            // Submit via RPC manager
            NSLog("[ChatService] Submitting payment via RPC manager...")
            let (txId, endpoint) = try await rpcManager.submitTransaction(tx, allowOrphan: false)
            NSLog("[ChatService] Payment submitted: \(txId) via \(endpoint)")
            _ = updatePendingMessageById(pendingMessageId, newTxId: txId, contactAddress: contact.address)
            markOutgoingAttemptSubmitted(
                messageId: pendingMessageId,
                pendingTxId: pendingTxId,
                contactAddress: contact.address,
                messageType: .payment,
                txId: txId
            )
            saveMessages(triggerExport: true)
        } catch {
            if let acceptedTxId = acceptedTransactionId(from: error) {
                NSLog("[ChatService] Payment already accepted by consensus for %@ -> promoting pending to %@",
                      String(pendingTxId.prefix(12)),
                      String(acceptedTxId.prefix(12)))
                _ = updatePendingMessageById(pendingMessageId, newTxId: acceptedTxId, contactAddress: contact.address)
                markOutgoingAttemptSubmitted(
                    messageId: pendingMessageId,
                    pendingTxId: pendingTxId,
                    contactAddress: contact.address,
                    messageType: .payment,
                    txId: acceptedTxId
                )
                saveMessages(triggerExport: true)
                return
            }
            markOutgoingAttemptFailed(messageId: pendingMessageId, pendingTxId: pendingTxId)
            markPendingMessageFailed(pendingTxId, contactAddress: contact.address)
            saveMessages()
            throw error
        }
    }

    func estimateMessageFee(to contact: Contact, content: String) async throws -> UInt64 {
        let trimmed = content.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            throw KasiaError.networkError("Message is empty")
        }

        guard let wallet = WalletManager.shared.currentWallet else {
            throw KasiaError.walletNotFound
        }

        guard let recipientPublicKey = KaspaAddress.publicKey(from: contact.address) else {
            throw KasiaError.invalidAddress
        }

        guard let senderScriptPubKey = KaspaAddress.scriptPublicKey(from: wallet.publicAddress) else {
            throw KasiaError.invalidAddress
        }

        let alias = primaryOurAlias(for: contact.address) ?? String(repeating: "0", count: 12)
        let payload = try KasiaTransactionBuilder.buildContextualMessagePayload(
            alias: alias,
            message: trimmed,
            recipientPublicKey: recipientPublicKey
        )

        // Use fallback method - doesn't require gRPC connection
        let utxos = try await fetchUtxosWithFallback(for: wallet.publicAddress)

        let spendable = utxos.filter { !$0.isCoinbase }
        guard !spendable.isEmpty else {
            throw KasiaError.networkError("No spendable UTXOs")
        }

        return KasiaTransactionBuilder.estimateContextualMessageFee(
            payload: payload,
            inputCount: spendable.count,
            senderScriptPubKey: senderScriptPubKey
        )
    }

    func estimatePaymentFee(to contact: Contact, amountSompi: UInt64, note: String = "") async throws -> UInt64 {
        guard amountSompi > 0 else { throw KasiaError.networkError("Amount is zero") }
        guard let wallet = WalletManager.shared.currentWallet else { throw KasiaError.walletNotFound }
        guard let recipientPublicKey = KaspaAddress.publicKey(from: contact.address) else {
            throw KasiaError.invalidAddress
        }

        let payload = try KasiaTransactionBuilder.buildPaymentPayload(message: note, amount: amountSompi, recipientPublicKey: recipientPublicKey)
        // Use fallback method - doesn't require gRPC connection
        let utxos = try await fetchUtxosWithFallback(for: wallet.publicAddress)
        let spendable = utxos.filter { !$0.isCoinbase }
        guard !spendable.isEmpty else {
            throw KasiaError.networkError("No spendable UTXOs")
        }

        guard let senderScriptPubKey = KaspaAddress.scriptPublicKey(from: wallet.publicAddress),
              let recipientScriptPubKey = KaspaAddress.scriptPublicKey(from: contact.address) else {
            throw KasiaError.invalidAddress
        }

        return try KasiaTransactionBuilder.estimatePaymentFee(
            utxos: spendable,
            payload: payload,
            amount: amountSompi,
            recipientScriptPubKey: recipientScriptPubKey,
            senderScriptPubKey: senderScriptPubKey
        )
    }

    /// Calculate maximum sendable amount (balance - fee for send-all transaction with no change output)
    func estimateMaxPaymentAmount(to contact: Contact, note: String = "") async throws -> UInt64 {
        guard let wallet = WalletManager.shared.currentWallet else { throw KasiaError.walletNotFound }
        guard let recipientPublicKey = KaspaAddress.publicKey(from: contact.address) else {
            throw KasiaError.invalidAddress
        }

        // Use fallback method - doesn't require gRPC connection
        let utxos = try await fetchUtxosWithFallback(for: wallet.publicAddress)
        let spendable = utxos.filter { !$0.isCoinbase }
        guard !spendable.isEmpty else {
            throw KasiaError.networkError("No spendable UTXOs")
        }

        let totalBalance = spendable.reduce(0) { $0 + $1.amount }

        guard let recipientScriptPubKey = KaspaAddress.scriptPublicKey(from: contact.address),
              let senderScriptPubKey = KaspaAddress.scriptPublicKey(from: wallet.publicAddress) else {
            throw KasiaError.invalidAddress
        }

        // Build payload with a placeholder amount (doesn't affect fee calculation significantly)
        let payload = try KasiaTransactionBuilder.buildPaymentPayload(
            message: note,
            amount: totalBalance,
            recipientPublicKey: recipientPublicKey
        )

        // Calculate fee for send-all (uses 2 outputs to match selectUtxosForPayment behavior)
        let fee = KasiaTransactionBuilder.estimateSendAllFee(
            utxos: spendable,
            payload: payload,
            recipientScriptPubKey: recipientScriptPubKey,
            senderScriptPubKey: senderScriptPubKey
        )

        guard totalBalance > fee else {
            throw KasiaError.networkError("Balance too low to cover fee")
        }

        return totalBalance - fee
    }

    func sendHandshake(to contact: Contact, isResponse: Bool, pendingTxId: String? = nil) async throws {
        guard let wallet = WalletManager.shared.currentWallet else {
            throw KasiaError.walletNotFound
        }

        guard let privateKey = WalletManager.shared.getPrivateKey() else {
            throw KasiaError.keychainError("Could not get private key")
        }

        guard let recipientPublicKey = KaspaAddress.publicKey(from: contact.address) else {
            throw KasiaError.invalidAddress
        }
        guard let senderScriptPubKey = KaspaAddress.scriptPublicKey(from: wallet.publicAddress) else {
            throw KasiaError.invalidAddress
        }

        // Ensure routing state exists for this contact before sending
        ensureRoutingState(for: contact.address, privateKey: privateKey)
        let alias = outgoingAlias(for: contact.address)
        let conversationId = conversationIds[contact.address] ?? generateConversationId()

        let activePendingTxId = pendingTxId ?? "pending_\(UUID().uuidString)"
        var activePendingMessageId: UUID?
        if pendingTxId == nil {
            let pendingTimestamp = Date()
            let handshakeContent = isResponse ? "[Request accepted]" : "[Request to communicate]"
            let pendingMessage = ChatMessage(
                txId: activePendingTxId,
                senderAddress: wallet.publicAddress,
                receiverAddress: contact.address,
                content: handshakeContent,
                timestamp: pendingTimestamp,
                blockTime: UInt64(pendingTimestamp.timeIntervalSince1970 * 1000),
                isOutgoing: true,
                messageType: .handshake,
                deliveryStatus: .pending
            )
            activePendingMessageId = pendingMessage.id
            addMessageToConversation(pendingMessage, contactAddress: contact.address)
            enqueuePendingOutgoing(
                contactAddress: contact.address,
                pendingTxId: activePendingTxId,
                messageType: .handshake,
                timestamp: pendingTimestamp
            )
        } else {
            resetPendingMessage(activePendingTxId, contactAddress: contact.address)
            activePendingMessageId = resolveMessageIdForPending(contactAddress: contact.address, pendingTxId: activePendingTxId)
        }
        saveMessages()
        if let activePendingMessageId {
            registerOutgoingAttempt(
                messageId: activePendingMessageId,
                pendingTxId: activePendingTxId,
                contactAddress: contact.address,
                messageType: .handshake
            )
            markOutgoingAttemptSubmitting(messageId: activePendingMessageId)
        }

        do {
            let rpcManager = NodePoolService.shared
            let settings = currentSettings

            if !rpcManager.isConnected {
                try await rpcManager.connect(network: settings.networkType)
            }

            let utxos = try await rpcManager.getUtxosByAddresses([wallet.publicAddress])
            updateWalletBalanceIfNeeded(address: wallet.publicAddress, utxos: utxos)
            let spendable = utxos.filter { $0.blockDaaScore > 0 && !$0.isCoinbase }
            guard !spendable.isEmpty else {
                throw KasiaError.networkError("No UTXOs available. Your account may be empty.")
            }

            // Split UTXOs so we can send self-stash as a second tx without double-spend
            let (handshakeUtxos, stashUtxos) = splitUtxosForHandshake(spendable)

            let transaction = try KasiaTransactionBuilder.buildHandshakeTx(
                from: wallet.publicAddress,
                to: contact.address,
                alias: alias,
                conversationId: conversationId,
                isResponse: isResponse,
                senderPrivateKey: privateKey,
                recipientPublicKey: recipientPublicKey,
                utxos: handshakeUtxos
            )

            let (txId, endpoint) = try await rpcManager.submitTransaction(transaction, allowOrphan: false)
            NSLog("[ChatService] Handshake submitted: \(txId) via \(endpoint)")
            if let activePendingMessageId {
                _ = updatePendingMessageById(activePendingMessageId, newTxId: txId, contactAddress: contact.address)
            } else {
                _ = updatePendingMessage(activePendingTxId, withRealTxId: txId, contactAddress: contact.address)
            }
            markOutgoingAttemptSubmitted(
                messageId: activePendingMessageId,
                pendingTxId: activePendingTxId,
                contactAddress: contact.address,
                messageType: .handshake,
                txId: txId
            )

            addOurAlias(alias, for: contact.address, blockTime: nil)
            saveOurAliases()
            conversationIds[contact.address] = conversationId
            saveConversationIds()

            saveMessages(triggerExport: true)

            // Create self-stash to persist handshake metadata (separate tx)
            await sendOrQueueSelfStash(
                contactAddress: contact.address,
                ourAlias: alias,
                theirAlias: primaryConversationAlias(for: contact.address),
                isResponse: isResponse,
                walletAddress: wallet.publicAddress,
                privateKey: privateKey,
                utxos: stashUtxos,
                handshakeTx: transaction,
                handshakeTxId: txId,
                senderScriptPubKey: senderScriptPubKey
            )
        } catch {
            if let acceptedTxId = acceptedTransactionId(from: error) {
                NSLog("[ChatService] Handshake already accepted by consensus for %@ -> promoting pending to %@",
                      String(activePendingTxId.prefix(12)),
                      String(acceptedTxId.prefix(12)))
                if let activePendingMessageId {
                    _ = updatePendingMessageById(activePendingMessageId, newTxId: acceptedTxId, contactAddress: contact.address)
                } else {
                    _ = updatePendingMessage(activePendingTxId, withRealTxId: acceptedTxId, contactAddress: contact.address)
                }
                markOutgoingAttemptSubmitted(
                    messageId: activePendingMessageId,
                    pendingTxId: activePendingTxId,
                    contactAddress: contact.address,
                    messageType: .handshake,
                    txId: acceptedTxId
                )
                saveMessages(triggerExport: true)
                return
            }
            markOutgoingAttemptFailed(messageId: activePendingMessageId, pendingTxId: activePendingTxId)
            markPendingMessageFailed(activePendingTxId, contactAddress: contact.address)
            saveMessages()
            throw error
        }
    }

    private func shouldRetryHandshakeAsResponse(for contactAddress: String) -> Bool {
        guard let conversation = conversations.first(where: { $0.contact.address == contactAddress }) else {
            return false
        }
        return conversation.messages.contains {
            $0.messageType == .handshake && !$0.isOutgoing && $0.deliveryStatus != .failed
        }
    }

    func respondToHandshake(for contact: Contact, accept: Bool) async throws {
        if accept {
            try await sendHandshake(to: contact, isResponse: true)
            clearDeclined(contact.address)
        } else {
            declineContact(contact.address)
        }
    }

    func isConversationDeclined(_ address: String) -> Bool {
        declinedContacts.contains(address)
    }

    func isConversationVisibleInChatList(_ conversation: Conversation, settings: AppSettings? = nil) -> Bool {
        let settings = settings ?? currentSettings
        let address = conversation.contact.address
        guard !isConversationDeclined(address) else { return false }

        let effectiveContact = contactsManager.getContact(byAddress: address) ?? conversation.contact
        guard !effectiveContact.isArchived else { return false }

        if settings.hideAutoCreatedPaymentChats &&
            effectiveContact.isAutoAdded &&
            !conversation.messages.contains(where: { $0.messageType != .payment }) {
            return false
        }

        return true
    }

    func pushEligibleConversationAddresses(settings: AppSettings? = nil) -> [String] {
        let settings = settings ?? currentSettings
        var addresses = Set<String>()
        for conversation in conversations {
            guard isConversationVisibleInChatList(conversation, settings: settings) else { continue }
            let contact = contactsManager.getContact(byAddress: conversation.contact.address) ?? conversation.contact
            guard settings.shouldDeliverIncomingNotification(for: contact) else { continue }
            let candidate = contact.address.trimmingCharacters(in: .whitespacesAndNewlines)
            guard contactsManager.isValidKaspaAddress(candidate) else { continue }
            addresses.insert(candidate.lowercased())
        }
        return Array(addresses)
    }

    func hasOurAlias(for address: String) -> Bool {
        routingStates[address] != nil || !(ourAliases[address]?.isEmpty ?? true)
    }

    func hasTheirAlias(for address: String) -> Bool {
        routingStates[address] != nil || !(conversationAliases[address]?.isEmpty ?? true)
    }

    /// Generate a random alias for a new conversation
    private func generateAlias() -> String {
        // Generate 6 random bytes and convert to hex (12 characters)
        var bytes = [UInt8](repeating: 0, count: 6)
        if SecRandomCopyBytes(kSecRandomDefault, bytes.count, &bytes) != errSecSuccess {
            // Fallback: use UUID bytes for non-security-critical alias
            let uuid = UUID()
            return withUnsafeBytes(of: uuid.uuid) { Data($0).prefix(6).map { String(format: "%02x", $0) }.joined() }
        }
        return bytes.map { String(format: "%02x", $0) }.joined()
    }

    private func generateConversationId() -> String {
        let uuid = UUID().uuidString.replacingOccurrences(of: "-", with: "")
        return String(uuid.prefix(12)).lowercased()
    }

    private func updateWalletBalanceIfNeeded(address: String, utxos: [UTXO]) {
        WalletManager.shared.updateBalanceIfCurrentWallet(address: address, utxos: utxos)
    }

    /// Split UTXOs so that handshake gets a minimal covering set and self-stash can use the rest
    private func splitUtxosForHandshake(_ utxos: [UTXO]) -> ([UTXO], [UTXO]) {
        guard utxos.count > 1 else {
            return (utxos, [])
        }

        // Reserve the smallest UTXO for self-stash if possible
        let sortedAsc = utxos.sorted { $0.amount < $1.amount }
        let remaining = Array(sortedAsc.dropFirst())

        let target: UInt64 = KasiaTransactionBuilder.handshakeAmount + 50_000 // padding for fee
        var selected: [UTXO] = []
        var total: UInt64 = 0
        for utxo in remaining {
            selected.append(utxo)
            let (nextTotal, overflow) = total.addingReportingOverflow(utxo.amount)
            if overflow {
                NSLog("[ChatService] Overflow while splitting handshake UTXOs; falling back to full set")
                return (utxos, [])
            }
            total = nextTotal
            if total >= target {
                break
            }
        }

        if total >= target {
            let handshakeIds = Set(selected.map { "\($0.outpoint.transactionId):\($0.outpoint.index)" })
            let stashUtxos = utxos.filter { !handshakeIds.contains("\($0.outpoint.transactionId):\($0.outpoint.index)") }
            return (selected, stashUtxos)
        } else {
            // Not enough without reserved; fall back to all UTXOs (stash later)
            return (utxos, [])
        }
    }

    private func connectRpcIfNeeded(timeout: TimeInterval = 30.0) async throws {
        let rpcManager = NodePoolService.shared
        if rpcManager.isConnected {
            return
        }

        let settings = currentSettings

        // Use gRPC manager for connection with timeout
        NSLog("[ChatService] Connecting via RPC manager (timeout: %.1fs)...", timeout)

        // Race between connection and timeout
        try await withThrowingTaskGroup(of: Void.self) { group in
            group.addTask {
                try await rpcManager.connect(network: settings.networkType)
            }
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
                throw KasiaError.networkError("RPC connection timeout")
            }

            // Wait for first to complete (either success or timeout)
            do {
                try await group.next()
                group.cancelAll()
            } catch {
                group.cancelAll()
                throw error
            }
        }
    }

    private func fetchCachedUtxos(for address: String) async throws -> [UTXO] {
        if let timestamp = cachedUtxosTimestamp,
           Date().timeIntervalSince(timestamp) < utxoCacheInterval,
           !cachedUtxos.isEmpty {
            return cachedUtxos
        }

        let utxos = try await NodePoolService.shared.getUtxosByAddresses([address])
        updateWalletBalanceIfNeeded(address: address, utxos: utxos)
        cachedUtxos = utxos
        cachedUtxosTimestamp = Date()
        return utxos
    }

    /// Fetch UTXOs with automatic fallback - tries gRPC if connected, otherwise uses REST API
    /// This is useful for fee estimation where we don't want to block waiting for gRPC connection
    private func fetchUtxosWithFallback(for address: String) async throws -> [UTXO] {
        // Check cache first
        if let timestamp = cachedUtxosTimestamp,
           Date().timeIntervalSince(timestamp) < utxoCacheInterval,
           !cachedUtxos.isEmpty {
            return cachedUtxos
        }

        // getUtxosByAddresses already has REST fallback built in
        let utxos = try await NodePoolService.shared.getUtxosByAddresses([address])
        updateWalletBalanceIfNeeded(address: address, utxos: utxos)
        cachedUtxos = utxos
        cachedUtxosTimestamp = Date()
        return utxos
    }

    private func splitUtxosForSelfStash(_ utxos: [UTXO]) -> ([UTXO], [UTXO]) {
        guard let first = utxos.first else { return ([], []) }
        return ([first], Array(utxos.dropFirst()))
    }

    private func sendOrQueueSelfStash(
        contactAddress: String,
        ourAlias: String,
        theirAlias: String?,
        isResponse: Bool,
        walletAddress: String,
        privateKey: Data,
        utxos: [UTXO],
        handshakeTx: KaspaRpcTransaction?,
        handshakeTxId: String?,
        senderScriptPubKey: Data?
    ) async {
        guard !utxos.isEmpty else {
            // Try to build from handshake change if possible
            if let handshakeTx = handshakeTx,
               let senderScriptPubKey = senderScriptPubKey,
               let change = changeUtxo(from: handshakeTx, txId: handshakeTxId, senderScript: senderScriptPubKey) {
                await submitSelfStashTx(
                    contactAddress: contactAddress,
                    ourAlias: ourAlias,
                    theirAlias: theirAlias,
                    isResponse: isResponse,
                    walletAddress: walletAddress,
                    privateKey: privateKey,
                    utxos: [change],
                    allowOrphan: true
                )
                return
            }

            queueSelfStash(contactAddress: contactAddress, ourAlias: ourAlias, theirAlias: theirAlias, isResponse: isResponse)
            return
        }
        await submitSelfStashTx(
            contactAddress: contactAddress,
            ourAlias: ourAlias,
            theirAlias: theirAlias,
            isResponse: isResponse,
            walletAddress: walletAddress,
            privateKey: privateKey,
            utxos: utxos,
            allowOrphan: false
        )
    }

    private func queueSelfStash(contactAddress: String, ourAlias: String, theirAlias: String?, isResponse: Bool) {
        let job = PendingSelfStash(partnerAddress: contactAddress, ourAlias: ourAlias, theirAlias: theirAlias, isResponse: isResponse)
        pendingSelfStash.append(job)
        savePendingSelfStash()
        print("[ChatService] Queued self-stash for \(contactAddress.suffix(10))")
    }

    private func submitSelfStashTx(
        contactAddress: String,
        ourAlias: String,
        theirAlias: String?,
        isResponse: Bool,
        walletAddress: String,
        privateKey: Data,
        utxos: [UTXO],
        allowOrphan: Bool
    ) async {
        do {
            let stashTx = try KasiaTransactionBuilder.buildHandshakeSelfStashTx(
                from: walletAddress,
                partnerAddress: contactAddress,
                ourAlias: ourAlias,
                theirAlias: theirAlias,
                isResponse: isResponse,
                senderPrivateKey: privateKey,
                utxos: utxos
            )
            let txId = try await NodePoolService.shared.submitTransaction(stashTx, allowOrphan: allowOrphan)
            print("[ChatService] Self-stash handshake submitted: \(txId)")
        } catch {
            print("[ChatService] Failed to submit self-stash handshake tx: \(error.localizedDescription)")
            queueSelfStash(contactAddress: contactAddress, ourAlias: ourAlias, theirAlias: theirAlias, isResponse: isResponse)
        }
    }

    private func changeUtxo(from handshakeTx: KaspaRpcTransaction, txId: String?, senderScript: Data) -> UTXO? {
        guard let txId = txId else { return nil }
        for (idx, output) in handshakeTx.outputs.enumerated() {
            if output.scriptPublicKey.script == senderScript, output.value > 0 {
                return UTXO(
                    address: "",
                    outpoint: UTXO.Outpoint(transactionId: txId, index: UInt32(idx)),
                    amount: output.value,
                    scriptPublicKey: senderScript,
                    blockDaaScore: 0,
                    isCoinbase: false
                )
            }
        }
        return nil
    }

    /// Attempt to send any queued self-stash handshake transactions using current UTXOs
    private func attemptPendingSelfStashSends() async {
        guard let wallet = WalletManager.shared.currentWallet,
              let privateKey = WalletManager.shared.getPrivateKey(),
              !pendingSelfStash.isEmpty else { return }

        do {
            let rpcManager = NodePoolService.shared
            if !rpcManager.isConnected {
                let settings = currentSettings
                try await rpcManager.connect(network: settings.networkType)
            }

            let utxos = try await rpcManager.getUtxosByAddresses([wallet.publicAddress])
            updateWalletBalanceIfNeeded(address: wallet.publicAddress, utxos: utxos)
            guard !utxos.isEmpty else { return }

            var remaining = utxos
            var succeeded: [PendingSelfStash] = []

            for job in pendingSelfStash {
                guard !remaining.isEmpty else { break }
                let (first, rest) = splitUtxosForSelfStash(remaining)
                remaining = rest
                do {
                    let stashTx = try KasiaTransactionBuilder.buildHandshakeSelfStashTx(
                        from: wallet.publicAddress,
                        partnerAddress: job.partnerAddress,
                        ourAlias: job.ourAlias,
                        theirAlias: job.theirAlias,
                        isResponse: job.isResponse,
                        senderPrivateKey: privateKey,
                        utxos: first
                    )
                    let (txId, endpoint) = try await rpcManager.submitTransaction(stashTx, allowOrphan: false)
                    NSLog("[ChatService] Self-stash submitted: \(txId) via \(endpoint)")
                    succeeded.append(job)
                } catch {
                    print("[ChatService] Pending self-stash failed: \(error.localizedDescription)")
                }
            }

            if !succeeded.isEmpty {
                pendingSelfStash.removeAll { job in
                    succeeded.contains(where: { $0.id == job.id })
                }
                savePendingSelfStash()
            }
        } catch {
            print("[ChatService] attemptPendingSelfStashSends error: \(error.localizedDescription)")
        }
    }

    /// Update a pending message with the real transaction ID
    @discardableResult
    private func updatePendingMessage(_ pendingTxId: String, withRealTxId txId: String, contactAddress: String) -> Bool {
        if let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            if updatePendingMessage(in: convIndex, pendingTxId: pendingTxId, withRealTxId: txId) {
                removePendingOutgoingGlobally(pendingTxId)
                return true
            }
        }

        if let convIndex = conversations.firstIndex(where: { conversation in
            conversation.messages.contains(where: { $0.txId == pendingTxId })
        }) {
            if updatePendingMessage(in: convIndex, pendingTxId: pendingTxId, withRealTxId: txId) {
                removePendingOutgoingGlobally(pendingTxId)
                return true
            }
        }

        return false
    }

    @discardableResult
    private func updatePendingMessage(in convIndex: Int, pendingTxId: String, withRealTxId txId: String) -> Bool {
        updateConversation(at: convIndex) { conversation in
            guard let msgIndex = conversation.messages.firstIndex(where: { $0.txId == pendingTxId }) else { return }
            let oldMessage = conversation.messages[msgIndex]
            if pendingTxId != txId {
                conversation.messages.removeAll(where: { $0.txId == txId })
            }
            let newMessage = ChatMessage(
                id: oldMessage.id,
                txId: txId,
                senderAddress: oldMessage.senderAddress,
                receiverAddress: oldMessage.receiverAddress,
                content: oldMessage.content,
                timestamp: oldMessage.timestamp,
                blockTime: oldMessage.blockTime,
                acceptingBlock: "mempool",
                isOutgoing: oldMessage.isOutgoing,
                messageType: oldMessage.messageType,
                deliveryStatus: .sent
            )
            conversation.messages[msgIndex] = newMessage
        }

        return true
    }

    /// Mark a pending message as failed (keeps it in the conversation for retry)
    private func markPendingMessageFailed(_ pendingTxId: String, contactAddress: String) {
        if let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            updateConversation(at: convIndex) { conversation in
                if let msgIndex = conversation.messages.firstIndex(where: { $0.txId == pendingTxId }) {
                    let oldMessage = conversation.messages[msgIndex]
                    let updatedMessage = ChatMessage(
                        id: oldMessage.id,
                        txId: oldMessage.txId,
                        senderAddress: oldMessage.senderAddress,
                        receiverAddress: oldMessage.receiverAddress,
                        content: oldMessage.content,
                        timestamp: oldMessage.timestamp,
                        blockTime: oldMessage.blockTime,
                        acceptingBlock: oldMessage.acceptingBlock,
                        isOutgoing: oldMessage.isOutgoing,
                        messageType: oldMessage.messageType,
                        deliveryStatus: .failed
                    )
                    conversation.messages[msgIndex] = updatedMessage
                }
            }
        }
        markOutgoingAttemptFailed(messageId: resolveMessageIdForPending(contactAddress: contactAddress, pendingTxId: pendingTxId), pendingTxId: pendingTxId)
        removePendingOutgoing(contactAddress: contactAddress, pendingTxId: pendingTxId)
    }

    private func resetPendingMessage(_ pendingTxId: String, contactAddress: String) {
        if let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            updateConversation(at: convIndex) { conversation in
                if let msgIndex = conversation.messages.firstIndex(where: { $0.txId == pendingTxId }) {
                    let oldMessage = conversation.messages[msgIndex]
                    let updatedMessage = ChatMessage(
                        id: oldMessage.id,
                        txId: oldMessage.txId,
                        senderAddress: oldMessage.senderAddress,
                        receiverAddress: oldMessage.receiverAddress,
                        content: oldMessage.content,
                        timestamp: oldMessage.timestamp,
                        blockTime: oldMessage.blockTime,
                        acceptingBlock: oldMessage.acceptingBlock,
                        isOutgoing: oldMessage.isOutgoing,
                        messageType: oldMessage.messageType,
                        deliveryStatus: .pending
                    )
                    conversation.messages[msgIndex] = updatedMessage
                }
            }
        }
        if let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            let pending = conversations[convIndex].messages.first(where: { $0.txId == pendingTxId })
            if let pending {
                enqueuePendingOutgoing(contactAddress: contactAddress, pendingTxId: pendingTxId, messageType: pending.messageType, timestamp: pending.timestamp)
            }
        }
    }

    private func updateOutgoingPendingMessageIfMatch(
        contactAddress: String,
        newTxId: String,
        content: String,
        messageType: ChatMessage.MessageType
    ) -> Bool {
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return false
        }

        var didUpdate = false
        updateConversation(at: convIndex) { conversation in
            if let existingIndex = conversation.messages.firstIndex(where: { $0.txId == newTxId }) {
                let existing = conversation.messages[existingIndex]
                if existing.isOutgoing && existing.deliveryStatus != .sent {
                    let updated = ChatMessage(
                        id: existing.id,
                        txId: existing.txId,
                        senderAddress: existing.senderAddress,
                        receiverAddress: existing.receiverAddress,
                        content: existing.content,
                        timestamp: existing.timestamp,
                        blockTime: existing.blockTime,
                        acceptingBlock: existing.acceptingBlock ?? "mempool",
                        isOutgoing: existing.isOutgoing,
                        messageType: existing.messageType,
                        deliveryStatus: .sent
                    )
                    conversation.messages[existingIndex] = updated
                }
                didUpdate = true
                return
            }

            // Do not match by content; duplicates are allowed. Pending promotion is handled by queue order.
        }

        return didUpdate
    }

    @discardableResult
    private func updatePendingMessageById(
        _ messageId: UUID,
        newTxId: String,
        contactAddress: String? = nil
    ) -> Bool {
        let targetIndex: Int?
        if let contactAddress,
           let index = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            targetIndex = index
        } else {
            targetIndex = conversations.firstIndex(where: { conversation in
                conversation.messages.contains(where: { $0.id == messageId })
            })
        }

        guard let convIndex = targetIndex else { return false }

        var didUpdate = false
        var oldPendingTxId: String?
        updateConversation(at: convIndex) { conversation in
            guard let msgIndex = conversation.messages.firstIndex(where: { $0.id == messageId }) else { return }
            let oldMessage = conversation.messages[msgIndex]
            oldPendingTxId = oldMessage.txId
            if oldMessage.txId != newTxId {
                conversation.messages.removeAll(where: { $0.txId == newTxId })
            }
            let newMessage = ChatMessage(
                id: oldMessage.id,
                txId: newTxId,
                senderAddress: oldMessage.senderAddress,
                receiverAddress: oldMessage.receiverAddress,
                content: oldMessage.content,
                timestamp: oldMessage.timestamp,
                blockTime: oldMessage.blockTime,
                acceptingBlock: "mempool",
                isOutgoing: oldMessage.isOutgoing,
                messageType: oldMessage.messageType,
                deliveryStatus: .sent
            )
            conversation.messages[msgIndex] = newMessage
            didUpdate = true
        }

        guard didUpdate, let oldPendingTxId else { return false }
        removePendingOutgoingGlobally(oldPendingTxId)
        return true
    }

    private func updateOldestPendingOutgoingMessage(
        contactAddress: String,
        newTxId: String,
        messageType: ChatMessage.MessageType
    ) -> Bool {
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return false
        }

        var didUpdate = false
        var oldPendingTxId: String?
        updateConversation(at: convIndex) { conversation in
            let candidates = conversation.messages
                .filter { $0.isOutgoing && $0.deliveryStatus != .sent && $0.messageType == messageType }
                .sorted(by: isMessageOrderedBefore)
            guard let candidate = candidates.first,
                  let msgIndex = conversation.messages.firstIndex(where: { $0.id == candidate.id }) else { return }

            if candidate.txId != newTxId {
                conversation.messages.removeAll(where: { $0.txId == newTxId })
            }
            oldPendingTxId = candidate.txId
            let newMessage = ChatMessage(
                id: candidate.id,
                txId: newTxId,
                senderAddress: candidate.senderAddress,
                receiverAddress: candidate.receiverAddress,
                content: candidate.content,
                timestamp: candidate.timestamp,
                blockTime: candidate.blockTime,
                acceptingBlock: candidate.acceptingBlock ?? "mempool",
                isOutgoing: candidate.isOutgoing,
                messageType: candidate.messageType,
                deliveryStatus: .sent
            )
            conversation.messages[msgIndex] = newMessage
            didUpdate = true
        }

        guard didUpdate, let oldPendingTxId else { return false }
        removePendingOutgoing(contactAddress: contactAddress, pendingTxId: oldPendingTxId)
        return true
    }

    private func updateMostRecentPendingOutgoingMessage(
        contactAddress: String,
        newTxId: String,
        messageType: ChatMessage.MessageType
    ) -> Bool {
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return false
        }

        var didUpdate = false
        updateConversation(at: convIndex) { conversation in
            let candidates = conversation.messages
                .filter { $0.isOutgoing && $0.deliveryStatus != .sent && $0.messageType == messageType }
                .sorted(by: isMessageOrderedBefore)

            guard let candidate = candidates.first,
                  let msgIndex = conversation.messages.firstIndex(where: { $0.id == candidate.id }) else { return }

            conversation.messages.removeAll(where: { $0.txId == newTxId })
            let newMessage = ChatMessage(
                id: candidate.id,
                txId: newTxId,
                senderAddress: candidate.senderAddress,
                receiverAddress: candidate.receiverAddress,
                content: candidate.content,
                timestamp: candidate.timestamp,
                blockTime: candidate.blockTime,
                acceptingBlock: candidate.acceptingBlock ?? "mempool",
                isOutgoing: candidate.isOutgoing,
                messageType: candidate.messageType,
                deliveryStatus: .sent
            )
            conversation.messages[msgIndex] = newMessage
            didUpdate = true
        }

        return didUpdate
    }

    func markConversationAsRead(_ conversation: Conversation) {
        if let index = conversations.firstIndex(where: { $0.id == conversation.id }) {
            // Use both in-memory window and persistent store cursor so pagination does not
            // block read marker advancement.
            let lastInMemoryIncoming = conversation.messages
                .filter { !$0.isOutgoing }
                .max(by: { $0.blockTime < $1.blockTime })
            let storeCursor = messageStore.fetchLatestIncomingCursor(contactAddress: conversation.contact.address)
            let inMemoryBlockTime = Int64(lastInMemoryIncoming?.blockTime ?? 0)
            let storeBlockTime = storeCursor?.blockTime ?? 0

            updateConversation(at: index, persist: false) { updated in
                updated.unreadCount = 0
            }
            // Persist unread reset immediately so reloads/CloudKit merges cannot resurrect
            // a stale unread badge when the read cursor does not advance.
            messageStore.updateConversationUnread(contactAddress: conversation.contact.address, unreadCount: 0)

            // Sync read status to CloudKit (debounced)
            let targetBlockTime = max(inMemoryBlockTime, storeBlockTime)
            if targetBlockTime > 0 {
                let targetTxId: String?
                if storeBlockTime > inMemoryBlockTime {
                    targetTxId = storeCursor?.txId
                } else {
                    targetTxId = lastInMemoryIncoming?.txId
                }
                NSLog(
                    "[ChatService] Marking conversation %@ as read at blockTime=%lld (inMemory=%lld, store=%lld)",
                    String(conversation.contact.address.suffix(8)),
                    targetBlockTime,
                    inMemoryBlockTime,
                    storeBlockTime
                )
                ReadStatusSyncManager.shared.markAsRead(
                    contactAddress: conversation.contact.address,
                    lastReadTxId: targetTxId,
                    lastReadBlockTime: UInt64(targetBlockTime)
                )
            }
        }
    }

    // MARK: - Private Methods

    /// Check the Kasia indexer for a handshake matching the given txId
    /// Used as fallback when the Kaspa REST API doesn't return the transaction payload
    private func checkIndexerForHandshake(txId: String, myAddress: String) async -> HandshakeResponse? {
        // Query recent incoming handshakes from the indexer
        // Use a 60-second lookback window to narrow the search
        let recentBlockTime = UInt64(max(0, Date().timeIntervalSince1970 * 1000 - 60_000))

        // Try up to 3 times with delays (indexer may need time to index the transaction)
        for attempt in 1...3 {
            do {
                let handshakes = try await apiClient.getHandshakesByReceiver(
                    address: myAddress, limit: 20, blockTime: recentBlockTime
                )
                if let match = handshakes.first(where: { $0.txId == txId }) {
                    return match
                }
            } catch {
                if ChatService.handleDpiPaginationFailure(error, context: "handshake lookup") {
                    return nil
                }
                NSLog("[ChatService] Indexer handshake check attempt %d failed: %@", attempt, error.localizedDescription)
            }

            if attempt < 3 {
                try? await Task.sleep(nanoseconds: 2_000_000_000) // 2s between retries
            }
        }

        return nil
    }

    private func fetchIncomingHandshakes(for address: String, blockTime: UInt64) async throws -> [HandshakeResponse] {
        let key = "in|\(address)|\(blockTime)|50"
        if let existing = handshakeFetchTasks[key] {
            NSLog("[ChatService] Handshake fetch in-flight, reusing task (%@)", String(address.suffix(10)))
            return try await existing.value
        }
        let task = Task { [apiClient] in
            do {
                return try await apiClient.getHandshakesByReceiver(address: address, limit: 50, blockTime: blockTime)
            } catch {
                if ChatService.handleDpiPaginationFailure(error, context: "incoming handshakes") {
                    return []
                }
                throw error
            }
        }
        handshakeFetchTasks[key] = task
        defer { handshakeFetchTasks[key] = nil }
        return try await task.value
    }

    private func fetchOutgoingHandshakes(for address: String, blockTime: UInt64) async throws -> [HandshakeResponse] {
        let key = "out|\(address)|\(blockTime)|50"
        if let existing = handshakeFetchTasks[key] {
            NSLog("[ChatService] Handshake fetch in-flight, reusing task (%@)", String(address.suffix(10)))
            return try await existing.value
        }
        let task = Task { [apiClient] in
            do {
                return try await apiClient.getHandshakesBySender(address: address, limit: 50, blockTime: blockTime)
            } catch {
                if ChatService.handleDpiPaginationFailure(error, context: "outgoing handshakes") {
                    return []
                }
                throw error
            }
        }
        handshakeFetchTasks[key] = task
        defer { handshakeFetchTasks[key] = nil }
        return try await task.value
    }

    private func fetchIncomingPayments(for address: String, blockTime: UInt64) async throws -> [PaymentResponse] {
        let key = "in|\(address)|\(blockTime)"
        if let existing = paymentFetchTasks[key] {
            NSLog("[ChatService] Payment fetch in-flight, reusing task (%@)", String(address.suffix(10)))
            return try await existing.value
        }
        NSLog("[ChatService] === FETCH INCOMING PAYMENTS START === address=%@, blockTime=%llu", String(address.suffix(10)), blockTime)
        let task = Task { [self] in
            // Fetch from Kaspa API instead of indexer
            let result = try await fetchPaymentsFromKaspaAPI(for: address, blockTime: blockTime, incoming: true)
            NSLog("[ChatService] === FETCH INCOMING PAYMENTS DONE === count=%d", result.count)
            return result
        }
        paymentFetchTasks[key] = task
        defer { paymentFetchTasks[key] = nil }
        do {
            return try await task.value
        } catch {
            NSLog("[ChatService] === FETCH INCOMING PAYMENTS ERROR === %@", error.localizedDescription)
            throw error
        }
    }

    private func fetchOutgoingPayments(for address: String, blockTime: UInt64) async throws -> [PaymentResponse] {
        let key = "out|\(address)|\(blockTime)"
        if let existing = paymentFetchTasks[key] {
            NSLog("[ChatService] Payment fetch in-flight, reusing task (%@)", String(address.suffix(10)))
            return try await existing.value
        }
        NSLog("[ChatService] === FETCH OUTGOING PAYMENTS START === address=%@, blockTime=%llu", String(address.suffix(10)), blockTime)
        let task = Task { [self] in
            // Fetch from Kaspa API instead of indexer
            let result = try await fetchPaymentsFromKaspaAPI(for: address, blockTime: blockTime, incoming: false)
            NSLog("[ChatService] === FETCH OUTGOING PAYMENTS DONE === count=%d", result.count)
            return result
        }
        paymentFetchTasks[key] = task
        defer { paymentFetchTasks[key] = nil }
        do {
            return try await task.value
        } catch {
            NSLog("[ChatService] === FETCH OUTGOING PAYMENTS ERROR === %@", error.localizedDescription)
            throw error
        }
    }

    private func applyMessageRetention(to blockTime: UInt64) -> UInt64 {
        guard let cutoff = messageRetentionCutoffMs() else { return blockTime }
        return max(blockTime, cutoff)
    }

    private func messageRetentionCutoffMs() -> UInt64? {
        let retention = SettingsViewModel.loadSettings().messageRetention
        guard let days = retention.days, days > 0 else { return nil }
        let seconds = Double(days) * 86_400.0
        let cutoff = Date().addingTimeInterval(-seconds).timeIntervalSince1970 * 1000
        return UInt64(max(0, cutoff))
    }

    /// Fetch payments directly from Kaspa REST API by scanning all transactions
    /// Payments are regular Kaspa transactions - payload is optional for encrypted message
    private func fetchPaymentsFromKaspaAPI(for address: String, blockTime: UInt64, incoming: Bool) async throws -> [PaymentResponse] {
        let direction = incoming ? "INCOMING" : "OUTGOING"
        NSLog("[ChatService] fetchPaymentsFromKaspaAPI START - direction=%@, address=%@", direction, String(address.suffix(10)))

        // Fetch all transactions with pagination
        let transactions = await fetchFullTransactionsPaginated(for: address, stopAtBlockTime: blockTime)
        NSLog("[ChatService] Fetched total %d transactions from Kaspa API", transactions.count)

        var payments: [PaymentResponse] = []
        var skippedOld = 0
        var skippedDirection = 0

        for tx in transactions {
            // Get block time directly from transaction
            let txBlockTime = tx.blockTime ?? 0

            // Skip transactions older than our filter time
            if blockTime > 0 && txBlockTime > 0 && txBlockTime <= blockTime {
                skippedOld += 1
                continue
            }

            // Check if we are the sender by looking at inputs
            var weAreSender = false
            var senderAddress = ""
            if let inputs = tx.inputs {
                for input in inputs {
                    if let inputAddr = input.previousOutpointAddress, !inputAddr.isEmpty {
                        if inputAddr == address {
                            weAreSender = true
                        } else if senderAddress.isEmpty {
                            senderAddress = inputAddr
                        }
                    }
                }
            }

            // Analyze outputs
            var totalToUs: UInt64 = 0
            var totalToOthers: UInt64 = 0
            var recipientAddress = ""
            var recipientAmount: UInt64 = 0

            for output in tx.outputs {
                if let addr = output.scriptPublicKeyAddress, !addr.isEmpty {
                    if addr == address {
                        totalToUs += output.amount
                    } else {
                        totalToOthers += output.amount
                        // For outgoing: track recipient (non-change output)
                        // Usually the payment is smaller than change, but we want the non-sender address
                        if addr != senderAddress {
                            // This is likely the actual recipient, not change back to sender
                            if recipientAddress.isEmpty || output.amount < recipientAmount {
                                // Prefer smaller amounts as actual payments (larger is usually change)
                                recipientAddress = addr
                                recipientAmount = output.amount
                            }
                        } else if recipientAddress.isEmpty {
                            // Fallback: use sender's change address if no other recipient
                            recipientAddress = addr
                            recipientAmount = output.amount
                        }
                    }
                }
            }

            // Determine transaction direction based on inputs
            // Incoming: we receive funds AND we are NOT the sender
            // Outgoing: we are the sender AND there are outputs to others
            let isIncomingTx = totalToUs > 0 && !weAreSender
            let isOutgoingTx = weAreSender && totalToOthers > 0

            // Filter based on requested direction
            if incoming && !isIncomingTx {
                skippedDirection += 1
                continue
            }
            if !incoming && !isOutgoingTx {
                skippedDirection += 1
                continue
            }

            var sender = ""
            var receiver = ""
            var amount: UInt64 = 0

            if isIncomingTx && incoming {
                // We received payment - amount is what was sent to us
                receiver = address
                amount = totalToUs
                sender = senderAddress.isEmpty ? "pending_resolution" : senderAddress

                // Skip self-stash transactions (sender == receiver) - these are handled as contextual messages
                if sender == address {
                    NSLog("[ChatService] Skipping self-stash payment %@ - handled as contextual message",
                          String(tx.transactionId.prefix(12)))
                    continue
                }
            } else if isOutgoingTx && !incoming {
                // We sent payment - find the actual recipient (not our change)
                sender = address
                // Find the output that's NOT our change
                for output in tx.outputs {
                    if let addr = output.scriptPublicKeyAddress, !addr.isEmpty, addr != address {
                        receiver = addr
                        amount = output.amount
                        break
                    }
                }
            }

            // Skip if we couldn't determine the other party
            if receiver.isEmpty {
                continue
            }

            // Get optional payload (may contain encrypted message)
            let messagePayload = tx.payload
            if let payload = messagePayload, !payload.isEmpty {
                let isContextual = isContextualPayload(payload)
                let isSelfStash = isSelfStashPayload(payload)
                if isContextual || isSelfStash {
                    NSLog("[ChatService] Skipping non-payment tx %@ (isContextual: %d, isSelfStash: %d, payload prefix: %@)",
                          String(tx.transactionId.prefix(12)),
                          isContextual ? 1 : 0,
                          isSelfStash ? 1 : 0,
                          String(payload.prefix(44)))
                    continue
                }
            }

            // Verify Schnorr signatures on incoming payments from REST API
            if incoming, let inputs = tx.inputs {
                let verificationInputs = inputs.compactMap { input -> KasiaTransactionBuilder.VerificationInput? in
                    guard let hash = input.previousOutpointHash,
                          let idxStr = input.previousOutpointIndex,
                          let idx = UInt32(idxStr),
                          let sigScript = input.signatureScript,
                          let addr = input.previousOutpointAddress,
                          let amt = input.previousOutpointAmount else { return nil }
                    return KasiaTransactionBuilder.VerificationInput(
                        previousOutpointHash: hash,
                        previousOutpointIndex: idx,
                        signatureScript: sigScript,
                        previousOutpointAddress: addr,
                        previousOutpointAmount: amt,
                        sequence: input.sequence?.value ?? 0,
                        sigOpCount: input.sigOpCount?.value ?? 1
                    )
                }
                let verificationOutputs = tx.outputs.map { output in
                    KasiaTransactionBuilder.VerificationOutput(
                        amount: output.amount,
                        scriptPublicKey: output.scriptPublicKey ?? ""
                    )
                }
                let txVersion = tx.version ?? 0
                let txLockTime = tx.lockTime?.value ?? 0
                let txGas = tx.gas?.value ?? 0
                let subnetData = CryptoUtils.hexToData(tx.subnetworkId ?? "") ?? Data(repeating: 0, count: 20)
                let payloadData = CryptoUtils.hexToData(tx.payload ?? "") ?? Data()

                if !verificationInputs.isEmpty {
                    let sigsValid = KasiaTransactionBuilder.verifyTransactionSignatures(
                        inputs: verificationInputs,
                        outputs: verificationOutputs,
                        version: txVersion,
                        lockTime: txLockTime,
                        subnetworkId: subnetData,
                        gas: txGas,
                        payload: payloadData
                    )
                    if !sigsValid {
                        NSLog("[ChatService] WARNING: Skipping payment %@ - Schnorr signature verification FAILED",
                              String(tx.transactionId.prefix(16)))
                        continue
                    }
                }
            }

            let payment = PaymentResponse(
                txId: tx.transactionId,
                sender: sender,
                receiver: receiver,
                amount: amount,
                message: nil,
                blockTime: txBlockTime,
                acceptingBlock: tx.acceptingBlockHash,
                acceptingDaaScore: tx.acceptingBlockBlueScore,
                messagePayload: messagePayload
            )

            payments.append(payment)
            let dirStr = incoming ? "IN" : "OUT"
            NSLog("[ChatService] Found payment [%@]: %@... amount=%llu sompi", dirStr, String(tx.transactionId.prefix(16)), amount)
        }

        let dirStr = incoming ? "incoming" : "outgoing"
        NSLog("[ChatService] fetchPaymentsFromKaspaAPI DONE - found %d %@ payments (skipped: %d old, %d wrong direction)", payments.count, dirStr, skippedOld, skippedDirection)
        return payments
    }

    /// Fetch full transactions with automatic pagination
    /// - Parameters:
    ///   - address: Kaspa address to fetch transactions for
    ///   - stopAtBlockTime: Stop fetching when we find transactions older than this (0 = fetch all)
    ///   - pageSize: Number of transactions per page (default: 50)
    ///   - maxTransactions: Maximum total transactions to fetch (default: 10000)
    /// - Returns: Array of all fetched transactions
    private func fetchFullTransactionsPaginated(
        for address: String,
        stopAtBlockTime: UInt64 = 0,
        pageSize: Int = 50,
        maxTransactions: Int = 10000
    ) async -> [KaspaFullTransactionResponse] {
        var allTransactions: [KaspaFullTransactionResponse] = []
        var offset = 0
        var pageCount = 0

        while allTransactions.count < maxTransactions {
            guard let url = kaspaRestURL(
                path: "/addresses/\(address)/full-transactions",
                queryItems: [
                    URLQueryItem(name: "limit", value: "\(pageSize)"),
                    URLQueryItem(name: "offset", value: "\(offset)"),
                    URLQueryItem(name: "resolve_previous_outpoints", value: "light")
                ]
            ) else {
                NSLog("[ChatService] Invalid URL for fetching transactions")
                break
            }

            if pageCount == 0 {
                NSLog("[ChatService] Kaspa API URL: %@", url.absoluteString)
            }

            do {
                let (data, response) = try await URLSession.shared.data(from: url)

                guard let httpResponse = response as? HTTPURLResponse,
                      (200...299).contains(httpResponse.statusCode) else {
                    NSLog("[ChatService] Kaspa API returned non-2xx status")
                    break
                }

                let transactions = try JSONDecoder().decode([KaspaFullTransactionResponse].self, from: data)

                if transactions.isEmpty {
                    break
                }

                allTransactions.append(contentsOf: transactions)

                // Check if we've reached transactions older than our stop time
                if stopAtBlockTime > 0 {
                    // Find the oldest transaction in this batch
                    let oldestBlockTime = transactions.compactMap { $0.blockTime }.min() ?? 0
                    if oldestBlockTime > 0 && oldestBlockTime <= stopAtBlockTime {
                        NSLog("[ChatService] Pagination: reached transactions older than stopAtBlockTime, stopping")
                        break
                    }
                }

                // If we got fewer than pageSize, we've reached the end
                if transactions.count < pageSize {
                    break
                }

                // Continue to next page
                offset += pageSize
                pageCount += 1

                if pageCount > 0 {
                    NSLog("[ChatService] Pagination: fetched page %d, total transactions: %d, offset: %d",
                          pageCount + 1, allTransactions.count, offset)
                }

            } catch {
                NSLog("[ChatService] Pagination error: %@", error.localizedDescription)
                break
            }
        }

        if allTransactions.count >= maxTransactions {
            NSLog("[ChatService] Pagination: reached max transactions limit (%d)", maxTransactions)
        }

        return allTransactions
    }

    private func processHandshakes(_ handshakes: [HandshakeResponse], isOutgoing: Bool, myAddress: String, privateKey: Data?) async {
        for handshake in handshakes {
            let resolvedSender = await resolveSenderAddress(
                sender: handshake.sender,
                txId: handshake.txId,
                receiver: handshake.receiver
            )
            let contactAddress = isOutgoing ? handshake.receiver : (resolvedSender ?? handshake.sender)
            if contactAddress.isEmpty {
                print("[ChatService] Skipping handshake \(handshake.txId) - missing sender")
                continue
            }
            if !isOutgoing {
                clearDeclined(contactAddress)
            }

            // Auto-add contact if not exists
            let existingContact = contactsManager.getContact(byAddress: contactAddress)
            _ = contactsManager.getOrCreateContact(address: contactAddress)
            if existingContact == nil {
                print("[ChatService] Discovered NEW contact from handshake: \(contactAddress.suffix(10))")
            }

            // Try to decrypt handshake payload to extract alias
            var content = "[Handshake]"
            var extractedAlias: String?
            var extractedConversationId: String?

            if let privKey = privateKey, !isOutgoing {
                // For incoming handshakes, decrypt to get sender's alias (runs on background thread)
                if let decrypted = await decryptHandshakePayload(handshake.messagePayload, privateKey: privKey) {
                    content = "[Request to communicate]"
                    extractedAlias = decrypted.alias  // may be nil for deterministic handshakes
                    extractedConversationId = decrypted.conversationId
                    if let alias = decrypted.alias {
                        print("[ChatService] Extracted alias '\(alias)' from handshake by \(contactAddress)")
                    } else {
                        print("[ChatService] Received alias-less (deterministic) handshake from \(contactAddress)")
                    }
                }
            } else {
                // For outgoing handshakes, we know our own alias
                content = decodeMessagePayload(handshake.messagePayload) ?? "[Handshake sent]"
            }

            // Store the alias for this contact
            if let alias = extractedAlias {
                addConversationAlias(alias, for: contactAddress, blockTime: handshake.blockTime)
            } else if !isOutgoing {
                // Alias-less handshake = peer uses deterministic aliases
                routingStates[contactAddress]?.peerSupportsDeterministic = true
            }
            if let convId = extractedConversationId {
                conversationIds[contactAddress] = convId
            }

            // If a payment message with this txId already exists, remove it first
            // (handles UTXO notification initially classifying a handshake as payment)
            if let existingMsg = findLocalMessage(txId: handshake.txId), existingMsg.messageType == .payment {
                NSLog("[ChatService] Replacing misclassified payment with handshake for tx %@", String(handshake.txId.prefix(12)))
                removeMessage(txId: handshake.txId)
            }

            let message = ChatMessage(
                txId: handshake.txId,
                senderAddress: resolvedSender ?? handshake.sender,
                receiverAddress: handshake.receiver,
                content: content,
                timestamp: Date(timeIntervalSince1970: TimeInterval((handshake.blockTime ?? 0) / 1000)),
                blockTime: handshake.blockTime ?? 0,
                acceptingBlock: handshake.acceptingBlock,
                isOutgoing: isOutgoing,
                messageType: .handshake
            )

            addMessageToConversation(message, contactAddress: contactAddress)

            // Update last poll time
            if let blockTime = handshake.blockTime, blockTime > lastPollTime {
                updateLastPollTime(blockTime)
            }
        }
    }

    /// Reclassify payment messages that should be handshakes.
    /// After self-stash recovery, we know which contacts have handshakes via ourAliases/conversationAliases.
    /// If a conversation has alias data but no handshake message, the earliest payment is the handshake.
    private func reclassifyMisidentifiedHandshakes() {
        var reclassified = 0

        for (contactAddress, aliases) in ourAliases where !aliases.isEmpty {
            guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else { continue }
            let conv = conversations[convIndex]

            // Check if outgoing handshake message exists
            let hasOutgoingHandshake = conv.messages.contains { $0.messageType == .handshake && $0.isOutgoing }
            if !hasOutgoingHandshake {
                // Find the earliest outgoing payment â€” it's the handshake
                if let earliestPayment = conv.messages
                    .filter({ $0.messageType == .payment && $0.isOutgoing })
                    .min(by: { $0.blockTime < $1.blockTime }) {
                    NSLog("[ChatService] Reclassifying outgoing payment %@ as handshake for %@",
                          String(earliestPayment.txId.prefix(12)), String(contactAddress.suffix(10)))
                    replaceMessageType(txId: earliestPayment.txId, contactAddress: contactAddress, newType: .handshake, newContent: "[Handshake sent]")
                    reclassified += 1
                }
            }
        }

        for contactAddress in conversationAliases.keys {
            guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else { continue }
            let conv = conversations[convIndex]

            // Check if incoming handshake message exists
            let hasIncomingHandshake = conv.messages.contains { $0.messageType == .handshake && !$0.isOutgoing }
            if !hasIncomingHandshake {
                // Find the earliest incoming payment â€” it's the handshake
                if let earliestPayment = conv.messages
                    .filter({ $0.messageType == .payment && !$0.isOutgoing })
                    .min(by: { $0.blockTime < $1.blockTime }) {
                    let content = "[Request to communicate]"
                    NSLog("[ChatService] Reclassifying incoming payment %@ as handshake for %@",
                          String(earliestPayment.txId.prefix(12)), String(contactAddress.suffix(10)))
                    replaceMessageType(txId: earliestPayment.txId, contactAddress: contactAddress, newType: .handshake, newContent: content)
                    reclassified += 1
                }
            }
        }

        if reclassified > 0 {
            NSLog("[ChatService] Reclassified %d payment(s) as handshake(s)", reclassified)
        }

        // Ensure aliases are set for contacts with completed handshake exchange.
        // With deterministic aliases, we can derive the correct alias from the private key.
        // Falls back to random alias only if no private key is available.
        for conversation in conversations {
            let addr = conversation.contact.address
            let hasOutgoing = conversation.messages.contains { $0.messageType == .handshake && $0.isOutgoing }
            let hasIncoming = conversation.messages.contains { $0.messageType == .handshake && !$0.isOutgoing }
            let hasRouting = routingStates[addr] != nil
            if hasOutgoing && hasIncoming && !hasRouting && (ourAliases[addr]?.isEmpty ?? true) {
                let fallbackAlias = generateAlias()
                addOurAlias(fallbackAlias, for: addr, blockTime: nil)
                NSLog("[ChatService] Generated fallback alias for %@ (self-stash unavailable)", String(addr.suffix(10)))
            }
        }
    }

    /// Replace a message's type and content in a conversation
    private func replaceMessageType(txId: String, contactAddress: String, newType: ChatMessage.MessageType, newContent: String) {
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else { return }
        updateConversation(at: convIndex) { conversation in
            if let msgIndex = conversation.messages.firstIndex(where: { $0.txId == txId }) {
                let old = conversation.messages[msgIndex]
                conversation.messages[msgIndex] = ChatMessage(
                    txId: old.txId,
                    senderAddress: old.senderAddress,
                    receiverAddress: old.receiverAddress,
                    content: newContent,
                    timestamp: old.timestamp,
                    blockTime: old.blockTime,
                    acceptingBlock: old.acceptingBlock,
                    isOutgoing: old.isOutgoing,
                    messageType: newType
                )
            }
        }
    }

    private func resolveSenderAddress(sender: String, txId: String, receiver: String) async -> String? {
        if isValidKaspaAddress(sender) {
            return sender
        }
        guard let derived = await fetchSenderAddressFromTransaction(txId: txId, receiver: receiver) else {
            return nil
        }
        return derived
    }

    private func isValidKaspaAddress(_ address: String) -> Bool {
        return KaspaAddress.isValid(address)
    }

    /// Check if a payload hex string contains handshake data
    /// Handshake payloads start with hex("ciph_msg:1:handshake:") after the OP_RETURN prefix
    private func isHandshakePayload(_ payloadHex: String) -> Bool {
        guard let payloadString = Self.payloadPrefixString(from: payloadHex, byteCount: 21) else {
            return false
        }
        return payloadString.hasPrefix("ciph_msg:1:handshake:")
    }

    private func isContextualPayload(_ payloadHex: String) -> Bool {
        guard let payloadString = Self.payloadPrefixString(from: payloadHex, byteCount: 16) else {
            return false
        }
        let matches = payloadString.hasPrefix("ciph_msg:1:comm:")
        if !matches && payloadString.hasPrefix("ciph_msg:") {
            // Log near-miss for debugging
            NSLog("[ChatService] Payload prefix '%@' starts with 'ciph_msg:' but not 'ciph_msg:1:comm:'", payloadString)
        }
        return matches
    }

    private func isSelfStashPayload(_ payloadHex: String) -> Bool {
        guard let payloadString = Self.payloadPrefixString(from: payloadHex, byteCount: 22) else {
            return false
        }
        let matches = payloadString.hasPrefix("ciph_msg:1:self_stash:")
        if !matches && payloadString.hasPrefix("ciph_msg:") {
            // Log near-miss for debugging
            NSLog("[ChatService] Payload prefix '%@' starts with 'ciph_msg:' but not 'ciph_msg:1:self_stash:'", payloadString)
        }
        return matches
    }

    private nonisolated static func payloadPrefixString(from payloadHex: String, byteCount: Int) -> String? {
        // Remove OP_RETURN prefix if present (6a followed by length byte)
        var hex = payloadHex
        if hex.hasPrefix("6a") && hex.count >= 4 {
            hex = String(hex.dropFirst(4))  // Drop 6a + length byte (2 chars each)
        }

        let prefixHex = String(hex.prefix(byteCount * 2))
        guard let data = Data(hexString: prefixHex),
              let payloadString = String(data: data, encoding: .utf8) else {
            return nil
        }
        return payloadString
    }

    private func fetchSenderAddressFromTransaction(txId: String, receiver: String) async -> String? {
        // Try full-transaction endpoint first for better data
        guard let url = kaspaRestURL(
            path: "/transactions/\(txId)",
            queryItems: [URLQueryItem(name: "resolve_previous_outpoints", value: "light")]
        ) else { return nil }
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                return nil
            }

            // Try to decode as full transaction first
            if let fullTx = try? JSONDecoder().decode(KaspaFullTransactionResponse.self, from: data) {
                // First try to get sender from resolved input addresses
                if let inputs = fullTx.inputs {
                    for input in inputs {
                        if let inputAddr = input.previousOutpointAddress, !inputAddr.isEmpty, inputAddr != receiver {
                            return inputAddr
                        }
                    }
                }
                // Fallback: get from outputs, excluding the receiver
                let addresses = fullTx.outputs.compactMap { $0.scriptPublicKeyAddress }
                    .filter { !$0.isEmpty && $0 != receiver }
                if let sender = addresses.first {
                    return sender
                }
            }

            // Fallback to simple response
            let decoded = try JSONDecoder().decode(KaspaTransactionResponse.self, from: data)
            let addresses = decoded.outputs.compactMap { $0.scriptPublicKeyAddress }
                .filter { !$0.isEmpty }
            if !receiver.isEmpty {
                if let other = addresses.first(where: { $0 != receiver }) {
                    return other
                }
            }
            return addresses.first
        } catch {
            print("[ChatService] Failed to fetch tx \(txId): \(error.localizedDescription)")
            return nil
        }
    }

    /// Resolve transaction info for incoming payments/handshakes
    /// Requires REST API because we need sender address from resolved inputs
    /// (Mempool entries don't include sender address - see MESSAGING.md)
    private func resolveTransactionInfo(txId: String, ourAddress: String) async -> TransactionResolveInfo? {
        if let indexerInfo = await resolveTransactionInfoFromIndexer(txId: txId, ourAddress: ourAddress) {
            return indexerInfo
        }
        if let restInfo = await resolveTransactionInfoFromKaspaRest(txId: txId, ourAddress: ourAddress) {
            return restInfo
        }
        return nil
    }

    private func resolveTransactionInfoFromIndexer(txId: String, ourAddress: String) async -> TransactionResolveInfo? {
        let nowMs = UInt64(Date().timeIntervalSince1970 * 1000)
        let baseStart = lastPollTime > 300_000 ? lastPollTime - 300_000 : lastPollTime
        let startCandidates: [UInt64] = baseStart > 0 ? [baseStart, 0] : [0]
        var attempt = 0

        for startBlockTime in startCandidates {
            for _ in 0..<2 {
                attempt += 1
                do {
                    let payments = try await apiClient.getPaymentsByReceiverOnce(
                        address: ourAddress,
                        limit: 100,
                        blockTime: startBlockTime
                    )
                    if let payment = payments.first(where: { $0.txId == txId }) {
                        let blockTimeMs = payment.blockTime ?? nowMs
                        if payment.sender == ourAddress {
                            if let fullTx = await fetchKaspaFullTransaction(txId: txId, retries: 1, delayNs: 500_000_000),
                               let derivedSender = deriveSenderFromFullTx(fullTx, excluding: ourAddress) {
                                NSLog("[ChatService] Indexer sender mismatch for %@ - using full tx sender %@",
                                      String(txId.prefix(12)), String(derivedSender.suffix(10)))
                                return TransactionResolveInfo(
                                    sender: derivedSender,
                                    blockTimeMs: fullTx.acceptingBlockTime ?? fullTx.blockTime ?? blockTimeMs,
                                    payload: fullTx.payload ?? payment.messagePayload
                                )
                            }
                        }
                        NSLog("[ChatService] Resolved tx %@ from indexer (attempt %d, start=%llu)",
                              String(txId.prefix(12)), attempt, startBlockTime)
                        return TransactionResolveInfo(
                            sender: payment.sender,
                            blockTimeMs: blockTimeMs,
                            payload: payment.messagePayload
                        )
                    }
                } catch {
                    NSLog("[ChatService] Indexer resolve failed for %@ (attempt %d): %@",
                          String(txId.prefix(12)), attempt, error.localizedDescription)
                }
                try? await Task.sleep(nanoseconds: 600_000_000)
            }
        }

        return nil
    }

    private func resolveTransactionInfoFromKaspaRest(txId: String, ourAddress: String) async -> TransactionResolveInfo? {
        // Use actor to safely share cancellation state
        actor ResolutionState {
            var isResolved = false
            var result: TransactionResolveInfo?

            func trySetResult(_ info: TransactionResolveInfo) -> Bool {
                guard !isResolved else { return false }
                isResolved = true
                result = info
                return true
            }

            func checkResolved() -> Bool { isResolved }
            func getResult() -> TransactionResolveInfo? { result }
        }

        let state = ResolutionState()

        // REST API polling - required because we need sender address from resolved inputs
        // Mempool entries don't include previousOutpointAddress, so we must use REST API
        let restTask = Task {
            guard let url = kaspaRestURL(
                path: "/transactions/\(txId)",
                queryItems: [URLQueryItem(name: "resolve_previous_outpoints", value: "light")]
            ) else { return }
            NSLog("[ChatService] Kaspa REST resolve request: %@", url.absoluteString)

            // Initial delay to give indexer time to process
            try? await Task.sleep(nanoseconds: 1_500_000_000)  // 1500ms

            let maxAttempts = 8
            let pollIntervalNs: UInt64 = 700_000_000  // 700ms

            for attempt in 1...maxAttempts {
                if await state.checkResolved() { return }

                do {
                    let (data, response) = try await URLSession.shared.data(from: url)

                    guard let httpResponse = response as? HTTPURLResponse else {
                        try? await Task.sleep(nanoseconds: pollIntervalNs)
                        continue
                    }

                    if httpResponse.statusCode == 404 || httpResponse.statusCode >= 500 {
                        try? await Task.sleep(nanoseconds: pollIntervalNs)
                        continue
                    }

                    guard (200...299).contains(httpResponse.statusCode) else { continue }

                    let fullTx = try JSONDecoder().decode(KaspaFullTransactionResponse.self, from: data)

                    var sender: String?
                    if let inputs = fullTx.inputs {
                        for input in inputs {
                            if let inputAddr = input.previousOutpointAddress, !inputAddr.isEmpty, inputAddr != ourAddress {
                                sender = inputAddr
                                break
                            }
                        }
                    }

                    guard let senderAddress = sender else {
                        try? await Task.sleep(nanoseconds: pollIntervalNs)
                        continue
                    }

                    let blockTimeMs = fullTx.acceptingBlockTime ?? fullTx.blockTime ?? UInt64(Date().timeIntervalSince1970 * 1000)

                    let info = TransactionResolveInfo(
                        sender: senderAddress,
                        blockTimeMs: blockTimeMs,
                        payload: fullTx.payload
                    )

                    if await state.trySetResult(info) {
                        NSLog("[ChatService] Resolved tx %@ from REST API on attempt %d", String(txId.prefix(12)), attempt)
                        return
                    }
                } catch {
                    try? await Task.sleep(nanoseconds: pollIntervalNs)
                }
            }
        }

        // Wait for REST API to complete with a result or timeout
        let timeout: UInt64 = 12_000_000_000  // 12 seconds max
        let startTime = DispatchTime.now()

        while true {
            if let result = await state.getResult() {
                restTask.cancel()
                return result
            }

            let elapsed = DispatchTime.now().uptimeNanoseconds - startTime.uptimeNanoseconds
            if elapsed > timeout {
                NSLog("[ChatService] Transaction resolution timeout for %@", String(txId.prefix(12)))
                restTask.cancel()
                return nil
            }

            try? await Task.sleep(nanoseconds: 50_000_000)  // Check every 50ms
        }
    }

    private func fetchKaspaFullTransaction(
        txId: String,
        retries: Int,
        delayNs: UInt64
    ) async -> KaspaFullTransactionResponse? {
        guard let url = kaspaRestURL(
            path: "/transactions/\(txId)",
            queryItems: [URLQueryItem(name: "resolve_previous_outpoints", value: "light")]
        ) else { return nil }
        NSLog("[ChatService] Kaspa REST full tx request: %@", url.absoluteString)

        for attempt in 1...max(1, retries) {
            do {
                let (data, response) = try await URLSession.shared.data(from: url)
                guard let httpResponse = response as? HTTPURLResponse,
                      (200...299).contains(httpResponse.statusCode) else {
                    try? await Task.sleep(nanoseconds: delayNs)
                    continue
                }
                let fullTx = try JSONDecoder().decode(KaspaFullTransactionResponse.self, from: data)
                NSLog("[ChatService] Kaspa REST full tx resolved for %@ on attempt %d",
                      String(txId.prefix(12)), attempt)
                return fullTx
            } catch {
                try? await Task.sleep(nanoseconds: delayNs)
            }
        }

        return nil
    }

    private func deriveSenderFromFullTx(_ fullTx: KaspaFullTransactionResponse, excluding address: String) -> String? {
        if let inputs = fullTx.inputs {
            for input in inputs {
                if let inputAddr = input.previousOutpointAddress, !inputAddr.isEmpty, inputAddr != address {
                    return inputAddr
                }
            }
        }
        return nil
    }

    /// Fetch any input address from a transaction (fallback when normal resolution fails)
    /// This tries the REST API without retries, just to get ANY input address
    private func fetchAnyInputAddress(txId: String, excludeAddress: String) async -> String? {
        guard let url = kaspaRestURL(
            path: "/transactions/\(txId)",
            queryItems: [URLQueryItem(name: "resolve_previous_outpoints", value: "light")]
        ) else { return nil }

        do {
            NSLog("[ChatService] Kaspa REST fetchAnyInputAddress: %@", url.absoluteString)
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                return nil
            }

            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let inputs = json["inputs"] as? [[String: Any]] else {
                return nil
            }

            // Get any input address that's not our own
            for input in inputs {
                if let addr = input["previous_outpoint_address"] as? String,
                   !addr.isEmpty,
                   addr != excludeAddress {
                    return addr
                }
            }
            return nil
        } catch {
            NSLog("[ChatService] fetchAnyInputAddress failed for %@: %@", String(txId.prefix(16)), error.localizedDescription)
            return nil
        }
    }

    private func fetchSavedHandshakes(myAddress: String, privateKey: Data?) async throws {
        guard let privKey = privateKey else {
            NSLog("[ChatService] Cannot fetch saved handshakes - no private key")
            return
        }

        let savedHandshakes: [SelfStashResponse]
        do {
            savedHandshakes = try await apiClient.getSelfStash(owner: myAddress, scope: "saved_handshake")
        } catch {
            if ChatService.handleDpiPaginationFailure(error, context: "saved handshakes") {
                return
            }
            throw error
        }
        NSLog("[ChatService] Fetched %d saved handshakes from self-stash", savedHandshakes.count)

        for stash in savedHandshakes {
            guard let stashedData = stash.stashedData else { continue }
            // Decrypt the stashed data on background thread to get our alias and contact info
            if let savedData = await decryptSelfStash(stashedData, privateKey: privKey) {
                let contact = savedData.contactAddress
                let alias = savedData.ourAlias
                if !contact.isEmpty && !alias.isEmpty {
                    NSLog("[ChatService] Saved handshake: contact=%@, ourAlias=%@, theirAlias=%@",
                          String(contact.suffix(10)), alias, savedData.theirAlias ?? "nil")
                    addOurAlias(alias, for: contact, blockTime: stash.blockTime)
                    if let theirAlias = savedData.theirAlias, !theirAlias.isEmpty {
                        addConversationAlias(theirAlias, for: contact, blockTime: stash.blockTime)
                    }
                    // Also derive and store deterministic routing state from partner address
                    ensureRoutingState(for: contact, privateKey: privKey)
                } else if !contact.isEmpty {
                    // Even if legacy alias is empty, derive deterministic from address
                    ensureRoutingState(for: contact, privateKey: privKey)
                } else {
                    NSLog("[ChatService] Saved handshake missing contact or alias")
                }
            }
        }
    }

    private func retryUntilSuccess<T>(
        label: String,
        initialDelayNs: UInt64 = 1_000_000_000,
        maxDelayNs: UInt64 = 15_000_000_000,
        operation: @escaping () async throws -> T
    ) async -> T? {
        var attempt = 0
        var delay = initialDelayNs

        while !Task.isCancelled {
            do {
                return try await operation()
            } catch {
                attempt += 1
                let delaySeconds = Double(delay) / 1_000_000_000.0
                NSLog("[ChatService] %@ failed (attempt %d): %@. Retrying in %.1fs",
                      label, attempt, error.localizedDescription, delaySeconds)
                try? await Task.sleep(nanoseconds: delay)
                delay = min(delay * 2, maxDelayNs)
            }
        }

        NSLog("[ChatService] %@ cancelled", label)
        return nil
    }

    private static func handleDpiPaginationFailure(_ error: Error, context: String) -> Bool {
        if case KasiaAPIClientError.dpiPaginationExhausted(let endpoint) = error {
            NSLog("[ChatService] DPI pagination exhausted for %@ (%@)", endpoint, context)
            MessageStore.shared.markDpiCorruptionWarning(endpoint: endpoint)
            return true
        }
        return false
    }

    private func beginChatFetch(_ address: String) {
        let count = (chatFetchCounts[address] ?? 0) + 1
        chatFetchCounts[address] = count
        if count == 1 {
            chatFetchFailed.remove(address)
        }
    }

    private func markChatFetchLoading(_ address: String) {
        // Show spinner only when there is actual payload work to parse/add.
        if chatFetchCounts[address] != nil {
            chatFetchStates[address] = .loading
        }
    }

    private func endChatFetch(_ address: String, success: Bool) {
        if !success {
            chatFetchFailed.insert(address)
        }
        let nextCount = (chatFetchCounts[address] ?? 1) - 1
        if nextCount <= 0 {
            chatFetchCounts.removeValue(forKey: address)
            if chatFetchFailed.contains(address) {
                chatFetchStates[address] = .failed
            } else {
                chatFetchStates.removeValue(forKey: address)
            }
        } else {
            chatFetchCounts[address] = nextCount
        }
    }

    private func fetchContextualMessages(
        myAddress: String,
        privateKey: Data?,
        fallbackSince: UInt64,
        nowMs: UInt64
    ) async -> Bool {
        let archivedAddresses = Set(contactsManager.archivedContacts.map { $0.address })
        // Build contact set from routing states (preferred) + legacy aliases (fallback)
        let allContactAddresses = Set(routingStates.keys).union(conversationAliases.keys)
        print("[ChatService] Fetching contextual messages for \(allContactAddresses.count) contacts")

        // Fetch INCOMING messages (from contacts to us)
        for contactAddress in allContactAddresses {
            guard !archivedAddresses.contains(contactAddress) else { continue }
            let aliases = incomingAliases(for: contactAddress)
            guard !aliases.isEmpty else { continue }
            beginChatFetch(contactAddress)
            var contactSuccess = true
            defer { endChatFetch(contactAddress, success: contactSuccess) }
            for alias in aliases {
                let syncObjectKey = contextualSyncObjectKey(
                    direction: "in",
                    queryAddress: contactAddress,
                    alias: alias,
                    contactAddress: contactAddress
                )
                let startBlockTime = syncStartBlockTime(
                    for: syncObjectKey,
                    fallbackBlockTime: fallbackSince,
                    nowMs: nowMs
                )
                let effectiveSince = applyMessageRetention(to: startBlockTime)
                let fetchKey = contextualFetchKey(address: contactAddress, alias: alias, limit: 50, since: effectiveSince)
                guard beginContextualFetch(fetchKey) else {
                    NSLog("[ChatService] Contextual fetch in-flight, skipping incoming %@",
                          String(contactAddress.suffix(10)))
                    continue
                }
                defer { endContextualFetch(fetchKey) }
                guard let messages = await retryUntilSuccess(
                    label: "fetch incoming contextual messages from \(contactAddress.suffix(10))",
                    operation: { [apiClient] in
                        do {
                            return try await apiClient.getContextualMessagesBySender(
                                address: contactAddress,
                                alias: alias,
                                limit: 50,
                                blockTime: effectiveSince
                            )
                        } catch {
                            if ChatService.handleDpiPaginationFailure(error, context: "incoming contextual messages") {
                                return []
                            }
                            throw error
                        }
                    }
                ) else {
                    contactSuccess = false
                    return false
                }
                advanceSyncCursor(for: syncObjectKey, maxBlockTime: messages.compactMap { $0.blockTime }.max())

                if !messages.isEmpty {
                    markChatFetchLoading(contactAddress)
                }
                print("[ChatService] Got \(messages.count) incoming contextual messages from \(contactAddress)")

                for contextMsg in messages {
                    var content = "[Encrypted message]"
                    if let privKey = privateKey {
                        // Decrypt on background thread to avoid blocking UI
                        if let decrypted = await decryptContextualMessage(contextMsg.messagePayload, privateKey: privKey) {
                            content = decrypted
                        }
                    }
                    let msgType = messageType(for: content)

                    let message = ChatMessage(
                        txId: contextMsg.txId,
                        senderAddress: contextMsg.sender,
                        receiverAddress: myAddress,
                        content: content,
                        timestamp: Date(timeIntervalSince1970: TimeInterval((contextMsg.blockTime ?? 0) / 1000)),
                        blockTime: contextMsg.blockTime ?? 0,
                        acceptingBlock: contextMsg.acceptingBlock,
                        isOutgoing: false,
                        messageType: msgType
                    )

                    addMessageToConversation(message, contactAddress: contactAddress)

                    // Capability detection: if message arrived on deterministic alias, mark peer
                    if let state = routingStates[contactAddress], alias == state.deterministicMyAlias {
                        if !state.peerSupportsDeterministic {
                            routingStates[contactAddress]?.peerSupportsDeterministic = true
                        }
                        routingStates[contactAddress]?.lastDeterministicIncomingAtMs = contextMsg.blockTime
                    }

                    if let blockTime = contextMsg.blockTime, blockTime > lastPollTime {
                        updateLastPollTime(blockTime)
                    }
                }
            }
        }

        // Fetch OUTGOING messages (from us to contacts)
        let allOutgoingAddresses = Set(routingStates.keys).union(ourAliases.keys)
        for contactAddress in allOutgoingAddresses {
            guard !archivedAddresses.contains(contactAddress) else { continue }
            let aliasSet = outgoingFetchAliases(for: contactAddress)
            guard !aliasSet.isEmpty else { continue }
            beginChatFetch(contactAddress)
            var contactSuccess = true
            defer { endChatFetch(contactAddress, success: contactSuccess) }
            for ourAlias in aliasSet {
                let syncObjectKey = contextualSyncObjectKey(
                    direction: "out",
                    queryAddress: myAddress,
                    alias: ourAlias,
                    contactAddress: contactAddress
                )
                let startBlockTime = syncStartBlockTime(
                    for: syncObjectKey,
                    fallbackBlockTime: fallbackSince,
                    nowMs: nowMs
                )
                let effectiveSince = applyMessageRetention(to: startBlockTime)
                let fetchKey = contextualFetchKey(address: myAddress, alias: ourAlias, limit: 50, since: effectiveSince)
                guard beginContextualFetch(fetchKey) else {
                    NSLog("[ChatService] Contextual fetch in-flight, skipping outgoing %@",
                          String(contactAddress.suffix(10)))
                    continue
                }
                defer { endContextualFetch(fetchKey) }
                guard let messages = await retryUntilSuccess(
                    label: "fetch outgoing contextual messages to \(contactAddress.suffix(10))",
                    operation: { [apiClient] in
                        do {
                            return try await apiClient.getContextualMessagesBySender(
                                address: myAddress,
                                alias: ourAlias,
                                limit: 50,
                                blockTime: effectiveSince
                            )
                        } catch {
                            if ChatService.handleDpiPaginationFailure(error, context: "outgoing contextual messages") {
                                return []
                            }
                            throw error
                        }
                    }
            ) else {
                contactSuccess = false
                return false
            }
                advanceSyncCursor(for: syncObjectKey, maxBlockTime: messages.compactMap { $0.blockTime }.max())

                if !messages.isEmpty {
                    markChatFetchLoading(contactAddress)
                }
                let sortedMessages = messages.sorted {
                    let lhsTime = $0.blockTime ?? 0
                    let rhsTime = $1.blockTime ?? 0
                    if lhsTime == rhsTime {
                        return $0.txId < $1.txId
                    }
                    return lhsTime < rhsTime
                }

                print("[ChatService] Got \(sortedMessages.count) outgoing contextual messages to \(contactAddress)")

                for contextMsg in sortedMessages {
                    // Outgoing messages are encrypted for the recipient, we can't decrypt them
                    // Check if we have this message stored locally with content
                    let existingMessage = findLocalMessage(txId: contextMsg.txId)
                    let content = existingMessage?.content ?? "ðŸ“¤ Sent via another device"
                    let msgType = existingMessage?.messageType ?? messageType(for: content)

                    let message = ChatMessage(
                        txId: contextMsg.txId,
                        senderAddress: myAddress,
                        receiverAddress: contactAddress,
                        content: content,
                        timestamp: Date(timeIntervalSince1970: TimeInterval((contextMsg.blockTime ?? 0) / 1000)),
                        blockTime: contextMsg.blockTime ?? 0,
                        acceptingBlock: contextMsg.acceptingBlock,
                        isOutgoing: true,
                        messageType: msgType
                    )

                    addMessageToConversation(message, contactAddress: contactAddress)
                    if let blockTime = contextMsg.blockTime, blockTime > lastPollTime {
                        updateLastPollTime(blockTime)
                    }
                }
            }
        }

        return true
    }

    private func fetchContextualMessagesForActive(
        contactAddress: String,
        myAddress: String,
        privateKey: Data?,
        fallbackSince: UInt64,
        nowMs: UInt64,
        forceExactBlockTime: Bool = false
    ) async -> Bool {
        if contactsManager.getContact(byAddress: contactAddress)?.isArchived == true {
            return true
        }
        beginChatFetch(contactAddress)
        var contactSuccess = true
        defer { endChatFetch(contactAddress, success: contactSuccess) }
        // Incoming from contact (use routing state aliases + legacy fallback)
        let inAliases = incomingAliases(for: contactAddress)
        if !inAliases.isEmpty {
            for alias in inAliases {
                let syncObjectKey = contextualSyncObjectKey(
                    direction: "in",
                    queryAddress: contactAddress,
                    alias: alias,
                    contactAddress: contactAddress
                )
                let startBlockTime: UInt64
                if forceExactBlockTime {
                    startBlockTime = fallbackSince
                } else {
                    startBlockTime = syncStartBlockTime(
                        for: syncObjectKey,
                        fallbackBlockTime: fallbackSince,
                        nowMs: nowMs
                    )
                }
                let effectiveSince = forceExactBlockTime ? startBlockTime : applyMessageRetention(to: startBlockTime)
                let fetchKey = contextualFetchKey(address: contactAddress, alias: alias, limit: 50, since: effectiveSince)
                guard beginContextualFetch(fetchKey) else {
                    NSLog("[ChatService] Contextual fetch in-flight, skipping active incoming %@",
                          String(contactAddress.suffix(10)))
                    continue
                }
                defer { endContextualFetch(fetchKey) }
                guard let messages = await retryUntilSuccess(
                    label: "fetch incoming contextual messages (active) from \(contactAddress.suffix(10))",
                    operation: { [apiClient] in
                        do {
                            return try await apiClient.getContextualMessagesBySender(
                                address: contactAddress,
                                alias: alias,
                                limit: 50,
                                blockTime: effectiveSince
                            )
                        } catch {
                            if ChatService.handleDpiPaginationFailure(error, context: "active incoming contextual messages") {
                                return []
                            }
                            throw error
                        }
                    }
            ) else {
                contactSuccess = false
                return false
                }
                if !forceExactBlockTime {
                    advanceSyncCursor(for: syncObjectKey, maxBlockTime: messages.compactMap { $0.blockTime }.max())
                }

                if !messages.isEmpty {
                    markChatFetchLoading(contactAddress)
                }
                for contextMsg in messages {
                    var content = "[Encrypted message]"
                    if let privKey = privateKey {
                        // Decrypt on background thread to avoid blocking UI
                        if let decrypted = await decryptContextualMessage(contextMsg.messagePayload, privateKey: privKey) {
                            content = decrypted
                        }
                    }

                    let message = ChatMessage(
                        txId: contextMsg.txId,
                        senderAddress: contextMsg.sender,
                        receiverAddress: myAddress,
                        content: content,
                        timestamp: Date(timeIntervalSince1970: TimeInterval((contextMsg.blockTime ?? 0) / 1000)),
                        blockTime: contextMsg.blockTime ?? 0,
                        acceptingBlock: contextMsg.acceptingBlock,
                        isOutgoing: false,
                        messageType: .contextual
                    )

                    addMessageToConversation(message, contactAddress: contactAddress)

                    // Capability detection: if message arrived on deterministic alias, mark peer
                    if let state = routingStates[contactAddress], alias == state.deterministicMyAlias {
                        if !state.peerSupportsDeterministic {
                            routingStates[contactAddress]?.peerSupportsDeterministic = true
                        }
                        routingStates[contactAddress]?.lastDeterministicIncomingAtMs = contextMsg.blockTime
                    }

                    if let blockTime = contextMsg.blockTime, blockTime > lastPollTime {
                        updateLastPollTime(blockTime)
                    }
                }
            }
        }

        // Outgoing from us (use routing state aliases + legacy fallback)
        let outAliases = outgoingFetchAliases(for: contactAddress)
        if !outAliases.isEmpty {
            for ourAlias in outAliases {
                let syncObjectKey = contextualSyncObjectKey(
                    direction: "out",
                    queryAddress: myAddress,
                    alias: ourAlias,
                    contactAddress: contactAddress
                )
                let startBlockTime: UInt64
                if forceExactBlockTime {
                    startBlockTime = fallbackSince
                } else {
                    startBlockTime = syncStartBlockTime(
                        for: syncObjectKey,
                        fallbackBlockTime: fallbackSince,
                        nowMs: nowMs
                    )
                }
                let effectiveSince = forceExactBlockTime ? startBlockTime : applyMessageRetention(to: startBlockTime)
                let fetchKey = contextualFetchKey(address: myAddress, alias: ourAlias, limit: 50, since: effectiveSince)
                guard beginContextualFetch(fetchKey) else {
                    NSLog("[ChatService] Contextual fetch in-flight, skipping active outgoing %@",
                          String(contactAddress.suffix(10)))
                    continue
                }
                defer { endContextualFetch(fetchKey) }
                guard let messages = await retryUntilSuccess(
                    label: "fetch outgoing contextual messages (active) to \(contactAddress.suffix(10))",
                    operation: { [apiClient] in
                        do {
                            return try await apiClient.getContextualMessagesBySender(
                                address: myAddress,
                                alias: ourAlias,
                                limit: 50,
                                blockTime: effectiveSince
                            )
                        } catch {
                            if ChatService.handleDpiPaginationFailure(error, context: "active outgoing contextual messages") {
                                return []
                            }
                            throw error
                        }
                    }
            ) else {
                contactSuccess = false
                return false
                }
                if !forceExactBlockTime {
                    advanceSyncCursor(for: syncObjectKey, maxBlockTime: messages.compactMap { $0.blockTime }.max())
                }

                if !messages.isEmpty {
                    markChatFetchLoading(contactAddress)
                }
                let sortedMessages = messages.sorted {
                    let lhsTime = $0.blockTime ?? 0
                    let rhsTime = $1.blockTime ?? 0
                    if lhsTime == rhsTime {
                        return $0.txId < $1.txId
                    }
                    return lhsTime < rhsTime
                }

                for contextMsg in sortedMessages {
                    let existingMessage = findLocalMessage(txId: contextMsg.txId)
                    let content = existingMessage?.content ?? "ðŸ“¤ Sent via another device"

                    let message = ChatMessage(
                        txId: contextMsg.txId,
                        senderAddress: myAddress,
                        receiverAddress: contactAddress,
                        content: content,
                        timestamp: Date(timeIntervalSince1970: TimeInterval((contextMsg.blockTime ?? 0) / 1000)),
                        blockTime: contextMsg.blockTime ?? 0,
                        acceptingBlock: contextMsg.acceptingBlock,
                        isOutgoing: true,
                        messageType: .contextual
                    )

                    addMessageToConversation(message, contactAddress: contactAddress)
                    if let blockTime = contextMsg.blockTime, blockTime > lastPollTime {
                        updateLastPollTime(blockTime)
                    }
                }
            }
        }

        return true
    }

    /// Fetch contextual messages with polling (triggered by UTXO notification)
    /// Algorithm: wait 1500ms initial delay, then poll every 500ms until we get new messages (max 10 attempts)
    private func fetchContextualMessagesFromContactWithRetry(contactAddress: String, myAddress: String, privateKey: Data) async {
        // Initial delay to give indexer time to process
        try? await Task.sleep(nanoseconds: 1_500_000_000)  // 1500ms

        let maxAttempts = 20
        let pollIntervalNs: UInt64 = 500_000_000  // 500ms

        beginChatFetch(contactAddress)
        var completedSuccessfully = false
        defer {
            endChatFetch(contactAddress, success: completedSuccessfully)
        }
        for attempt in 1...maxAttempts {
            let result = await fetchContextualMessagesFromContact(
                contactAddress: contactAddress,
                myAddress: myAddress,
                privateKey: privateKey
            )

            switch result {
            case .success(let added):
                if added, attempt > 1 {
                    NSLog("[ChatService] Found messages from %@ on attempt %d", String(contactAddress.suffix(10)), attempt)
                }
                completedSuccessfully = true
                return
            case .failure:
                break
            }

            if attempt < maxAttempts {
                try? await Task.sleep(nanoseconds: pollIntervalNs)
            }
        }

        NSLog("[ChatService] No new messages from %@ after %d attempts", String(contactAddress.suffix(10)), maxAttempts)
    }

    /// Fetch contextual messages from a specific contact (triggered by UTXO notification)
    /// Returns true if any new messages were added
    @discardableResult
    private func fetchContextualMessagesFromContact(contactAddress: String, myAddress: String, privateKey: Data) async -> ContactFetchResult {
        // Get incoming aliases for this contact (deterministic + legacy)
        let aliases = incomingAliases(for: contactAddress)
        guard !aliases.isEmpty else {
            NSLog("[ChatService] No alias for contact %@, cannot fetch contextual messages", String(contactAddress.suffix(10)))
            return .success(added: false)
        }
        let nowMs = currentTimeMs()
        let fallbackSince = lastPollTime > syncReorgBufferMs ? lastPollTime - syncReorgBufferMs : lastPollTime

        var newMessagesAdded = false

        do {
            for alias in aliases {
                let syncObjectKey = contextualSyncObjectKey(
                    direction: "in",
                    queryAddress: contactAddress,
                    alias: alias,
                    contactAddress: contactAddress
                )
                let startBlockTime = syncStartBlockTime(
                    for: syncObjectKey,
                    fallbackBlockTime: fallbackSince,
                    nowMs: nowMs
                )
                let effectiveSince = applyMessageRetention(to: startBlockTime)
                let fetchKey = contextualFetchKey(address: contactAddress, alias: alias, limit: 10, since: effectiveSince)
                guard beginContextualFetch(fetchKey) else {
                    NSLog("[ChatService] Contextual fetch in-flight, skipping contact %@",
                          String(contactAddress.suffix(10)))
                    continue
                }
                defer { endContextualFetch(fetchKey) }

                // Fetch recent messages from this contact
                let messages = try await apiClient.getContextualMessagesBySender(
                    address: contactAddress,
                    alias: alias,
                    limit: 10,  // Only fetch recent messages
                    blockTime: effectiveSince
                )
                advanceSyncCursor(for: syncObjectKey, maxBlockTime: messages.compactMap { $0.blockTime }.max())

                if !messages.isEmpty {
                    markChatFetchLoading(contactAddress)
                }
                for contextMsg in messages {
                    // Skip if already have this message
                    if findLocalMessage(txId: contextMsg.txId) != nil {
                        continue
                    }

                    var content = "[Encrypted message]"
                    if let decrypted = await decryptContextualMessage(contextMsg.messagePayload, privateKey: privateKey) {
                        content = decrypted
                    }

                    let message = ChatMessage(
                        txId: contextMsg.txId,
                        senderAddress: contextMsg.sender,
                        receiverAddress: myAddress,
                        content: content,
                        timestamp: Date(timeIntervalSince1970: TimeInterval((contextMsg.blockTime ?? 0) / 1000)),
                        blockTime: contextMsg.blockTime ?? 0,
                        acceptingBlock: contextMsg.acceptingBlock,
                        isOutgoing: false,
                        messageType: .contextual
                    )

                    addMessageToConversation(message, contactAddress: contactAddress)
                    newMessagesAdded = true

                    // Capability detection
                    if let state = routingStates[contactAddress], alias == state.deterministicMyAlias {
                        if !state.peerSupportsDeterministic {
                            routingStates[contactAddress]?.peerSupportsDeterministic = true
                        }
                        routingStates[contactAddress]?.lastDeterministicIncomingAtMs = contextMsg.blockTime
                    }

                    if let blockTime = contextMsg.blockTime, blockTime > lastPollTime {
                        updateLastPollTime(blockTime)
                    }
                }
            }

            if newMessagesAdded {
                saveMessages()
                NSLog("[ChatService] New contextual messages added from contact %@", String(contactAddress.suffix(10)))
            }

            return .success(added: newMessagesAdded)

        } catch {
            if ChatService.handleDpiPaginationFailure(error, context: "contact contextual messages") {
                return .failure
            }
            NSLog("[ChatService] Failed to fetch contextual messages from contact %@: %@",
                  String(contactAddress.suffix(10)), error.localizedDescription)
            return .failure
        }
    }

    private func contextualFetchKey(address: String, alias: String, limit: Int, since: UInt64) -> String {
        "\(address)|\(alias)|\(limit)|\(since)"
    }

    private func beginContextualFetch(_ key: String) -> Bool {
        if contextualFetchInFlight.contains(key) {
            return false
        }
        contextualFetchInFlight.insert(key)
        return true
    }

    private func endContextualFetch(_ key: String) {
        contextualFetchInFlight.remove(key)
    }

    private func processPayments(
        _ payments: [PaymentResponse],
        isOutgoing: Bool,
        myAddress: String,
        privateKey: Data? = nil,
        deliveryStatus: ChatMessage.DeliveryStatus = .sent
    ) async {
        let direction = isOutgoing ? "outgoing" : "incoming"
        NSLog("[ChatService] === PROCESSING %d %@ PAYMENTS ===", payments.count, direction)
        let hideAutoCreatedPaymentChats = SettingsViewModel.loadSettings().hideAutoCreatedPaymentChats

        var needsFullSync = false

        for payment in payments {
            if !isOutgoing, let amount = payment.amount, amount > 0 {
                incomingResolutionAmountHints[payment.txId] = amount
            }

            // Determine contact address
            var contactAddress: String
            if isOutgoing {
                contactAddress = payment.receiver
            } else {
                // For incoming payments, sender might need resolution
                if payment.sender == "pending_resolution" || payment.sender.isEmpty || !isValidKaspaAddress(payment.sender) {
                    // Try one more resolution attempt (in case API is now available)
                    if let resolved = await resolveSenderAddress(
                        sender: "",
                        txId: payment.txId,
                        receiver: myAddress
                    ) {
                        contactAddress = resolved
                        print("[ChatService] Resolved sender for \(payment.txId.prefix(16))...: \(contactAddress.suffix(10))")
                    } else {
                        // Still couldn't resolve - try to get any input address from the transaction
                        // as a temporary solution, then schedule full sync for proper resolution
                        if let tempSender = await fetchAnyInputAddress(txId: payment.txId, excludeAddress: myAddress) {
                            contactAddress = tempSender
                            NSLog("[ChatService] Using temporary sender for %@: %@", String(payment.txId.prefix(16)), String(tempSender.suffix(20)))
                            needsFullSync = true
                        } else {
                            NSLog("[ChatService] Sender completely unresolved for %@, scheduling full sync", String(payment.txId.prefix(16)))
                            needsFullSync = true
                            continue
                        }
                    }
                } else {
                    contactAddress = payment.sender
                }
            }

            // Skip if we couldn't determine the contact address
            NSLog("[ChatService] Payment %@ - contactAddress: %@, myAddress: %@, match: %d",
                  String(payment.txId.prefix(16)),
                  String(contactAddress.suffix(20)),
                  String(myAddress.suffix(20)),
                  contactAddress == myAddress ? 1 : 0)

            if !isOutgoing, let existing = findLocalMessage(txId: payment.txId) {
                if existing.isOutgoing {
                    NSLog("[ChatService] Replacing outgoing message for %@ with incoming payment",
                          String(payment.txId.prefix(16)))
                    removeMessage(txId: payment.txId)
                } else {
                    let shouldPromoteStatus = deliveryStatus.priority > existing.deliveryStatus.priority
                    let shouldKeepPending = incomingResolutionPendingTxIds.contains(payment.txId) && deliveryStatus == .sent
                    if shouldPromoteStatus && !shouldKeepPending {
                        if updateIncomingPaymentStatus(txId: payment.txId, deliveryStatus: deliveryStatus, content: paymentContent(payment, isOutgoing: isOutgoing)) {
                            saveMessages()
                        }
                        if deliveryStatus == .sent {
                            clearIncomingResolutionTracking(txId: payment.txId)
                        } else if deliveryStatus == .warning {
                            incomingResolutionWarningTxIds.insert(payment.txId)
                        }
                        continue
                    }
                    // Incoming already present.
                    continue
                }
            }

            if contactAddress.isEmpty || contactAddress == myAddress {
                NSLog("[ChatService] Skipping payment %@ - self-address detected", String(payment.txId.prefix(16)))
                continue
            }

            // Skip if this transaction already exists as a handshake message
            if let existingMsg = findLocalMessage(txId: payment.txId), existingMsg.messageType == .handshake {
                NSLog("[ChatService] Skipping payment %@ - already exists as handshake", String(payment.txId.prefix(16)))
                continue
            }

            // Check if this payment is actually a handshake (REST API payload detection)
            if let payload = payment.messagePayload, !payload.isEmpty, isHandshakePayload(payload) {
                NSLog("[ChatService] Payment %@ has handshake payload - processing as handshake", String(payment.txId.prefix(16)))
                var handshakeContent = "[Handshake]"
                if !isOutgoing, let privKey = privateKey {
                    // For incoming handshakes, decrypt to extract alias
                    if let decrypted = await decryptHandshakePayload(payload, privateKey: privKey) {
                        handshakeContent = "[Request to communicate]"
                        if let alias = decrypted.alias {
                            addConversationAlias(alias, for: contactAddress, blockTime: payment.blockTime)
                            NSLog("[ChatService] Extracted alias '%@' from payment-handshake by %@", alias, String(contactAddress.suffix(10)))
                        } else {
                            NSLog("[ChatService] Received deterministic (alias-less) payment-handshake from %@", String(contactAddress.suffix(10)))
                        }
                        if let convId = decrypted.conversationId {
                            conversationIds[contactAddress] = convId
                        }
                    }
                } else {
                    handshakeContent = "[Handshake sent]"
                }
                let handshakeMsg = ChatMessage(
                    txId: payment.txId,
                    senderAddress: isOutgoing ? payment.sender : contactAddress,
                    receiverAddress: payment.receiver,
                    content: handshakeContent,
                    timestamp: Date(timeIntervalSince1970: TimeInterval((payment.blockTime ?? 0) / 1000)),
                    blockTime: payment.blockTime ?? 0,
                    acceptingBlock: payment.acceptingBlock,
                    isOutgoing: isOutgoing,
                    messageType: .handshake
                )
                addMessageToConversation(handshakeMsg, contactAddress: contactAddress)
                if let blockTime = payment.blockTime, blockTime > lastPollTime {
                    updateLastPollTime(blockTime)
                }
                continue
            }

            if let payload = payment.messagePayload, !payload.isEmpty {
                if isContextualPayload(payload) {
                    NSLog("[ChatService] Payment %@ has contextual payload - skipping as payment", String(payment.txId.prefix(16)))
                    if let privateKey,
                       shouldAttemptSelfStashDecryption(payloadHex: payload, contactAddress: contactAddress),
                       let decrypted = await decryptContextualMessageFromRawPayload(payload, privateKey: privateKey) {
                        let message = ChatMessage(
                            txId: payment.txId,
                            senderAddress: isOutgoing ? payment.sender : contactAddress,
                            receiverAddress: payment.receiver,
                            content: decrypted,
                            timestamp: Date(timeIntervalSince1970: TimeInterval((payment.blockTime ?? 0) / 1000)),
                            blockTime: payment.blockTime ?? 0,
                            acceptingBlock: payment.acceptingBlock,
                            isOutgoing: isOutgoing,
                            messageType: messageType(for: decrypted)
                        )
                        addMessageToConversation(message, contactAddress: contactAddress)
                        if let blockTime = payment.blockTime, blockTime > lastPollTime {
                            updateLastPollTime(blockTime)
                        }
                    }
                    continue
                }

                if isSelfStashPayload(payload) {
                    NSLog("[ChatService] Payment %@ has self-stash payload - skipping", String(payment.txId.prefix(16)))
                    continue
                }
            }

            let existingContact = contactsManager.getContact(byAddress: contactAddress)
            let hasExistingConversation = conversations.contains { $0.contact.address == contactAddress }
            if hideAutoCreatedPaymentChats && existingContact == nil && !hasExistingConversation {
                NSLog("[ChatService] Skipping payment %@ - auto-created payment chats disabled for %@",
                      String(payment.txId.prefix(16)),
                      String(contactAddress.suffix(20)))
                if let blockTime = payment.blockTime, blockTime > lastPollTime {
                    updateLastPollTime(blockTime)
                }
                continue
            }

            // Decode payment message
            let content = paymentContent(payment, isOutgoing: isOutgoing)

            // Use resolved sender for incoming payments
            let resolvedSender = isOutgoing ? payment.sender : contactAddress

            if isOutgoing,
               updateOutgoingPendingMessageIfMatch(
                contactAddress: contactAddress,
                newTxId: payment.txId,
                content: content,
                messageType: .payment
               ) {
                saveMessages()
                if let blockTime = payment.blockTime, blockTime > lastPollTime {
                    updateLastPollTime(blockTime)
                }
                continue
            }

            let message = ChatMessage(
                txId: payment.txId,
                senderAddress: resolvedSender,
                receiverAddress: payment.receiver,
                content: content,
                timestamp: Date(timeIntervalSince1970: TimeInterval((payment.blockTime ?? 0) / 1000)),
                blockTime: payment.blockTime ?? 0,
                acceptingBlock: payment.acceptingBlock,
                isOutgoing: isOutgoing,
                messageType: .payment,
                deliveryStatus: deliveryStatus
            )

            addMessageToConversation(message, contactAddress: contactAddress)

            if !isOutgoing {
                if deliveryStatus == .sent {
                    clearIncomingResolutionTracking(txId: payment.txId)
                } else if deliveryStatus == .warning {
                    incomingResolutionWarningTxIds.insert(payment.txId)
                } else if deliveryStatus == .pending {
                    incomingResolutionPendingTxIds.insert(payment.txId)
                }
            }

            // Update last poll time
            if let blockTime = payment.blockTime, blockTime > lastPollTime {
                updateLastPollTime(blockTime)
            }
        }

        // Trigger full sync if we have unresolved senders
        if needsFullSync {
            NSLog("[ChatService] Triggering full sync to resolve pending senders...")
            Task { @MainActor in
                // Small delay before full sync to let API propagate
                try? await Task.sleep(nanoseconds: 3_000_000_000)
                await self.fetchNewMessages(forActiveOnly: nil)  // nil triggers full fetch
            }
        }
    }

    /// Find a locally stored message by transaction ID
    private func findLocalMessage(txId: String) -> ChatMessage? {
        for conversation in conversations {
            if let message = conversation.messages.first(where: { $0.txId == txId }) {
                return message
            }
        }
        guard let key = messageEncryptionKey() else { return nil }
        return messageStore.fetchMessage(txId: txId, decryptionKey: key)
    }

    func hasLocalMessage(txId: String) -> Bool {
        return findLocalMessage(txId: txId) != nil
    }

    func addOutgoingMessageFromPush(
        txId: String,
        sender: String,
        payload: String?,
        timestamp: Int64
    ) async -> Bool {
        guard let privateKey = WalletManager.shared.getPrivateKey() else {
            NSLog("[ChatService] Outgoing push: missing private key")
            return false
        }

        // Check if message already exists with content (not placeholder)
        if let existingMsg = findLocalMessage(txId: txId),
           existingMsg.content != "ðŸ“¤ Sent via another device" {
            NSLog("[ChatService] Outgoing push already exists with content: %@", txId)
            return true
        }

        // PRIORITY 1: Try CloudKit sync first
        // Outgoing messages from other devices have their content stored in CloudKit
        // The on-chain payload is encrypted for the recipient, so we can't decrypt it here
        NSLog("[ChatService] Outgoing push from other device: %@ - trying CloudKit sync", txId)

        let settings = currentSettings
        if settings.storeMessagesInICloud {
            // Trigger CloudKit to fetch any pending changes
            await messageStore.waitForCloudKitSync(timeout: 5)

            // Reload messages from store (includes CloudKit-synced data)
            loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)

            // Brief pause for Core Data to merge
            try? await Task.sleep(nanoseconds: 500_000_000)

            // Check if CloudKit delivered the content
            if let cloudKitMsg = findLocalMessage(txId: txId),
               cloudKitMsg.content != "ðŸ“¤ Sent via another device" {
                NSLog("[ChatService] Outgoing push resolved via CloudKit: %@", txId)
                return true
            }

            NSLog("[ChatService] CloudKit sync did not deliver content for %@ - trying payload decrypt", txId)
        }

        // PRIORITY 2: Try to decrypt on-chain payload (may work for some message types)
        let rawPayload = await resolveRawPayloadForTx(txId: txId, payloadHint: payload)
        guard let rawPayload else {
            NSLog("[ChatService] Outgoing push: failed to resolve raw payload for %@", txId)
            // Schedule a retry - CloudKit may deliver later
            scheduleCloudKitRetryForOutgoing(txId: txId, sender: sender, timestamp: timestamp)
            return false
        }

        guard let payloadString = Self.hexStringToData(rawPayload)
            .flatMap({ String(data: $0, encoding: .utf8) }) else {
            NSLog("[ChatService] Outgoing push: invalid raw payload for %@", txId)
            return false
        }

        guard let alias = Self.extractContextualAlias(fromRawPayloadString: payloadString) else {
            NSLog("[ChatService] Outgoing push: alias not found for %@", txId)
            return false
        }

        guard let contactAddress = contactAddressForOutgoingAlias(alias) else {
            NSLog("[ChatService] Outgoing push: no contact for alias %@ (tx=%@)", alias, txId)
            return false
        }

        guard let decrypted = await decryptContextualMessageFromRawPayload(rawPayload, privateKey: privateKey) else {
            NSLog("[ChatService] Outgoing push: decrypt failed for %@ - content will sync via CloudKit", txId)
            // Create placeholder message - CloudKit will deliver actual content
            let placeholderMessage = ChatMessage(
                txId: txId,
                senderAddress: sender,
                receiverAddress: contactAddress,
                content: "ðŸ“¤ Sent via another device",
                timestamp: Date(timeIntervalSince1970: TimeInterval(timestamp) / 1000),
                blockTime: UInt64(timestamp),
                acceptingBlock: nil,
                isOutgoing: true,
                messageType: .contextual
            )
            addMessageToConversation(placeholderMessage, contactAddress: contactAddress)
            saveMessages()

            // Schedule CloudKit retry
            scheduleCloudKitRetryForOutgoing(txId: txId, sender: sender, timestamp: timestamp)
            return true  // Return true since we created a placeholder
        }

        let msgType = messageType(for: decrypted)
        if updateOutgoingPendingMessageIfMatch(
            contactAddress: contactAddress,
            newTxId: txId,
            content: decrypted,
            messageType: msgType
        ) {
            saveMessages(triggerExport: true)
            NSLog("[ChatService] Outgoing push updated pending message: %@ to %@", txId, String(contactAddress.suffix(10)))
            return true
        }

        let message = ChatMessage(
            txId: txId,
            senderAddress: sender,
            receiverAddress: contactAddress,
            content: decrypted,
            timestamp: Date(timeIntervalSince1970: TimeInterval(timestamp) / 1000),
            blockTime: UInt64(timestamp),
            acceptingBlock: nil,
            isOutgoing: true,
            messageType: msgType
        )

        addMessageToConversation(message, contactAddress: contactAddress)
        saveMessages(triggerExport: true)
        NSLog("[ChatService] Outgoing push imported: %@ to %@", txId, String(contactAddress.suffix(10)))
        return true
    }

    /// Schedule a CloudKit retry for outgoing messages that couldn't be resolved immediately
    private func scheduleCloudKitRetryForOutgoing(txId: String, sender: String, timestamp: Int64) {
        Task {
            // Wait 5 seconds for CloudKit to potentially deliver
            try? await Task.sleep(nanoseconds: 5_000_000_000)

            // Reload from store
            loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)

            // Check if content arrived
            if let msg = findLocalMessage(txId: txId),
               msg.content != "ðŸ“¤ Sent via another device" {
                NSLog("[ChatService] CloudKit retry successful for outgoing: %@", txId)
                return
            }

            // Try again after 15 seconds
            try? await Task.sleep(nanoseconds: 10_000_000_000)
            loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)

            if let msg = findLocalMessage(txId: txId),
               msg.content == "ðŸ“¤ Sent via another device" {
                NSLog("[ChatService] Outgoing message %@ still awaiting CloudKit sync", txId)
            }
        }
    }

    private func contactAddressForOutgoingAlias(_ alias: String) -> String? {
        for (address, aliases) in ourAliases where aliases.contains(alias) {
            return address
        }
        return nil
    }

    private func resolveRawPayloadForTx(txId: String, payloadHint: String?) async -> String? {
        if let payloadHint,
           let data = Data(base64Encoded: payloadHint),
           let raw = String(data: data, encoding: .utf8),
           raw.hasPrefix("ciph_msg:") {
            return raw.data(using: .utf8)?.hexString
        }

        if let payloadHint,
           let data = Data(hexString: payloadHint),
           let raw = String(data: data, encoding: .utf8),
           raw.hasPrefix("ciph_msg:") {
            return payloadHint
        }

        if let entry = await NodePoolService.shared.getMempoolEntry(txId: txId, attempt: 1),
           !entry.payload.isEmpty {
            return entry.payload
        }

        if let url = kaspaRestURL(
            path: "/transactions/\(txId)",
            queryItems: [URLQueryItem(name: "resolve_previous_outpoints", value: "light")]
        ),
           let (data, response) = try? await URLSession.shared.data(from: url),
           let httpResponse = response as? HTTPURLResponse,
           (200...299).contains(httpResponse.statusCode),
           let fullTx = try? JSONDecoder().decode(KaspaFullTransactionResponse.self, from: data),
           let payload = fullTx.payload,
           !payload.isEmpty {
            return payload
        }

        return nil
    }

    private func addMessageToConversation(_ message: ChatMessage, contactAddress: String) {
        if let existing = contactsManager.getContact(byAddress: contactAddress), existing.isArchived {
            return
        }
        let contact = contactsManager.getOrCreateContact(address: contactAddress)
        var isNewMessage = false
        var isNewConversation = false

        if message.isOutgoing && message.deliveryStatus == .sent {
            if updateOutgoingPendingMessageIfMatch(
                contactAddress: contactAddress,
                newTxId: message.txId,
                content: message.content,
                messageType: message.messageType
            ) {
                return
            }
            if updatePendingFromQueue(
                contactAddress: contactAddress,
                newTxId: message.txId,
                messageType: message.messageType
            ) {
                return
            }
            if updateOldestPendingOutgoingMessage(
                contactAddress: contactAddress,
                newTxId: message.txId,
                messageType: message.messageType
            ) {
                return
            }
        }

        let isUserViewing = activeConversationAddress == contactAddress &&
            UIApplication.shared.applicationState == .active

        if let index = conversations.firstIndex(where: { $0.contact.address == contactAddress }) {
            updateConversation(at: index) { conversation in
                if !conversation.messages.contains(where: { $0.txId == message.txId }) {
                    conversation.messages.append(message)
                    isNewMessage = true
                    if !message.isOutgoing {
                        if isUserViewing {
                            conversation.unreadCount = 0
                        } else {
                            conversation.unreadCount += 1
                        }
                    }
                }
            }
            // Mark for batched save if sync in progress
            if isSyncInProgress && isNewMessage {
                needsMessageStoreSyncAfterBatch = true
            }
        } else {
            var conversation = Conversation(contact: contact, messages: [message])
            isNewMessage = true
            isNewConversation = true
            if !message.isOutgoing {
                conversation.unreadCount = isUserViewing ? 0 : 1
            }
            conversations.append(conversation)
            markConversationDirty(contactAddress)
            print("[ChatService] Created NEW conversation for contact \(contactAddress.suffix(10)), total conversations: \(conversations.count)")
            if isSyncInProgress {
                needsMessageStoreSyncAfterBatch = true
            } else {
                saveMessages()
            }
        }

        // Update contact's last message time (debounced to avoid per-message saves)
        queueLastMessageUpdate(contactId: contact.id, date: message.timestamp)

        if isNewMessage {
            print("[ChatService] Added message \(message.txId.prefix(16))... to \(contactAddress.suffix(10)), type: \(message.messageType), isNew: \(isNewConversation)")
        }

        // If user is currently viewing this chat, advance read marker immediately
        // to prevent unread counter resurrection after store reload/merge.
        if isNewMessage && !message.isOutgoing && isUserViewing && message.blockTime > 0 {
            ReadStatusSyncManager.shared.markAsRead(
                contactAddress: contactAddress,
                lastReadTxId: message.txId,
                lastReadBlockTime: message.blockTime
            )
        }

        // Send local notification for new incoming messages.
        // Only suppress when the app is actively in the foreground AND the user is viewing that conversation.
        let isViewingConversation = activeConversationAddress == contactAddress &&
            UIApplication.shared.applicationState == .active
        if isNewMessage && !message.isOutgoing && !isViewingConversation {
            sendLocalNotification(for: message, from: contact)
        }
    }

    private func updateIncomingPaymentStatus(
        txId: String,
        deliveryStatus: ChatMessage.DeliveryStatus,
        content: String
    ) -> Bool {
        for index in conversations.indices {
            if let msgIndex = conversations[index].messages.firstIndex(where: { $0.txId == txId && !$0.isOutgoing }) {
                let existing = conversations[index].messages[msgIndex]
                if existing.deliveryStatus == deliveryStatus && existing.content == content {
                    return false
                }
                let updated = ChatMessage(
                    id: existing.id,
                    txId: existing.txId,
                    senderAddress: existing.senderAddress,
                    receiverAddress: existing.receiverAddress,
                    content: content,
                    timestamp: existing.timestamp,
                    blockTime: existing.blockTime,
                    acceptingBlock: existing.acceptingBlock,
                    isOutgoing: existing.isOutgoing,
                    messageType: existing.messageType,
                    deliveryStatus: deliveryStatus
                )
                conversations[index].messages[msgIndex] = updated
                return true
            }
        }
        return false
    }

    private func sendLocalNotification(for message: ChatMessage, from contact: Contact) {
        let settings = currentSettings
        // Check if notifications are enabled
        guard settings.notificationsEnabled else { return }
        guard settings.notificationMode != .remotePush else { return }

        // Don't notify during initial sync after wallet import/create
        guard !suppressNotificationsUntilSynced else { return }

        // Respect global defaults + optional per-contact override.
        guard settings.shouldDeliverIncomingNotification(for: contact) else { return }

        // Don't notify for pending messages
        guard message.deliveryStatus != .pending else { return }

        let content = UNMutableNotificationContent()
        content.title = contact.alias
        content.body = formatNotificationBody(message.content)
        let shouldPlaySound = settings.shouldPlayIncomingNotificationSound(for: contact)
        content.sound = shouldPlaySound ? .default : nil
        content.threadIdentifier = contact.address

        if !shouldPlaySound &&
            settings.incomingNotificationVibrationEnabled &&
            UIApplication.shared.applicationState == .active {
            Haptics.impact(.light)
        }

        let request = UNNotificationRequest(
            identifier: message.txId,
            content: content,
            trigger: nil // Deliver immediately
        )

        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("[ChatService] Failed to send notification: \(error.localizedDescription)")
            }
        }
    }

    private func formatNotificationBody(_ content: String) -> String {
        // Check if content is a file JSON payload
        let trimmed = content.trimmingCharacters(in: .whitespacesAndNewlines)
        guard trimmed.hasPrefix("{"), trimmed.hasSuffix("}") else {
            return content
        }

        guard let data = content.data(using: .utf8),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              json["type"] as? String == "file",
              let mimeType = json["mimeType"] as? String else {
            return content
        }

        let mime = mimeType.lowercased()
        if mime.hasPrefix("image/") {
            return "Sent a photo"
        } else if mime.hasPrefix("audio/") {
            return "Sent a voice message"
        } else if mime.hasPrefix("video/") {
            return "Sent a video"
        } else {
            return "Sent a file"
        }
    }

    private func updateConversation(
        at index: Int,
        persist: Bool = true,
        normalizeMessages: Bool = false,
        update: (inout Conversation) -> Void
    ) {
        guard conversations.indices.contains(index) else { return }
        var updatedConversations = conversations
        let originalConversation = updatedConversations[index]
        var conversation = originalConversation
        update(&conversation)
        if normalizeMessages {
            conversation.messages = dedupeMessages(conversation.messages)
        }
        guard conversation != originalConversation else { return }
        updatedConversations[index] = conversation
        conversations = updatedConversations
        guard persist else { return }
        markConversationDirty(conversation.contact.address)
        if isSyncInProgress {
            needsMessageStoreSyncAfterBatch = true
        } else {
            saveMessages()
        }
    }

    private func decodeMessagePayload(_ hexPayload: String?) -> String? {
        guard let hexPayload = hexPayload else { return nil }
        // Remove "ciph_msg:" prefix if present
        var payload = hexPayload
        if payload.hasPrefix("ciph_msg:") {
            payload = String(payload.dropFirst(9))
        }

        // Try to decode as hex
        guard let data = Self.hexStringToData(payload) else { return nil }

        // Try to parse as JSON
        if let json = try? JSONDecoder().decode(HandshakePayload.self, from: data) {
            if let convId = json.conversationId, let recipient = json.recipientAddress {
                conversationIds[recipient] = convId
            }
            return "[Request to communicate]"
        }

        if let json = try? JSONDecoder().decode(MessagePayload.self, from: data) {
            return json.content
        }

        // Return as string if possible
        return String(data: data, encoding: .utf8)
    }

    private func decodePaymentPayload(_ hexPayload: String?) -> PaymentPayload? {
        guard let hexPayload = hexPayload else { return nil }
        var payload = hexPayload
        if payload.hasPrefix("ciph_msg:") {
            payload = String(payload.dropFirst(9))
        }

        guard let data = Self.hexStringToData(payload) else { return nil }

        if let json = try? JSONDecoder().decode(PaymentPayload.self, from: data) {
            return json
        }

        return nil
    }

    private func messageType(for content: String) -> ChatMessage.MessageType {
        guard let data = content.data(using: .utf8),
              let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
              let type = json["type"] as? String,
              type == "file",
              let mime = json["mimeType"] as? String else {
            return .contextual
        }

        if mime.lowercased().hasPrefix("audio/") {
            return .audio
        }

        return .contextual
    }

    private func paymentContent(_ payment: PaymentResponse, isOutgoing: Bool) -> String {
        if let amount = payment.amount {
            let formatted = formatKasAmount(amount)
            let direction = isOutgoing ? "Sent" : "Received"
            if let payload = decodePaymentPayload(payment.messagePayload),
               !payload.message.isEmpty {
                return "\(direction) \(formatted) KAS â€” \(payload.message)"
            }
            return "\(direction) \(formatted) KAS"
        }

        if let payload = decodePaymentPayload(payment.messagePayload) {
            let kasAmount = Double(payload.amount) / 100_000_000.0
            return "Payment: \(kasAmount) KAS â€” \(payload.message)"
        }

        return "[Payment]"
    }

    private func formatKasAmount(_ sompi: UInt64) -> String {
        let kas = Double(sompi) / 100_000_000.0
        let formatter = NumberFormatter()
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 8
        return formatter.string(from: NSNumber(value: kas)) ?? String(format: "%.8f", kas)
    }

    private nonisolated static func hexStringToData(_ hex: String) -> Data? {
        var data = Data()
        var temp = ""

        for char in hex {
            temp += String(char)
            if temp.count == 2 {
                if let byte = UInt8(temp, radix: 16) {
                    data.append(byte)
                } else {
                    return nil
                }
                temp = ""
            }
        }

        return data
    }

    private func migrateLegacyMessagesIfNeeded() {
        guard let data = userDefaults.data(forKey: messagesKey),
              let cachedConversations = try? JSONDecoder().decode([CachedConversation].self, from: data) else {
            return
        }
        guard let key = messageEncryptionKey() else { return }
        guard messageStore.isStoreLoaded else {
            if !legacyMigrationScheduled {
                legacyMigrationScheduled = true
                Task { [weak self] in
                    try? await Task.sleep(nanoseconds: 1_000_000_000)
                    self?.legacyMigrationScheduled = false
                    self?.migrateLegacyMessagesIfNeeded()
                }
            }
            return
        }
        Task { [weak self] in
            guard let self else { return }
            let conversations = await MainActor.run { () -> [Conversation] in
                cachedConversations.compactMap { cached in
                    guard let contact = self.contactsManager.getContact(byAddress: cached.contactAddress) else { return nil }
                    return Conversation(id: cached.id, contact: contact, messages: cached.messages, unreadCount: cached.unreadCount)
                }
            }
            let didWrite = await self.messageStore.syncFromConversations(
                conversations,
                encryptionKey: key,
                retention: SettingsViewModel.loadSettings().messageRetention
            )
            if didWrite {
                await MainActor.run {
                    self.recordLocalSave()
                }
            }
        }
        userDefaults.removeObject(forKey: messagesKey)
    }

    /// Public method to reload messages from the message store.
    /// Call this after CloudKit sync to pick up messages from other devices.
    /// - Parameter forceReload: If true, reloads even if conversations are not empty
    func loadMessagesFromStoreIfNeeded(onlyIfEmpty: Bool = true) {
        if onlyIfEmpty {
            _loadMessagesFromStoreIfNeeded(onlyIfEmpty: true)
            return
        }

        let now = Date()
        let elapsed = now.timeIntervalSince(lastMessageStoreReloadAt)
        if elapsed < messageStoreReloadMinInterval {
            guard !messageStoreReloadPending else { return }
            messageStoreReloadPending = true
            let delay = messageStoreReloadMinInterval - elapsed
            messageStoreReloadTask?.cancel()
            messageStoreReloadTask = Task { @MainActor [weak self] in
                try? await Task.sleep(nanoseconds: UInt64(max(delay, 0) * 1_000_000_000))
                guard let self else { return }
                self.messageStoreReloadPending = false
                self.lastMessageStoreReloadAt = Date()
                self._loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
            }
            return
        }

        lastMessageStoreReloadAt = now
        _loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
    }

    private func _loadMessagesFromStoreIfNeeded(onlyIfEmpty: Bool) {
        if onlyIfEmpty && !conversations.isEmpty {
            return
        }
        guard let key = messageEncryptionKey() else { return }
        let messages = messageStore.fetchAllMessages(decryptionKey: key)
        let meta = messageStore.fetchConversationMeta()
        guard !messages.isEmpty || !meta.isEmpty else { return }

        // Debug: count messages with/without content
        let withContent = messages.filter { $0.message.content != "ðŸ“¤ Sent via another device" }.count
        let placeholder = messages.count - withContent
        NSLog("[ChatService] loadMessagesFromStore: %d messages (%d with content, %d placeholder)",
              messages.count, withContent, placeholder)

        var grouped: [String: [String: ChatMessage]] = [:]
        for stored in messages {
            let contactAddress = stored.contactAddress
            let txId = stored.message.txId
            guard !txId.isEmpty else {
                continue
            }
            var bucket = grouped[contactAddress, default: [:]]
            if let existing = bucket[txId] {
                bucket[txId] = preferMessage(existing, stored.message)
            } else {
                bucket[txId] = stored.message
            }
            grouped[contactAddress] = bucket
        }

        var loaded: [Conversation] = []
        let allContactAddresses = Set(grouped.keys).union(meta.keys)
        for contactAddress in allContactAddresses {
            let byTxId = grouped[contactAddress] ?? [:]
            let contact = contactsManager.getOrCreateContact(address: contactAddress)
            let conversationId = meta[contactAddress]?.id ?? UUID()
            let sorted = byTxId.values.sorted(by: isMessageOrderedBefore)
            let dedupedFull = dedupeMessages(sorted)
            let dedupedWindow = trimMessagesForMemory(dedupedFull)

            // Compute unread count from lastReadBlockTime if available (CloudKit-synced)
            // This ensures read status from other devices is honored
            let convMeta = meta[contactAddress]
            let lastReadBlockTime = convMeta?.lastReadBlockTime ?? 0
            let unreadCount: Int
            if lastReadBlockTime > 0 {
                // Compute unread as messages with blockTime > lastReadBlockTime (incoming only)
                unreadCount = dedupedFull.filter { msg in
                    !msg.isOutgoing && Int64(msg.blockTime) > lastReadBlockTime
                }.count
            } else {
                // Fallback to stored unreadCount (backward compatibility)
                unreadCount = convMeta?.unreadCount ?? 0
            }

            loaded.append(Conversation(id: conversationId, contact: contact, messages: dedupedWindow, unreadCount: unreadCount))
        }

        if !loaded.isEmpty {
            resetOlderHistoryPaginationState(for: allContactAddresses)
            if conversations.isEmpty {
                conversations = loaded.sorted { ($0.lastMessage?.timestamp ?? .distantPast) < ($1.lastMessage?.timestamp ?? .distantPast) }
                rebuildPendingOutgoingQueue()
                return
            }

            var existingByAddress: [String: Conversation] = [:]
            for conversation in conversations {
                existingByAddress[conversation.contact.address] = conversation
            }

            var merged: [Conversation] = []
            var seenAddresses: Set<String> = []

            for loadedConv in loaded {
                let address = loadedConv.contact.address
                seenAddresses.insert(address)
                if var existing = existingByAddress[address] {
                    let mergedMessages = dedupeMessages(existing.messages + loadedConv.messages)
                    let shouldTrim = address != activeConversationAddress
                    let combinedMessages = shouldTrim
                        ? trimMessagesForMemory(mergedMessages)
                        : mergedMessages

                    // Determine unread count:
                    // - If CloudKit has a read status (lastReadBlockTime > 0), use computed count from loaded
                    // - Otherwise prefer in-memory value to prevent race conditions
                    let convMeta = meta[address]
                    let cloudKitLastReadBlockTime = convMeta?.lastReadBlockTime ?? 0
                    let unreadCount: Int
                    if cloudKitLastReadBlockTime > 0 {
                        // CloudKit has read status - recompute unread from combined messages
                        unreadCount = combinedMessages.filter { msg in
                            !msg.isOutgoing && Int64(msg.blockTime) > cloudKitLastReadBlockTime
                        }.count
                    } else {
                        // No CloudKit read status - prefer in-memory value
                        unreadCount = existing.unreadCount
                    }

                    existing = Conversation(
                        id: existing.id,
                        contact: existing.contact,
                        messages: combinedMessages,
                        unreadCount: unreadCount
                    )
                    merged.append(existing)
                } else {
                    merged.append(loadedConv)
                }
            }

            for conversation in conversations where !seenAddresses.contains(conversation.contact.address) {
                merged.append(conversation)
            }

            conversations = merged.sorted { ($0.lastMessage?.timestamp ?? .distantPast) < ($1.lastMessage?.timestamp ?? .distantPast) }
            rebuildPendingOutgoingQueue()
        }
    }

    private func isMessageOrderedBefore(_ lhs: ChatMessage, _ rhs: ChatMessage) -> Bool {
        if lhs.blockTime != rhs.blockTime {
            return lhs.blockTime < rhs.blockTime
        }
        if lhs.timestamp != rhs.timestamp {
            return lhs.timestamp < rhs.timestamp
        }
        if lhs.id != rhs.id {
            return lhs.id.uuidString < rhs.id.uuidString
        }
        return lhs.txId < rhs.txId
    }

    private func preferMessage(_ existing: ChatMessage, _ candidate: ChatMessage) -> ChatMessage {
        let existingPlaceholder = isPlaceholderContent(existing.content)
        let candidatePlaceholder = isPlaceholderContent(candidate.content)

        if existingPlaceholder != candidatePlaceholder {
            return candidatePlaceholder ? existing : candidate
        }

        if existing.deliveryStatus != candidate.deliveryStatus {
            if candidate.deliveryStatus.priority != existing.deliveryStatus.priority {
                return candidate.deliveryStatus.priority > existing.deliveryStatus.priority ? candidate : existing
            }
        }

        return isMessageOrderedBefore(existing, candidate) ? candidate : existing
    }

    private func isPlaceholderContent(_ content: String) -> Bool {
        content == "ðŸ“¤ Sent via another device" || content == "[Encrypted message]"
    }

    private func dedupeMessages(_ messages: [ChatMessage]) -> [ChatMessage] {
        var byId: [UUID: ChatMessage] = [:]
        for message in messages {
            if let existing = byId[message.id] {
                byId[message.id] = preferMessage(existing, message)
            } else {
                byId[message.id] = message
            }
        }

        var byTxId: [String: ChatMessage] = [:]
        for message in byId.values {
            let key = message.txId.isEmpty ? message.id.uuidString : message.txId
            if let existing = byTxId[key] {
                byTxId[key] = preferMessage(existing, message)
            } else {
                byTxId[key] = message
            }
        }
        return Array(byTxId.values).sorted(by: isMessageOrderedBefore)
    }

    /// Reduce in-memory history while preserving protocol-critical/system-critical messages.
    /// Keeps all handshakes and unsent messages, plus a rolling window of recent regular messages.
    private func trimMessagesForMemory(_ messages: [ChatMessage]) -> [ChatMessage] {
        guard messages.count > inMemoryConversationWindowSize else { return messages }

        let sticky = messages.filter { message in
            message.messageType == .handshake || message.deliveryStatus != .sent
        }
        let stickyIds = Set(sticky.map(\.id))
        let recent = messages
            .filter { !stickyIds.contains($0.id) }
            .suffix(inMemoryConversationWindowSize)

        return Array((sticky + recent).sorted(by: isMessageOrderedBefore))
    }

    private func rebuildPendingOutgoingQueue() {
        pendingOutgoingQueue.removeAll()
        for conversation in conversations {
            let pending = conversation.messages
                .filter { $0.isOutgoing && $0.deliveryStatus != .sent }
                .sorted(by: isMessageOrderedBefore)
            guard !pending.isEmpty else { continue }
            let contactAddress = conversation.contact.address
            pendingOutgoingQueue[contactAddress] = pending.map {
                PendingOutgoingRef(txId: $0.txId, messageType: $0.messageType, timestamp: $0.timestamp)
            }
        }
    }

    private func resetOlderHistoryPaginationState<S: Sequence>(for contactAddresses: S) where S.Element == String {
        for address in contactAddresses {
            olderHistoryExhaustedContacts.remove(address)
            olderHistoryPageTasks[address]?.cancel()
            olderHistoryPageTasks[address] = nil
        }
    }

    /// Debounce state for CloudKit import on remote store change
    private var cloudKitImportTimer: Timer?
    private var lastCloudKitImportAt: Date?
    private var lastLocalSaveAt: Date?
    #if targetEnvironment(macCatalyst)
    private let cloudKitImportMinInterval: TimeInterval = 30.0 // Catalyst imports are slower; reduce churn.
    #else
    private let cloudKitImportMinInterval: TimeInterval = 10.0
    #endif

    private func observeRemoteStoreChanges() {
        remoteChangeObserver = messageStore.observeRemoteChanges { [weak self] in
            Task { @MainActor [weak self] in
                self?.scheduleCloudKitImport()
            }
        }
    }

    /// Record when we do a local save to avoid triggering import right after
    private func recordLocalSave() {
        lastLocalSaveAt = Date()
    }

    private func scheduleCloudKitImport() {
        // Ignore remote-change notifications while app is inactive to avoid
        // background import churn and CoreData CloudKit background task pressure.
        guard UIApplication.shared.applicationState == .active else { return }

        // Skip if this notification is likely from our own recent save
        if let lastSave = lastLocalSaveAt,
           Date().timeIntervalSince(lastSave) < 15.0 {
            return  // Likely our own save, skip
        }

        // Cancel any pending timer
        cloudKitImportTimer?.invalidate()

        // If already have a timer pending, this is a burst - import now
        if cloudKitImportTimer != nil {
            cloudKitImportTimer = nil
            performCloudKitImport()
            return
        }

        // First notification - wait 500ms for more to arrive
        cloudKitImportTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: false) { [weak self] _ in
            Task { @MainActor [weak self] in
                guard let self else { return }
                self.cloudKitImportTimer = nil
                self.performCloudKitImport()
            }
        }
    }

    private func performCloudKitImport() {
        // Avoid competing with initial CloudKit setup/import. Let MessageStore
        // complete initial sync first, then remote-change imports can run.
        switch messageStore.cloudKitSyncStatus {
        case .syncing, .notStarted, .disabled, .failed:
            return
        default:
            break
        }

        // Remote-change notifications mean Core Data already has new transactions.
        // Do not force a new CloudKit import cycle here; just refresh and reload.
        if UIApplication.shared.applicationState != .active {
            return
        }

        // Check minimum interval
        if let lastImport = lastCloudKitImportAt,
           Date().timeIntervalSince(lastImport) < cloudKitImportMinInterval {
            return  // Too soon
        }

        lastCloudKitImportAt = Date()
        NSLog("[ChatService] Processing remote store change")

        Task {
            messageStore.refreshFromCloudKit()
            messageStore.processRemoteChanges()
            await MainActor.run {
                self.loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
            }
        }
    }

    private func observeContacts() {
        contactsCancellable = contactsManager.$contacts
            .receive(on: RunLoop.main)
            .sink { [weak self] contacts in
                self?.syncConversationContacts(with: contacts)
            }
    }

    private func observeSettings() {
        settingsCancellable = NotificationCenter.default.publisher(for: .settingsDidChange)
            .receive(on: RunLoop.main)
            .sink { [weak self] notification in
                guard let settings = notification.object as? AppSettings else { return }
                self?.cachedSettings = settings
                self?.messageStore.applyRetention(settings.messageRetention)
                self?.saveMessages()
                self?.refreshPushReliabilityPrerequisites()
            }
    }

    private func loadPushReliabilityState() {
        if let raw = userDefaults.string(forKey: pushReliabilityStateKey),
           let parsed = PushReliabilityState(rawValue: raw) {
            pushReliabilityState = parsed
        } else {
            pushReliabilityState = .disabled
        }
        pushConsecutiveMisses = max(0, userDefaults.integer(forKey: pushConsecutiveMissesKey))

        if let ts = userDefaults.object(forKey: pushLastCatchUpSyncAtKey) as? Double {
            lastCatchUpSyncAt = Date(timeIntervalSince1970: ts)
        } else {
            lastCatchUpSyncAt = nil
        }

        if let ts = userDefaults.object(forKey: pushLastReregisterAtKey) as? Double {
            lastPushReregisterAt = Date(timeIntervalSince1970: ts)
        } else {
            lastPushReregisterAt = nil
        }

        refreshPushReliabilityPrerequisites()
    }

    private func persistPushReliabilityState() {
        userDefaults.set(pushReliabilityState.rawValue, forKey: pushReliabilityStateKey)
        userDefaults.set(pushConsecutiveMisses, forKey: pushConsecutiveMissesKey)
        if let lastCatchUpSyncAt {
            userDefaults.set(lastCatchUpSyncAt.timeIntervalSince1970, forKey: pushLastCatchUpSyncAtKey)
        } else {
            userDefaults.removeObject(forKey: pushLastCatchUpSyncAtKey)
        }
        if let lastPushReregisterAt {
            userDefaults.set(lastPushReregisterAt.timeIntervalSince1970, forKey: pushLastReregisterAtKey)
        } else {
            userDefaults.removeObject(forKey: pushLastReregisterAtKey)
        }
    }

    private func isPushChannelOperational() -> Bool {
        let settings = currentSettings
        guard settings.notificationMode == .remotePush else { return false }

        let pushManager = PushNotificationManager.shared
        let status = pushManager.permissionStatus
        guard status == .authorized || status == .provisional else { return false }
        guard pushManager.isRegistered else { return false }

        return true
    }

    private func refreshPushReliabilityPrerequisites() {
        if !isPushChannelOperational() {
            if pushReliabilityState != .disabled {
                NSLog("[ChatService] Push reliability disabled (push mode not operational)")
            }
            pushReliabilityState = .disabled
            pushConsecutiveMisses = 0
            for task in pushObservationTasks.values {
                task.cancel()
            }
            pushObservationTasks.removeAll()
            pendingPushObservations.removeAll()
            persistPushReliabilityState()
            return
        }

        if pushReliabilityState == .disabled {
            pushReliabilityState = .unknown
            pushConsecutiveMisses = 0
            NSLog("[ChatService] Push reliability moved to unknown (operational)")
            persistPushReliabilityState()
        }
    }

    private func prunePushReliabilityCaches(now: Date) {
        let cutoff = now.addingTimeInterval(-pushObservationRetention)
        pushSeenByTxId = pushSeenByTxId.filter { $0.value >= cutoff }

        let staleObservations = pendingPushObservations.values
            .filter { $0.observedAt < cutoff }
            .map(\.txId)
        for txId in staleObservations {
            pendingPushObservations.removeValue(forKey: txId)
            if let task = pushObservationTasks.removeValue(forKey: txId) {
                task.cancel()
            }
        }
    }

    private func shouldTrackPushReliability(for senderAddress: String) -> Bool {
        let normalized = senderAddress.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        guard !normalized.isEmpty else { return false }

        let settings = currentSettings
        guard settings.notificationMode == .remotePush else { return false }

        let eligible = Set(pushEligibleConversationAddresses(settings: settings))
        guard eligible.contains(normalized) else { return false }

        let contact = contactsManager.getContact(byAddress: normalized)
        return settings.shouldDeliverIncomingNotification(for: contact)
    }

    private func trackIncomingUtxoForPushReliability(txId: String, senderAddress: String) {
        refreshPushReliabilityPrerequisites()
        guard pushReliabilityState != .disabled else { return }
        guard shouldTrackPushReliability(for: senderAddress) else { return }

        let normalizedTxId = txId.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !normalizedTxId.isEmpty else { return }

        let now = Date()
        prunePushReliabilityCaches(now: now)

        if let pushSeenAt = pushSeenByTxId[normalizedTxId],
           pushSeenAt.timeIntervalSince(now) >= -pushLeadMatchTolerance {
            applyPushObservationOutcome(
                txId: normalizedTxId,
                senderAddress: senderAddress,
                didReceivePush: true
            )
            return
        }

        if pendingPushObservations[normalizedTxId] != nil {
            return
        }

        pendingPushObservations[normalizedTxId] = PendingPushObservation(
            txId: normalizedTxId,
            senderAddress: senderAddress,
            observedAt: now
        )
        schedulePushObservationEvaluation(for: normalizedTxId)
    }

    private func schedulePushObservationEvaluation(for txId: String) {
        if let task = pushObservationTasks.removeValue(forKey: txId) {
            task.cancel()
        }
        let delayNs = UInt64(pushObservationGraceInterval * 1_000_000_000)
        pushObservationTasks[txId] = Task { [weak self] in
            try? await Task.sleep(nanoseconds: delayNs)
            await self?.evaluatePendingPushObservation(txId: txId)
        }
    }

    private func evaluatePendingPushObservation(txId: String) {
        refreshPushReliabilityPrerequisites()
        guard pushReliabilityState != .disabled else { return }

        guard let observation = pendingPushObservations.removeValue(forKey: txId) else {
            pushObservationTasks.removeValue(forKey: txId)
            return
        }

        if let task = pushObservationTasks.removeValue(forKey: txId) {
            task.cancel()
        }

        guard shouldTrackPushReliability(for: observation.senderAddress) else {
            return
        }

        let didReceivePush: Bool
        if let pushSeenAt = pushSeenByTxId[txId] {
            didReceivePush = pushSeenAt.timeIntervalSince(observation.observedAt) >= -pushLeadMatchTolerance
        } else {
            didReceivePush = false
        }

        applyPushObservationOutcome(
            txId: txId,
            senderAddress: observation.senderAddress,
            didReceivePush: didReceivePush
        )
    }

    private func applyPushObservationOutcome(
        txId: String,
        senderAddress: String,
        didReceivePush: Bool
    ) {
        refreshPushReliabilityPrerequisites()
        guard pushReliabilityState != .disabled else { return }

        if didReceivePush {
            pushConsecutiveMisses = 0
            if pushReliabilityState != .reliable {
                transitionPushReliabilityState(
                    to: .reliable,
                    reason: "push matched tx \(String(txId.prefix(12))) from \(String(senderAddress.suffix(10)))"
                )
            } else {
                persistPushReliabilityState()
            }
            return
        }

        pushConsecutiveMisses += 1
        NSLog("[ChatService] Push miss for tx=%@ sender=%@ misses=%d",
              String(txId.prefix(12)),
              String(senderAddress.suffix(10)),
              pushConsecutiveMisses)
        if pushConsecutiveMisses >= 3 {
            transitionPushReliabilityState(
                to: .unreliable,
                reason: "3 consecutive push misses"
            )
        } else {
            persistPushReliabilityState()
        }
    }

    private func transitionPushReliabilityState(to newState: PushReliabilityState, reason: String) {
        guard pushReliabilityState != newState else { return }
        let oldState = pushReliabilityState
        pushReliabilityState = newState
        if newState == .reliable || newState == .disabled {
            pushConsecutiveMisses = 0
        }
        persistPushReliabilityState()

        NSLog("[ChatService] Push reliability state %@ -> %@ (%@)",
              oldState.rawValue,
              newState.rawValue,
              reason)

        if newState == .unreliable {
            Task { [weak self] in
                await self?.handlePushMarkedUnreliable(reason: reason)
            }
        }
    }

    private func handlePushMarkedUnreliable(reason: String) async {
        await maybeRunCatchUpSync(trigger: .pushMarkedUnreliable, force: true)

        let now = Date()
        if let lastPushReregisterAt,
           now.timeIntervalSince(lastPushReregisterAt) < pushReregisterCooldown {
            NSLog("[ChatService] Skipping push re-register - cooldown active")
            return
        }

        lastPushReregisterAt = now
        persistPushReliabilityState()
        await PushNotificationManager.shared.forceReregister(reason: reason)
    }

    private func handleCloudKitImportResult(txId: String, didImport: Bool) async {
        guard messageStore.hasMessageWithContent(txId: txId) == false else {
            cloudKitImportFirstAttemptAt.removeValue(forKey: txId)
            cloudKitImportLastObservedAt.removeValue(forKey: txId)
            cloudKitImportRetryTokenByTxId.removeValue(forKey: txId)
            return
        }

        let firstAttempt = cloudKitImportFirstAttemptAt[txId] ?? Date()
        cloudKitImportFirstAttemptAt[txId] = firstAttempt
        let elapsed = Date().timeIntervalSince(firstAttempt)
        if elapsed >= cloudKitImportMaxWaitSeconds {
            NSLog("[ChatService] CloudKit import wait exhausted for %@ after %.0fs",
                  String(txId.prefix(12)), elapsed)
            cloudKitImportFirstAttemptAt.removeValue(forKey: txId)
            cloudKitImportLastObservedAt.removeValue(forKey: txId)
            cloudKitImportRetryTokenByTxId.removeValue(forKey: txId)
            return
        }

        var delaySeconds: TimeInterval = didImport ? 6.0 : 2.0
        var retryAfterDate = cloudKitImportLastObservedAt[txId] ?? firstAttempt
        var retryReason = didImport ? "observed but content missing" : "timed out"

        if didImport, let latestImport = messageStore.latestCloudKitImportEndDate {
            if let previousImport = cloudKitImportLastObservedAt[txId], latestImport <= previousImport {
                // We only saw the same import watermark again; wait a bit longer and
                // require a newer import cycle on retry.
                delaySeconds = 8.0
                retryAfterDate = previousImport
                retryReason = "observed stale import"
            } else {
                cloudKitImportLastObservedAt[txId] = latestImport
                retryAfterDate = latestImport
            }
        }

        NSLog("[ChatService] CloudKit import %@ for %@ - retrying in %.1fs (elapsed %.0fs, after=%@)",
              retryReason,
              String(txId.prefix(12)),
              delaySeconds,
              elapsed,
              retryAfterDate.description)

        let retryToken = UUID()
        cloudKitImportRetryTokenByTxId[txId] = retryToken

        Task { @MainActor [weak self] in
            try? await Task.sleep(nanoseconds: UInt64(delaySeconds * 1_000_000_000))
            guard let self else { return }
            guard self.cloudKitImportRetryTokenByTxId[txId] == retryToken else { return }
            let didRetryImport = await MessageStore.shared.fetchCloudKitChanges(
                reason: "self-stash-retry-\(String(txId.prefix(12)))",
                after: retryAfterDate,
                timeout: 12.0
            )
            guard self.cloudKitImportRetryTokenByTxId[txId] == retryToken else { return }
            self.loadMessagesFromStoreIfNeeded(onlyIfEmpty: false)
            await self.handleCloudKitImportResult(txId: txId, didImport: didRetryImport)
        }
    }

    private func syncConversationContacts(with contacts: [Contact]) {
        var byId: [UUID: Contact] = [:]
        byId.reserveCapacity(contacts.count)
        var byAddress: [String: Contact] = [:]
        byAddress.reserveCapacity(contacts.count)
        for contact in contacts {
            byId[contact.id] = contact
            byAddress[contact.address.lowercased()] = contact
        }

        let updated = conversations.map { conversation -> Conversation in
            let refreshed = byId[conversation.contact.id] ??
                byAddress[conversation.contact.address.lowercased()]
            guard let refreshed else {
                return conversation
            }
            if refreshed == conversation.contact {
                return conversation
            }
            return Conversation(
                id: conversation.id,
                contact: refreshed,
                messages: conversation.messages,
                unreadCount: conversation.unreadCount
            )
        }
        if updated != conversations {
            conversations = updated
        }
    }

    private func currentTimeMs() -> UInt64 {
        UInt64(Date().timeIntervalSince1970 * 1000)
    }

    private func handshakeSyncObjectKey(direction: String, address: String) -> String {
        "hs|\(direction)|\(address.lowercased())"
    }

    private func contextualSyncObjectKey(
        direction: String,
        queryAddress: String,
        alias: String,
        contactAddress: String? = nil
    ) -> String {
        var key = "ctx|\(direction)|\(queryAddress.lowercased())|\(alias)"
        if let contactAddress, !contactAddress.isEmpty {
            key += "|\(contactAddress.lowercased())"
        }
        return key
    }

    private func syncStartBlockTime(for objectKey: String, fallbackBlockTime: UInt64, nowMs: UInt64) -> UInt64 {
        guard let cursor = syncObjectCursors[objectKey], cursor.lastFetchedBlockTime > 0 else {
            return fallbackBlockTime
        }

        let lastFetchedBlockTime = cursor.lastFetchedBlockTime
        if nowMs > lastFetchedBlockTime, nowMs - lastFetchedBlockTime > syncReorgBufferMs {
            return lastFetchedBlockTime == UInt64.max ? UInt64.max : lastFetchedBlockTime + 1
        }

        return lastFetchedBlockTime > syncReorgBufferMs ? lastFetchedBlockTime - syncReorgBufferMs : 0
    }

    private func advanceSyncCursor(for objectKey: String, maxBlockTime: UInt64?) {
        guard let maxBlockTime, maxBlockTime > 0 else { return }
        let previous = syncObjectCursors[objectKey]?.lastFetchedBlockTime ?? 0
        guard maxBlockTime > previous else { return }
        syncObjectCursors[objectKey] = SyncObjectCursor(lastFetchedBlockTime: maxBlockTime)
        syncObjectCursorsDirty = true
        if !isSyncInProgress {
            saveSyncObjectCursorsIfNeeded()
        }
    }

    private func clearSyncObjectCursors() {
        syncObjectCursors = [:]
        syncObjectCursorsDirty = false
        userDefaults.removeObject(forKey: syncCursorsKey)
    }

    private func loadSyncObjectCursors() {
        guard let data = userDefaults.data(forKey: syncCursorsKey),
              let decoded = try? JSONDecoder().decode([String: SyncObjectCursor].self, from: data) else {
            return
        }
        syncObjectCursors = decoded
    }

    private func saveSyncObjectCursorsIfNeeded() {
        guard syncObjectCursorsDirty else { return }
        guard let data = try? JSONEncoder().encode(syncObjectCursors) else { return }
        userDefaults.set(data, forKey: syncCursorsKey)
        syncObjectCursorsDirty = false
    }

    private func updateLastPollTime(_ blockTime: UInt64) {
        if isSyncInProgress {
            if let current = syncMaxBlockTime {
                syncMaxBlockTime = max(current, blockTime)
            } else {
                syncMaxBlockTime = blockTime
            }
            return
        }
        lastPollTime = blockTime
        userDefaults.set(Int(blockTime), forKey: lastPollTimeKey)
    }

    private func scheduleBadgeUpdate() {
        badgeUpdateTask?.cancel()
        badgeUpdateTask = Task { @MainActor in
            try? await Task.sleep(nanoseconds: 200_000_000)
            updateAppBadge()
        }
    }

    private func updateAppBadge() {
        let totalUnread = conversations.reduce(0) { $0 + max(0, $1.unreadCount) }
        SharedDataManager.setUnreadCount(totalUnread)
        if #available(iOS 16.0, *) {
            UNUserNotificationCenter.current().setBadgeCount(totalUnread)
        } else {
            UIApplication.shared.applicationIconBadgeNumber = totalUnread
        }
    }

    private func beginSyncBlockTime() {
        isSyncInProgress = true
        syncMaxBlockTime = lastPollTime
    }

    private func endSyncBlockTime(success: Bool) {
        defer {
            isSyncInProgress = false
            syncMaxBlockTime = nil
        }

        if success, let candidate = syncMaxBlockTime, candidate > lastPollTime {
            lastPollTime = candidate
            userDefaults.set(Int(candidate), forKey: lastPollTimeKey)
        }
        if needsMessageStoreSyncAfterBatch {
            needsMessageStoreSyncAfterBatch = false
            saveMessages()
        }
        saveSyncObjectCursorsIfNeeded()
        flushPendingLastMessageUpdates()
    }

    private func messageEncryptionKey() -> SymmetricKey? {
        guard var privateKey = WalletManager.shared.getPrivateKey() else { return nil }
        var keyData = CryptoUtils.sha256(privateKey)
        privateKey.zeroOut()
        let key = SymmetricKey(data: keyData)
        keyData.zeroOut()
        return key
    }

    private func scheduleMessageStoreSync(triggerExport: Bool = false) {
        if triggerExport {
            pendingCloudKitExport = true
        }
        if let lastScheduled = lastMessageStoreSyncScheduledAt,
           !isSyncInProgress,
           Date().timeIntervalSince(lastScheduled) < messageStoreSyncMinInterval,
           !pendingCloudKitExport {
            return
        }
        messageSyncTask?.cancel()
        lastMessageStoreSyncScheduledAt = Date()
        messageSyncTask = Task { [weak self] in
            // Reduced delay from 600ms to 150ms to minimize race condition window
            // where in-memory changes (e.g., marking as read) get overwritten by
            // stale Core Data reloads before save completes
            try? await Task.sleep(nanoseconds: 150_000_000)
            guard let self else { return }
            guard let key = self.messageEncryptionKey() else { return }
            let shouldExport = self.pendingCloudKitExport
            let conversationsSnapshot = await MainActor.run { self.conversations }
            let dirtyAddresses = await MainActor.run { () -> Set<String> in
                let snapshot = self.dirtyConversationAddresses
                self.dirtyConversationAddresses.removeAll()
                return snapshot
            }
            let now = Date()
            let shouldRunMaintenance = now.timeIntervalSince(self.lastFullStoreMaintenanceAt) >= self.fullStoreMaintenanceInterval
            let conversationsToSync: [Conversation]
            let performMaintenance: Bool
            if shouldRunMaintenance {
                conversationsToSync = conversationsSnapshot
                performMaintenance = true
            } else if !dirtyAddresses.isEmpty {
                conversationsToSync = conversationsSnapshot.filter { dirtyAddresses.contains($0.contact.address) }
                performMaintenance = false
            } else {
                conversationsToSync = []
                performMaintenance = false
            }

            if conversationsToSync.isEmpty {
                if shouldExport {
                    await MainActor.run {
                        self.messageStore.triggerCloudKitExport()
                        self.pendingCloudKitExport = false
                    }
                } else {
                    await MainActor.run {
                        self.pendingCloudKitExport = false
                    }
                }
                return
            }

            let didWrite = await self.messageStore.syncFromConversations(
                conversationsToSync,
                encryptionKey: key,
                retention: SettingsViewModel.loadSettings().messageRetention,
                performMaintenance: performMaintenance
            )
            if performMaintenance {
                await MainActor.run {
                    self.lastFullStoreMaintenanceAt = now
                }
            }

            if didWrite {
                // Record that we just did a local save (to avoid triggering import from our own changes)
                await MainActor.run {
                    self.recordLocalSave()
                }
            }

            // Trigger CloudKit export for outgoing content (debounced)
            if shouldExport && didWrite {
                await MainActor.run {
                    NSLog("[ChatService] Triggering CloudKit export after message store sync")
                    NSLog("[ChatService] Requesting CloudKit export after message store sync")
                    self.messageStore.triggerCloudKitExport()
                    self.pendingCloudKitExport = false
                }
            } else if shouldExport {
                await MainActor.run {
                    self.pendingCloudKitExport = false
                }
            }
        }
    }

    private func saveMessages(triggerExport: Bool = false) {
        scheduleMessageStoreSync(triggerExport: triggerExport)
    }

    private func markConversationDirty(_ contactAddress: String) {
        dirtyConversationAddresses.insert(contactAddress)
    }

    private func enqueuePendingOutgoing(contactAddress: String, pendingTxId: String, messageType: ChatMessage.MessageType, timestamp: Date) {
        var queue = pendingOutgoingQueue[contactAddress, default: []]
        if !queue.contains(where: { $0.txId == pendingTxId }) {
            queue.append(PendingOutgoingRef(txId: pendingTxId, messageType: messageType, timestamp: timestamp))
            queue.sort { $0.timestamp < $1.timestamp }
            pendingOutgoingQueue[contactAddress] = queue
        }
    }

    private func removePendingOutgoing(contactAddress: String, pendingTxId: String) {
        guard var queue = pendingOutgoingQueue[contactAddress] else { return }
        queue.removeAll { $0.txId == pendingTxId }
        if queue.isEmpty {
            pendingOutgoingQueue.removeValue(forKey: contactAddress)
        } else {
            pendingOutgoingQueue[contactAddress] = queue
        }
    }

    private func removePendingOutgoingGlobally(_ pendingTxId: String) {
        for (contactAddress, queue) in pendingOutgoingQueue {
            let filtered = queue.filter { $0.txId != pendingTxId }
            if filtered.isEmpty {
                pendingOutgoingQueue.removeValue(forKey: contactAddress)
            } else {
                pendingOutgoingQueue[contactAddress] = filtered
            }
        }
    }

    private func popPendingOutgoing(contactAddress: String, messageType: ChatMessage.MessageType) -> String? {
        guard var queue = pendingOutgoingQueue[contactAddress] else { return nil }
        if let index = queue.firstIndex(where: { $0.messageType == messageType }) {
            let ref = queue.remove(at: index)
            if queue.isEmpty {
                pendingOutgoingQueue.removeValue(forKey: contactAddress)
            } else {
                pendingOutgoingQueue[contactAddress] = queue
            }
            return ref.txId
        }
        return nil
    }

    private func updatePendingFromQueue(contactAddress: String, newTxId: String, messageType: ChatMessage.MessageType) -> Bool {
        guard let queue = pendingOutgoingQueue[contactAddress], !queue.isEmpty else {
            return false
        }
        guard let convIndex = conversations.firstIndex(where: { $0.contact.address == contactAddress }) else {
            return false
        }
        let pendingSet = Set(conversations[convIndex].messages.map { $0.txId })
        for ref in queue where ref.messageType == messageType {
            if pendingSet.contains(ref.txId) {
                if updatePendingMessage(ref.txId, withRealTxId: newTxId, contactAddress: contactAddress) {
                    return true
                }
            }
        }
        return false
    }

    private func queueLastMessageUpdate(contactId: UUID, date: Date) {
        if let existing = pendingLastMessageUpdates[contactId], existing >= date {
            return
        }
        pendingLastMessageUpdates[contactId] = date
        pendingLastMessageUpdateWorkItem?.cancel()
        let workItem = DispatchWorkItem { [weak self] in
            self?.flushPendingLastMessageUpdates()
        }
        pendingLastMessageUpdateWorkItem = workItem
        let delay = isSyncInProgress ? max(lastMessageBatchDelay, 1.5) : lastMessageBatchDelay
        DispatchQueue.main.asyncAfter(deadline: .now() + delay, execute: workItem)
    }

    private func flushPendingLastMessageUpdates() {
        guard !pendingLastMessageUpdates.isEmpty else { return }
        let updates = pendingLastMessageUpdates
        pendingLastMessageUpdates.removeAll()
        for (contactId, date) in updates {
            contactsManager.updateContactLastMessage(contactId, at: date)
        }
    }

    // MARK: - Draft Storage

    private func loadMessageDrafts() {
        guard let data = userDefaults.data(forKey: draftsKey),
              let drafts = try? JSONDecoder().decode([String: String].self, from: data) else {
            return
        }
        messageDrafts = drafts
    }

    private func saveMessageDrafts() {
        guard let data = try? JSONEncoder().encode(messageDrafts) else { return }
        userDefaults.set(data, forKey: draftsKey)
    }

    func draft(for contactAddress: String) -> String {
        messageDrafts[contactAddress] ?? ""
    }

    func setDraft(_ text: String, for contactAddress: String) {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.isEmpty {
            messageDrafts.removeValue(forKey: contactAddress)
        } else {
            messageDrafts[contactAddress] = text
        }
        saveMessageDrafts()
    }

    func clearDraft(for contactAddress: String) {
        if messageDrafts.removeValue(forKey: contactAddress) != nil {
            saveMessageDrafts()
        }
    }

    // MARK: - Alias Storage

    private func loadConversationAliases() {
        guard let data = userDefaults.data(forKey: aliasesKey) else {
            return
        }
        if let decoded = decodeAliasSetMap(from: data) {
            conversationAliases = decoded
        } else if let legacy = try? JSONDecoder().decode([String: String].self, from: data) {
            conversationAliases = legacy.mapValues { [$0] }.mapValues { Set($0) }
            conversationPrimaryAliases = legacy
        }
        if let primaryData = userDefaults.data(forKey: conversationPrimaryAliasesKey),
           let primary = try? JSONDecoder().decode([String: String].self, from: primaryData) {
            conversationPrimaryAliases = primary
        }
        if let updatedData = userDefaults.data(forKey: conversationAliasUpdatedAtKey),
           let updated = try? JSONDecoder().decode([String: UInt64].self, from: updatedData) {
            conversationAliasUpdatedAt = updated
        }
        rebuildPrimaryAliasesIfNeeded()
        print("[ChatService] Loaded \(conversationAliases.count) conversation aliases")
    }

    private func saveConversationAliases() {
        guard let data = try? JSONEncoder().encode(encodeAliasSetMap(conversationAliases)) else { return }
        userDefaults.set(data, forKey: aliasesKey)
        if let primaryData = try? JSONEncoder().encode(conversationPrimaryAliases) {
            userDefaults.set(primaryData, forKey: conversationPrimaryAliasesKey)
        }
        if let updatedData = try? JSONEncoder().encode(conversationAliasUpdatedAt) {
            userDefaults.set(updatedData, forKey: conversationAliasUpdatedAtKey)
        }
        Task {
            await PushNotificationManager.shared.updateWatchedAddresses()
        }
    }

    func knownIncomingAliases() -> [String] {
        let addresses = Set(conversationPrimaryAliases.keys).union(conversationAliases.keys).union(routingStates.keys)
        return knownIncomingAliases(forAddresses: addresses)
    }

    func knownIncomingAliases(forAddresses addresses: Set<String>) -> [String] {
        let normalizedAddresses = Set(addresses.map { $0.lowercased() })
        guard !normalizedAddresses.isEmpty else { return [] }

        var aliasSet = Set<String>()
        for (address, alias) in conversationPrimaryAliases where normalizedAddresses.contains(address.lowercased()) {
            aliasSet.insert(alias)
        }
        for (address, set) in conversationAliases where normalizedAddresses.contains(address.lowercased()) {
            if let selected = set.sorted().first {
                aliasSet.insert(selected)
            }
        }
        // Include deterministic incoming aliases from routing states
        for (address, state) in routingStates where normalizedAddresses.contains(address.lowercased()) {
            aliasSet.insert(state.deterministicMyAlias)
        }
        return Array(aliasSet)
    }

    private func loadOurAliases() {
        guard let data = userDefaults.data(forKey: ourAliasesKey) else {
            return
        }
        if let decoded = decodeAliasSetMap(from: data) {
            ourAliases = decoded
        } else if let legacy = try? JSONDecoder().decode([String: String].self, from: data) {
            ourAliases = legacy.mapValues { [$0] }.mapValues { Set($0) }
            ourPrimaryAliases = legacy
        }
        if let primaryData = userDefaults.data(forKey: ourPrimaryAliasesKey),
           let primary = try? JSONDecoder().decode([String: String].self, from: primaryData) {
            ourPrimaryAliases = primary
        }
        if let updatedData = userDefaults.data(forKey: ourAliasUpdatedAtKey),
           let updated = try? JSONDecoder().decode([String: UInt64].self, from: updatedData) {
            ourAliasUpdatedAt = updated
        }
        rebuildPrimaryAliasesIfNeeded()
        print("[ChatService] Loaded \(ourAliases.count) of our aliases")
    }

    private func loadConversationIds() {
        guard let data = userDefaults.data(forKey: conversationIdsKey),
              let ids = try? JSONDecoder().decode([String: String].self, from: data) else {
            return
        }
        conversationIds = ids
        print("[ChatService] Loaded \(ids.count) conversation ids")
    }

    private func saveOurAliases() {
        guard let data = try? JSONEncoder().encode(encodeAliasSetMap(ourAliases)) else { return }
        userDefaults.set(data, forKey: ourAliasesKey)
        if let primaryData = try? JSONEncoder().encode(ourPrimaryAliases) {
            userDefaults.set(primaryData, forKey: ourPrimaryAliasesKey)
        }
        if let updatedData = try? JSONEncoder().encode(ourAliasUpdatedAt) {
            userDefaults.set(updatedData, forKey: ourAliasUpdatedAtKey)
        }
    }

    private func saveConversationIds() {
        guard let data = try? JSONEncoder().encode(conversationIds) else { return }
        userDefaults.set(data, forKey: conversationIdsKey)
    }

    // MARK: - Routing State Persistence

    private func loadRoutingStates() {
        guard let data = userDefaults.data(forKey: routingStatesKey) else { return }
        if let decoded = try? JSONDecoder().decode([String: ConversationRoutingState].self, from: data) {
            routingStates = decoded
            print("[ChatService] Loaded \(routingStates.count) routing states")
        }
    }

    private func saveRoutingStates() {
        guard let data = try? JSONEncoder().encode(routingStates) else { return }
        userDefaults.set(data, forKey: routingStatesKey)
    }

    /// Migrate legacy aliases to deterministic routing states.
    /// Called once after self-stash recovery completes (requires private key).
    private func migrateToDeterministicAliases(privateKey: Data) {
        guard !userDefaults.bool(forKey: deterministicMigrationDoneKey) else { return }

        let allContactAddresses = Set(conversationAliases.keys).union(ourAliases.keys).union(
            contactsManager.activeContacts.map { $0.address }
        )

        var migrated = 0
        for address in allContactAddresses {
            if routingStates[address] != nil { continue }  // already has routing state

            let hasLegacyIncoming = !(conversationAliases[address]?.isEmpty ?? true)
            let hasLegacyOutgoing = !(ourAliases[address]?.isEmpty ?? true)
            let hasLegacy = hasLegacyIncoming || hasLegacyOutgoing

            // Derive deterministic pair
            guard let myAlias = try? DeterministicAlias.deriveMyAlias(privateKey: privateKey, theirAddress: address),
                  let theirAlias = try? DeterministicAlias.deriveTheirAlias(privateKey: privateKey, theirAddress: address) else {
                NSLog("[ChatService] Failed to derive deterministic aliases for %@", String(address.suffix(10)))
                continue
            }

            let state = ConversationRoutingState(
                contactAddress: address,
                deterministicMyAlias: myAlias,
                deterministicTheirAlias: theirAlias,
                legacyIncomingAliases: conversationAliases[address] ?? [],
                legacyOutgoingAliases: ourAliases[address] ?? [],
                mode: hasLegacy ? .hybrid : .deterministicOnly,
                peerSupportsDeterministic: false,
                lastLegacyIncomingAtMs: nil,
                lastDeterministicIncomingAtMs: nil
            )
            routingStates[address] = state
            migrated += 1
        }

        if migrated > 0 {
            saveRoutingStates()
            NSLog("[ChatService] Migrated %d contacts to deterministic routing states", migrated)
        }
        userDefaults.set(true, forKey: deterministicMigrationDoneKey)
    }

    /// Ensure a routing state exists for a contact. Creates one on-demand if needed.
    private func ensureRoutingState(for address: String, privateKey: Data?) {
        guard routingStates[address] == nil, let privKey = privateKey else { return }
        guard let myAlias = try? DeterministicAlias.deriveMyAlias(privateKey: privKey, theirAddress: address),
              let theirAlias = try? DeterministicAlias.deriveTheirAlias(privateKey: privKey, theirAddress: address) else {
            return
        }

        let hasLegacyIncoming = !(conversationAliases[address]?.isEmpty ?? true)
        let hasLegacyOutgoing = !(ourAliases[address]?.isEmpty ?? true)

        routingStates[address] = ConversationRoutingState(
            contactAddress: address,
            deterministicMyAlias: myAlias,
            deterministicTheirAlias: theirAlias,
            legacyIncomingAliases: conversationAliases[address] ?? [],
            legacyOutgoingAliases: ourAliases[address] ?? [],
            mode: (hasLegacyIncoming || hasLegacyOutgoing) ? .hybrid : .deterministicOnly,
            peerSupportsDeterministic: false,
            lastLegacyIncomingAtMs: nil,
            lastDeterministicIncomingAtMs: nil
        )
        saveRoutingStates()
    }

    /// Get all incoming aliases (deterministic + legacy) for a contact
    func incomingAliases(for address: String) -> Set<String> {
        guard let state = routingStates[address] else {
            return conversationAliases[address] ?? []
        }
        var aliases: Set<String> = [state.deterministicMyAlias]
        if state.mode != .deterministicOnly {
            aliases.formUnion(state.legacyIncomingAliases)
        }
        return aliases
    }

    /// Get all outgoing fetch aliases (deterministic + legacy) for syncing our sent messages
    func outgoingFetchAliases(for address: String) -> Set<String> {
        guard let state = routingStates[address] else {
            return ourAliases[address] ?? []
        }
        var aliases: Set<String> = [state.deterministicTheirAlias]
        if state.mode != .deterministicOnly {
            aliases.formUnion(state.legacyOutgoingAliases)
        }
        return aliases
    }

    /// Get the outgoing alias to use when sending a new message
    func outgoingAlias(for address: String) -> String {
        guard let state = routingStates[address] else {
            // Fallback to legacy if no routing state
            return primaryOurAlias(for: address) ?? generateAlias()
        }
        switch state.mode {
        case .deterministicOnly:
            return state.deterministicTheirAlias
        case .hybrid:
            return state.peerSupportsDeterministic
                ? state.deterministicTheirAlias
                : state.legacyOutgoingAliases.sorted().first ?? state.deterministicTheirAlias
        case .legacyOnly:
            return state.legacyOutgoingAliases.sorted().first ?? state.deterministicTheirAlias
        }
    }

    /// Check if a routing state exists for a contact
    func hasRoutingState(for address: String) -> Bool {
        routingStates[address] != nil
    }

    private func decodeAliasSetMap(from data: Data) -> [String: Set<String>]? {
        if let decoded = try? JSONDecoder().decode([String: [String]].self, from: data) {
            return decoded.mapValues { Set($0) }
        }
        return nil
    }

    private func encodeAliasSetMap(_ map: [String: Set<String>]) -> [String: [String]] {
        map.mapValues { Array($0) }
    }

    private func rebuildPrimaryAliasesIfNeeded() {
        for (address, aliases) in conversationAliases {
            if let primary = conversationPrimaryAliases[address] {
                if !aliases.contains(primary) {
                    var updated = aliases
                    updated.insert(primary)
                    conversationAliases[address] = updated
                }
                continue
            }
            if let selected = aliases.sorted().first {
                conversationPrimaryAliases[address] = selected
            }
        }
        for (address, aliases) in ourAliases {
            if let primary = ourPrimaryAliases[address] {
                if !aliases.contains(primary) {
                    var updated = aliases
                    updated.insert(primary)
                    ourAliases[address] = updated
                }
                continue
            }
            if let selected = aliases.sorted().first {
                ourPrimaryAliases[address] = selected
            }
        }
    }

    private func loadPendingSelfStash() {
        guard let data = userDefaults.data(forKey: pendingSelfStashKey),
              let jobs = try? JSONDecoder().decode([PendingSelfStash].self, from: data) else {
            pendingSelfStash = []
            return
        }
        pendingSelfStash = jobs
    }

    private func savePendingSelfStash() {
        guard let data = try? JSONEncoder().encode(pendingSelfStash) else { return }
        userDefaults.set(data, forKey: pendingSelfStashKey)
    }

    private func loadDeclinedContacts() {
        guard let data = userDefaults.data(forKey: declinedContactsKey),
              let list = try? JSONDecoder().decode([String].self, from: data) else {
            declinedContacts = []
            return
        }
        declinedContacts = Set(list)
    }

    private func saveDeclinedContacts() {
        let list = Array(declinedContacts)
        guard let data = try? JSONEncoder().encode(list) else { return }
        userDefaults.set(data, forKey: declinedContactsKey)
    }

    private func declineContact(_ address: String) {
        declinedContacts.insert(address)
        saveDeclinedContacts()
    }

    private func clearDeclined(_ address: String) {
        if declinedContacts.remove(address) != nil {
            saveDeclinedContacts()
        }
    }

    // MARK: - Decryption (nonisolated to run off main thread)

    /// Decrypt handshake payload on background thread
    private func decryptHandshakePayload(_ payload: String?, privateKey: Data) async -> DecryptedHandshake? {
        guard let payload = payload else { return nil }
        return await Task.detached(priority: .userInitiated) {
            Self.decryptHandshakePayloadSync(payload, privateKey: privateKey)
        }.value
    }

    /// Synchronous handshake decryption (runs on background thread)
    /// Handles two payload formats:
    /// - Indexer format: just the encrypted hex (no prefix)
    /// - REST API format: full transaction payload hex = hex("ciph_msg:1:handshake:") + encrypted_hex
    private nonisolated static func decryptHandshakePayloadSync(_ payload: String, privateKey: Data) -> DecryptedHandshake? {
        var encryptedHex = payload

        // Strip protocol prefix if present (REST API returns full transaction payload)
        // "ciph_msg:1:handshake:" = 21 bytes = 42 hex chars
        let handshakePrefixHex = "636970685f6d73673a313a68616e647368616b653a"
        let lowered = payload.lowercased()

        // Also handle optional OP_RETURN prefix: "6a" + 1 byte length
        if lowered.hasPrefix("6a") {
            let stripped = String(lowered.dropFirst(4))
            if stripped.hasPrefix(handshakePrefixHex) {
                encryptedHex = String(payload.dropFirst(4 + handshakePrefixHex.count))
            }
        } else if lowered.hasPrefix(handshakePrefixHex) {
            encryptedHex = String(payload.dropFirst(handshakePrefixHex.count))
        }

        // Decrypt the encrypted portion
        if let decrypted = try? KasiaCipher.decryptHex(encryptedHex, privateKey: privateKey) {
            if let data = decrypted.data(using: .utf8),
               let json = try? JSONDecoder().decode(DecryptedHandshake.self, from: data) {
                return json  // alias may be nil for deterministic handshakes
            }
            // Legacy: raw decrypted text is not valid JSON â€” treat as alias-less handshake
            return DecryptedHandshake(alias: nil, type: "handshake")
        }

        // Fallback: try decrypting the raw payload (indexer format without prefix)
        if encryptedHex != payload {
            if let decrypted = try? KasiaCipher.decryptHex(payload, privateKey: privateKey) {
                if let data = decrypted.data(using: .utf8),
                   let json = try? JSONDecoder().decode(DecryptedHandshake.self, from: data) {
                    return json
                }
                return DecryptedHandshake(alias: nil, type: "handshake")
            }
        }

        return nil
    }

    /// Decrypt contextual message on background thread
    private func decryptContextualMessage(_ payload: String?, privateKey: Data) async -> String? {
        guard let payload = payload else { return nil }
        return await Task.detached(priority: .userInitiated) {
            Self.decryptContextualMessageSync(payload, privateKey: privateKey)
        }.value
    }

    /// Synchronous contextual message decryption (runs on background thread)
    /// Expects format: hex(base64(encrypted)) - as returned by indexer
    private nonisolated static func decryptContextualMessageSync(_ payload: String, privateKey: Data) -> String? {
        // Contextual message payload is hex(base64(encrypted))
        // First decode hex to get the base64 string
        guard let base64Data = hexStringToData(payload),
              let base64String = String(data: base64Data, encoding: .utf8) else {
            return nil
        }

        // Then decode base64 to get the encrypted bytes
        guard let encryptedData = Data(base64Encoded: base64String) else {
            return nil
        }

        // Now decrypt
        do {
            guard let encryptedMessage = KasiaCipher.EncryptedMessage(fromBytes: encryptedData) else {
                return nil
            }
            let decrypted = try KasiaCipher.decrypt(encryptedMessage, privateKey: privateKey)
            return decrypted
        } catch {
            return nil
        }
    }

    /// Decrypt contextual message from raw TX payload on background thread
    /// Raw TX payload format: "ciph_msg:1:comm:ALIAS:BASE64_ENCRYPTED" (as returned by REST API)
    private func decryptContextualMessageFromRawPayload(_ payload: String?, privateKey: Data) async -> String? {
        guard let payload = payload else { return nil }
        return await Task.detached(priority: .userInitiated) {
            Self.decryptContextualMessageFromRawPayloadSync(payload, privateKey: privateKey)
        }.value
    }

    /// Synchronous decryption from raw TX payload
    private nonisolated static func decryptContextualMessageFromRawPayloadSync(_ payload: String, privateKey: Data) -> String? {
        // Raw payload from REST API is hex-encoded
        guard let payloadData = hexStringToData(payload),
              let payloadString = String(data: payloadData, encoding: .utf8) else {
            NSLog("[ChatService] Raw payload: failed to decode hex to string")
            return nil
        }

        // Check if it's a contextual message: "ciph_msg:1:comm:ALIAS:BASE64_ENCRYPTED"
        guard payloadString.hasPrefix("ciph_msg:1:comm:") else {
            // Not a contextual message - could be handshake or other type
            if payloadString.hasPrefix("ciph_msg:") {
                NSLog("[ChatService] Raw payload: different message type: %@", String(payloadString.prefix(30)))
            }
            return nil
        }

        // Split by ":" and get the last part (encrypted base64)
        let parts = payloadString.split(separator: ":", maxSplits: 4, omittingEmptySubsequences: false)
        // parts: ["ciph_msg", "1", "comm", "ALIAS", "BASE64_ENCRYPTED"]
        guard parts.count >= 5 else {
            NSLog("[ChatService] Raw payload: unexpected format, parts=%d", parts.count)
            return nil
        }

        let base64String = String(parts[4])
        guard !base64String.isEmpty else {
            NSLog("[ChatService] Raw payload: empty base64 content")
            return nil
        }

        // Decode base64 to get encrypted bytes
        guard let encryptedData = Data(base64Encoded: base64String) else {
            NSLog("[ChatService] Raw payload: failed to decode base64")
            return nil
        }

        // Decrypt
        do {
            guard let encryptedMessage = KasiaCipher.EncryptedMessage(fromBytes: encryptedData) else {
                NSLog("[ChatService] Raw payload: failed to parse encrypted message structure")
                return nil
            }
            let decrypted = try KasiaCipher.decrypt(encryptedMessage, privateKey: privateKey)
            return decrypted
        } catch {
            NSLog("[ChatService] Raw payload: decryption failed: %@", error.localizedDescription)
            return nil
        }
    }

    private nonisolated static func extractContextualAlias(fromRawPayloadString payloadString: String) -> String? {
        guard payloadString.hasPrefix("ciph_msg:1:comm:") else {
            return nil
        }

        let parts = payloadString.split(separator: ":", maxSplits: 4, omittingEmptySubsequences: false)
        guard parts.count >= 5 else {
            NSLog("[ChatService] Raw payload: unexpected format, parts=%d", parts.count)
            return nil
        }

        let alias = String(parts[3])
        if alias.isEmpty {
            NSLog("[ChatService] Raw payload: empty alias")
            return nil
        }

        return alias
    }

    private func decryptPaymentPayloadFromSealedHex(_ payload: String?, privateKey: Data) async -> PaymentPayload? {
        guard let payload = payload else { return nil }
        return await Task.detached(priority: .userInitiated) {
            Self.decryptPaymentPayloadFromSealedHexSync(payload, privateKey: privateKey)
        }.value
    }

    private nonisolated static func decryptPaymentPayloadFromSealedHexSync(_ payload: String, privateKey: Data) -> PaymentPayload? {
        do {
            let decrypted = try KasiaCipher.decryptHex(payload, privateKey: privateKey)
            if let data = decrypted.data(using: .utf8),
               let json = try? JSONDecoder().decode(PaymentPayload.self, from: data) {
                return json
            }
        } catch {
            return nil
        }
        return nil
    }

    private func decryptPaymentPayloadFromRawPayload(_ payload: String?, privateKey: Data) async -> PaymentPayload? {
        guard let payload = payload else { return nil }
        return await Task.detached(priority: .userInitiated) {
            Self.decryptPaymentPayloadFromRawPayloadSync(payload, privateKey: privateKey)
        }.value
    }

    private nonisolated static func decryptPaymentPayloadFromRawPayloadSync(_ payload: String, privateKey: Data) -> PaymentPayload? {
        guard let payloadData = hexStringToData(payload) else {
            NSLog("[ChatService] Raw payload: failed to decode hex for payment")
            return nil
        }

        let prefixV1 = Data("ciph_msg:1:pay:".utf8)
        let prefixLegacy = Data("ciph_msg:pay:".utf8)
        let encryptedBytes: Data

        if payloadData.starts(with: prefixV1) {
            encryptedBytes = Data(payloadData.dropFirst(prefixV1.count))
        } else if payloadData.starts(with: prefixLegacy) {
            encryptedBytes = Data(payloadData.dropFirst(prefixLegacy.count))
        } else {
            return nil
        }

        guard let encryptedMessage = KasiaCipher.EncryptedMessage(fromBytes: encryptedBytes) else {
            return nil
        }

        do {
            let decrypted = try KasiaCipher.decrypt(encryptedMessage, privateKey: privateKey)
            if let data = decrypted.data(using: .utf8),
               let json = try? JSONDecoder().decode(PaymentPayload.self, from: data) {
                return json
            }
        } catch {
            return nil
        }

        return nil
    }

    private nonisolated static func isPaymentRawPayload(_ payload: String) -> Bool {
        guard let payloadData = hexStringToData(payload) else { return false }
        let prefixV1 = Data("ciph_msg:1:pay:".utf8)
        let prefixLegacy = Data("ciph_msg:pay:".utf8)
        return payloadData.starts(with: prefixV1) || payloadData.starts(with: prefixLegacy)
    }

    /// Decrypt self-stash on background thread
    private func decryptSelfStash(_ stashedData: String, privateKey: Data) async -> SavedHandshakeData? {
        return await Task.detached(priority: .userInitiated) {
            Self.decryptSelfStashSync(stashedData, privateKey: privateKey)
        }.value
    }

    /// Synchronous self-stash decryption (runs on background thread)
    private nonisolated static func decryptSelfStashSync(_ stashedData: String, privateKey: Data) -> SavedHandshakeData? {
        // Self-stash data is hex-encoded encrypted JSON
        do {
            let decrypted = try KasiaCipher.decryptHex(stashedData, privateKey: privateKey)

            // Parse JSON to extract saved handshake data
            if let data = decrypted.data(using: .utf8) {
                // Try to parse as SavedHandshakeData directly
                if let savedData = try? JSONDecoder().decode(SavedHandshakeData.self, from: data) {
                    return savedData
                }

                // Try to parse as a flexible JSON structure with Kasia's field names
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    // Extract alias (our alias)
                    let ourAlias = json["alias"] as? String ?? ""

                    // Extract contact address (could be partnerAddress or recipientAddress)
                    let contactAddress = json["partnerAddress"] as? String
                        ?? json["recipientAddress"] as? String
                        ?? json["partner_address"] as? String
                        ?? json["recipient_address"] as? String
                        ?? ""

                    // Extract their alias
                    let theirAlias = json["theirAlias"] as? String
                        ?? json["their_alias"] as? String

                    if !ourAlias.isEmpty && !contactAddress.isEmpty {
                        return SavedHandshakeData(
                            type: json["type"] as? String,
                            alias: ourAlias,
                            timestamp: json["timestamp"] as? UInt64,
                            version: json["version"] as? Int,
                            theirAlias: theirAlias,
                            partnerAddress: contactAddress,
                            recipientAddress: nil,
                            isResponse: json["isResponse"] as? Bool
                        )
                    }
                }
            }

            return nil
        } catch {
            return nil
        }
    }
}

// MARK: - Supporting Types

    private struct CachedConversation: Codable {
        let id: UUID
        let contactAddress: String
        let messages: [ChatMessage]
        let unreadCount: Int
    }

    private struct ChatHistoryArchive: Codable {
        let schemaVersion: Int
        let exportedAt: Date
        let walletAddress: String?
        let conversations: [ChatHistoryArchiveConversation]
    }

    private struct ChatHistoryArchiveConversation: Codable {
        let conversationId: UUID?
        let contactAddress: String
        let contactAlias: String?
        let unreadCount: Int
        let messages: [ChatMessage]
    }

/// Result from resolving transaction info from REST API
struct TransactionResolveInfo {
    let sender: String
    let blockTimeMs: UInt64
    let payload: String?
}

struct KaspaTransactionResponse: Codable {
    let outputs: [KaspaTransactionOutput]
}

struct KaspaTransactionOutput: Codable {
    let scriptPublicKeyAddress: String?

    enum CodingKeys: String, CodingKey {
        case scriptPublicKeyAddress = "script_public_key_address"
    }
}

struct DecryptedHandshake: Codable {
    let alias: String?
    let type: String?
    let timestamp: UInt64?
    let version: Int?
    let conversationId: String?
    let recipientAddress: String?
    let sendToRecipient: Bool?
    let isResponse: Bool?

    enum CodingKeys: String, CodingKey {
        case alias
        case type
        case timestamp
        case version
        case conversationId
        case recipientAddress
        case sendToRecipient
        case isResponse
    }

    init(alias: String?, type: String? = nil, timestamp: UInt64? = nil, version: Int? = nil, conversationId: String? = nil, recipientAddress: String? = nil, sendToRecipient: Bool? = nil, isResponse: Bool? = nil) {
        self.alias = alias
        self.type = type
        self.timestamp = timestamp
        self.version = version
        self.conversationId = conversationId
        self.recipientAddress = recipientAddress
        self.sendToRecipient = sendToRecipient
        self.isResponse = isResponse
    }

    /// Dynamic coding key for dual camelCase/snake_case interop
    private struct DynKey: CodingKey {
        var stringValue: String
        var intValue: Int?
        init(stringValue: String) { self.stringValue = stringValue; self.intValue = nil }
        init?(intValue: Int) { self.stringValue = "\(intValue)"; self.intValue = intValue }
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let dyn = try decoder.container(keyedBy: DynKey.self)
        self.alias = try container.decodeIfPresent(String.self, forKey: .alias)
        self.type = try container.decodeIfPresent(String.self, forKey: .type)
        self.timestamp = try container.decodeIfPresent(UInt64.self, forKey: .timestamp)
        self.version = try container.decodeIfPresent(Int.self, forKey: .version)
        // Dual-key: try camelCase then snake_case
        self.conversationId = try container.decodeIfPresent(String.self, forKey: .conversationId)
            ?? dyn.decodeIfPresent(String.self, forKey: DynKey(stringValue: "conversation_id"))
        self.recipientAddress = try container.decodeIfPresent(String.self, forKey: .recipientAddress)
            ?? dyn.decodeIfPresent(String.self, forKey: DynKey(stringValue: "recipient_address"))
        self.sendToRecipient = try container.decodeIfPresent(Bool.self, forKey: .sendToRecipient)
            ?? dyn.decodeIfPresent(Bool.self, forKey: DynKey(stringValue: "send_to_recipient"))
        self.isResponse = try container.decodeIfPresent(Bool.self, forKey: .isResponse)
            ?? dyn.decodeIfPresent(Bool.self, forKey: DynKey(stringValue: "is_response"))
    }
}

struct PendingSelfStash: Codable, Identifiable, Equatable {
    let id: UUID
    let partnerAddress: String
    let ourAlias: String
    let theirAlias: String?
    let isResponse: Bool

    init(partnerAddress: String, ourAlias: String, theirAlias: String?, isResponse: Bool) {
        self.id = UUID()
        self.partnerAddress = partnerAddress
        self.ourAlias = ourAlias
        self.theirAlias = theirAlias
        self.isResponse = isResponse
    }
}

// MARK: - Kaspa API Transaction Models (for fetching payments directly)

struct KaspaFullTransactionResponse: Codable {
    let transactionId: String
    let inputs: [KaspaFullTxInput]?
    let outputs: [KaspaFullTxOutput]
    let subnetworkId: String?
    let payload: String?
    let blockTime: UInt64?
    let blockHash: [String]?
    let isAccepted: Bool?
    let acceptingBlockHash: String?
    let acceptingBlockBlueScore: UInt64?
    let acceptingBlockTime: UInt64?
    let mass: String?  // API returns as String
    let hash: String?
    let version: UInt16?
    let lockTime: FlexibleUInt64?
    let gas: FlexibleUInt64?

    enum CodingKeys: String, CodingKey {
        case transactionId = "transaction_id"
        case inputs
        case outputs
        case subnetworkId = "subnetwork_id"
        case payload
        case blockTime = "block_time"
        case blockHash = "block_hash"
        case isAccepted = "is_accepted"
        case acceptingBlockHash = "accepting_block_hash"
        case acceptingBlockBlueScore = "accepting_block_blue_score"
        case acceptingBlockTime = "accepting_block_time"
        case mass
        case hash
        case version
        case lockTime = "lock_time"
        case gas
    }
}

struct KaspaFullTxInput: Codable {
    // Flat structure - API returns fields directly, not nested
    let transactionId: String?
    let index: Int?
    let previousOutpointHash: String?
    let previousOutpointIndex: String?  // String in API
    let previousOutpointAddress: String? // Resolved address when using resolve_previous_outpoints
    let previousOutpointAmount: UInt64?
    let signatureScript: String?
    let sequence: FlexibleUInt64?
    let sigOpCount: FlexibleUInt8?

    enum CodingKeys: String, CodingKey {
        case transactionId = "transaction_id"
        case index
        case previousOutpointHash = "previous_outpoint_hash"
        case previousOutpointIndex = "previous_outpoint_index"
        case previousOutpointAddress = "previous_outpoint_address"
        case previousOutpointAmount = "previous_outpoint_amount"
        case signatureScript = "signature_script"
        case sequence
        case sigOpCount = "sig_op_count"
    }
}

/// Flexible decoder that handles both numeric and string representations of UInt64
struct FlexibleUInt64: Codable {
    let value: UInt64

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let intVal = try? container.decode(UInt64.self) {
            value = intVal
        } else if let strVal = try? container.decode(String.self), let parsed = UInt64(strVal) {
            value = parsed
        } else {
            value = 0
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value)
    }
}

/// Flexible decoder that handles both numeric and string representations of UInt8
struct FlexibleUInt8: Codable {
    let value: UInt8

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let intVal = try? container.decode(UInt8.self) {
            value = intVal
        } else if let strVal = try? container.decode(String.self), let parsed = UInt8(strVal) {
            value = parsed
        } else {
            value = 1
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value)
    }
}

struct KaspaFullTxOutput: Codable {
    let transactionId: String?
    let index: Int?
    let amount: UInt64
    let scriptPublicKey: String?  // Simple hex string, not an object
    let scriptPublicKeyAddress: String?
    let scriptPublicKeyType: String?

    enum CodingKeys: String, CodingKey {
        case transactionId = "transaction_id"
        case index
        case amount
        case scriptPublicKey = "script_public_key"
        case scriptPublicKeyAddress = "script_public_key_address"
        case scriptPublicKeyType = "script_public_key_type"
    }
}

actor InFlightResolveTracker {
    private var ids = Set<String>()

    func contains(_ id: String) -> Bool {
        ids.contains(id)
    }

    func insert(_ id: String) {
        ids.insert(id)
    }

    func remove(_ id: String) {
        ids.remove(id)
    }
}
