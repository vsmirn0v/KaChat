// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: p2p.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Protowire_RequestAddressesMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var includeAllSubnetworks: Bool = false

  var subnetworkID: Protowire_SubnetworkId {
    get {return _subnetworkID ?? Protowire_SubnetworkId()}
    set {_subnetworkID = newValue}
  }
  /// Returns true if `subnetworkID` has been explicitly set.
  var hasSubnetworkID: Bool {return self._subnetworkID != nil}
  /// Clears the value of `subnetworkID`. Subsequent reads from it will return its default value.
  mutating func clearSubnetworkID() {self._subnetworkID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subnetworkID: Protowire_SubnetworkId? = nil
}

struct Protowire_AddressesMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addressList: [Protowire_NetAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NetAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Int64 = 0

  var ip: Data = Data()

  var port: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_SubnetworkId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_TransactionMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var inputs: [Protowire_TransactionInput] = []

  var outputs: [Protowire_TransactionOutput] = []

  var lockTime: UInt64 = 0

  var subnetworkID: Protowire_SubnetworkId {
    get {return _subnetworkID ?? Protowire_SubnetworkId()}
    set {_subnetworkID = newValue}
  }
  /// Returns true if `subnetworkID` has been explicitly set.
  var hasSubnetworkID: Bool {return self._subnetworkID != nil}
  /// Clears the value of `subnetworkID`. Subsequent reads from it will return its default value.
  mutating func clearSubnetworkID() {self._subnetworkID = nil}

  var gas: UInt64 = 0

  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subnetworkID: Protowire_SubnetworkId? = nil
}

struct Protowire_TransactionInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var previousOutpoint: Protowire_Outpoint {
    get {return _previousOutpoint ?? Protowire_Outpoint()}
    set {_previousOutpoint = newValue}
  }
  /// Returns true if `previousOutpoint` has been explicitly set.
  var hasPreviousOutpoint: Bool {return self._previousOutpoint != nil}
  /// Clears the value of `previousOutpoint`. Subsequent reads from it will return its default value.
  mutating func clearPreviousOutpoint() {self._previousOutpoint = nil}

  var signatureScript: Data = Data()

  var sequence: UInt64 = 0

  var sigOpCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousOutpoint: Protowire_Outpoint? = nil
}

struct Protowire_Outpoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: Protowire_TransactionId {
    get {return _transactionID ?? Protowire_TransactionId()}
    set {_transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  var hasTransactionID: Bool {return self._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  mutating func clearTransactionID() {self._transactionID = nil}

  var index: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transactionID: Protowire_TransactionId? = nil
}

struct Protowire_TransactionId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_ScriptPublicKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var script: Data = Data()

  var version: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_TransactionOutput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var scriptPublicKey: Protowire_ScriptPublicKey {
    get {return _scriptPublicKey ?? Protowire_ScriptPublicKey()}
    set {_scriptPublicKey = newValue}
  }
  /// Returns true if `scriptPublicKey` has been explicitly set.
  var hasScriptPublicKey: Bool {return self._scriptPublicKey != nil}
  /// Clears the value of `scriptPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearScriptPublicKey() {self._scriptPublicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scriptPublicKey: Protowire_ScriptPublicKey? = nil
}

struct Protowire_BlockMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Protowire_BlockHeader {
    get {return _header ?? Protowire_BlockHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var transactions: [Protowire_TransactionMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Protowire_BlockHeader? = nil
}

struct Protowire_BlockHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var parents: [Protowire_BlockLevelParents] = []

  var hashMerkleRoot: Protowire_Hash {
    get {return _hashMerkleRoot ?? Protowire_Hash()}
    set {_hashMerkleRoot = newValue}
  }
  /// Returns true if `hashMerkleRoot` has been explicitly set.
  var hasHashMerkleRoot: Bool {return self._hashMerkleRoot != nil}
  /// Clears the value of `hashMerkleRoot`. Subsequent reads from it will return its default value.
  mutating func clearHashMerkleRoot() {self._hashMerkleRoot = nil}

  var acceptedIDMerkleRoot: Protowire_Hash {
    get {return _acceptedIDMerkleRoot ?? Protowire_Hash()}
    set {_acceptedIDMerkleRoot = newValue}
  }
  /// Returns true if `acceptedIDMerkleRoot` has been explicitly set.
  var hasAcceptedIDMerkleRoot: Bool {return self._acceptedIDMerkleRoot != nil}
  /// Clears the value of `acceptedIDMerkleRoot`. Subsequent reads from it will return its default value.
  mutating func clearAcceptedIDMerkleRoot() {self._acceptedIDMerkleRoot = nil}

  var utxoCommitment: Protowire_Hash {
    get {return _utxoCommitment ?? Protowire_Hash()}
    set {_utxoCommitment = newValue}
  }
  /// Returns true if `utxoCommitment` has been explicitly set.
  var hasUtxoCommitment: Bool {return self._utxoCommitment != nil}
  /// Clears the value of `utxoCommitment`. Subsequent reads from it will return its default value.
  mutating func clearUtxoCommitment() {self._utxoCommitment = nil}

  var timestamp: Int64 = 0

  var bits: UInt32 = 0

  var nonce: UInt64 = 0

  var daaScore: UInt64 = 0

  var blueWork: Data = Data()

  var pruningPoint: Protowire_Hash {
    get {return _pruningPoint ?? Protowire_Hash()}
    set {_pruningPoint = newValue}
  }
  /// Returns true if `pruningPoint` has been explicitly set.
  var hasPruningPoint: Bool {return self._pruningPoint != nil}
  /// Clears the value of `pruningPoint`. Subsequent reads from it will return its default value.
  mutating func clearPruningPoint() {self._pruningPoint = nil}

  var blueScore: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hashMerkleRoot: Protowire_Hash? = nil
  fileprivate var _acceptedIDMerkleRoot: Protowire_Hash? = nil
  fileprivate var _utxoCommitment: Protowire_Hash? = nil
  fileprivate var _pruningPoint: Protowire_Hash? = nil
}

struct Protowire_BlockLevelParents: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parentHashes: [Protowire_Hash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_Hash: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestBlockLocatorMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var highHash: Protowire_Hash {
    get {return _highHash ?? Protowire_Hash()}
    set {_highHash = newValue}
  }
  /// Returns true if `highHash` has been explicitly set.
  var hasHighHash: Bool {return self._highHash != nil}
  /// Clears the value of `highHash`. Subsequent reads from it will return its default value.
  mutating func clearHighHash() {self._highHash = nil}

  var limit: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _highHash: Protowire_Hash? = nil
}

struct Protowire_BlockLocatorMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashes: [Protowire_Hash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestHeadersMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowHash: Protowire_Hash {
    get {return _lowHash ?? Protowire_Hash()}
    set {_lowHash = newValue}
  }
  /// Returns true if `lowHash` has been explicitly set.
  var hasLowHash: Bool {return self._lowHash != nil}
  /// Clears the value of `lowHash`. Subsequent reads from it will return its default value.
  mutating func clearLowHash() {self._lowHash = nil}

  var highHash: Protowire_Hash {
    get {return _highHash ?? Protowire_Hash()}
    set {_highHash = newValue}
  }
  /// Returns true if `highHash` has been explicitly set.
  var hasHighHash: Bool {return self._highHash != nil}
  /// Clears the value of `highHash`. Subsequent reads from it will return its default value.
  mutating func clearHighHash() {self._highHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lowHash: Protowire_Hash? = nil
  fileprivate var _highHash: Protowire_Hash? = nil
}

struct Protowire_RequestNextHeadersMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_DoneHeadersMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestRelayBlocksMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashes: [Protowire_Hash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestTransactionsMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ids: [Protowire_TransactionId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_TransactionNotFoundMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Protowire_TransactionId {
    get {return _id ?? Protowire_TransactionId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Protowire_TransactionId? = nil
}

struct Protowire_InvRelayBlockMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Protowire_Hash {
    get {return _hash ?? Protowire_Hash()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: Protowire_Hash? = nil
}

struct Protowire_InvTransactionsMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ids: [Protowire_TransactionId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_PingMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_PongMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_VerackMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_VersionMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var protocolVersion: UInt32 = 0

  var services: UInt64 = 0

  var timestamp: Int64 = 0

  var address: Protowire_NetAddress {
    get {return _address ?? Protowire_NetAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var id: Data = Data()

  var userAgent: String = String()

  var disableRelayTx: Bool = false

  var subnetworkID: Protowire_SubnetworkId {
    get {return _subnetworkID ?? Protowire_SubnetworkId()}
    set {_subnetworkID = newValue}
  }
  /// Returns true if `subnetworkID` has been explicitly set.
  var hasSubnetworkID: Bool {return self._subnetworkID != nil}
  /// Clears the value of `subnetworkID`. Subsequent reads from it will return its default value.
  mutating func clearSubnetworkID() {self._subnetworkID = nil}

  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _address: Protowire_NetAddress? = nil
  fileprivate var _subnetworkID: Protowire_SubnetworkId? = nil
}

struct Protowire_RejectMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestPruningPointUTXOSetMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pruningPointHash: Protowire_Hash {
    get {return _pruningPointHash ?? Protowire_Hash()}
    set {_pruningPointHash = newValue}
  }
  /// Returns true if `pruningPointHash` has been explicitly set.
  var hasPruningPointHash: Bool {return self._pruningPointHash != nil}
  /// Clears the value of `pruningPointHash`. Subsequent reads from it will return its default value.
  mutating func clearPruningPointHash() {self._pruningPointHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pruningPointHash: Protowire_Hash? = nil
}

struct Protowire_PruningPointUtxoSetChunkMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outpointAndUtxoEntryPairs: [Protowire_OutpointAndUtxoEntryPair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_OutpointAndUtxoEntryPair: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outpoint: Protowire_Outpoint {
    get {return _outpoint ?? Protowire_Outpoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var utxoEntry: Protowire_UtxoEntry {
    get {return _utxoEntry ?? Protowire_UtxoEntry()}
    set {_utxoEntry = newValue}
  }
  /// Returns true if `utxoEntry` has been explicitly set.
  var hasUtxoEntry: Bool {return self._utxoEntry != nil}
  /// Clears the value of `utxoEntry`. Subsequent reads from it will return its default value.
  mutating func clearUtxoEntry() {self._utxoEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Protowire_Outpoint? = nil
  fileprivate var _utxoEntry: Protowire_UtxoEntry? = nil
}

struct Protowire_UtxoEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: UInt64 = 0

  var scriptPublicKey: Protowire_ScriptPublicKey {
    get {return _scriptPublicKey ?? Protowire_ScriptPublicKey()}
    set {_scriptPublicKey = newValue}
  }
  /// Returns true if `scriptPublicKey` has been explicitly set.
  var hasScriptPublicKey: Bool {return self._scriptPublicKey != nil}
  /// Clears the value of `scriptPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearScriptPublicKey() {self._scriptPublicKey = nil}

  var blockDaaScore: UInt64 = 0

  var isCoinbase: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scriptPublicKey: Protowire_ScriptPublicKey? = nil
}

struct Protowire_RequestNextPruningPointUtxoSetChunkMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_DonePruningPointUtxoSetChunksMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestIBDBlocksMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashes: [Protowire_Hash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_UnexpectedPruningPointMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_IbdBlockLocatorMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetHash: Protowire_Hash {
    get {return _targetHash ?? Protowire_Hash()}
    set {_targetHash = newValue}
  }
  /// Returns true if `targetHash` has been explicitly set.
  var hasTargetHash: Bool {return self._targetHash != nil}
  /// Clears the value of `targetHash`. Subsequent reads from it will return its default value.
  mutating func clearTargetHash() {self._targetHash = nil}

  var blockLocatorHashes: [Protowire_Hash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _targetHash: Protowire_Hash? = nil
}

struct Protowire_RequestIBDChainBlockLocatorMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowHash: Protowire_Hash {
    get {return _lowHash ?? Protowire_Hash()}
    set {_lowHash = newValue}
  }
  /// Returns true if `lowHash` has been explicitly set.
  var hasLowHash: Bool {return self._lowHash != nil}
  /// Clears the value of `lowHash`. Subsequent reads from it will return its default value.
  mutating func clearLowHash() {self._lowHash = nil}

  var highHash: Protowire_Hash {
    get {return _highHash ?? Protowire_Hash()}
    set {_highHash = newValue}
  }
  /// Returns true if `highHash` has been explicitly set.
  var hasHighHash: Bool {return self._highHash != nil}
  /// Clears the value of `highHash`. Subsequent reads from it will return its default value.
  mutating func clearHighHash() {self._highHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lowHash: Protowire_Hash? = nil
  fileprivate var _highHash: Protowire_Hash? = nil
}

struct Protowire_IbdChainBlockLocatorMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockLocatorHashes: [Protowire_Hash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestAnticoneMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHash: Protowire_Hash {
    get {return _blockHash ?? Protowire_Hash()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  var contextHash: Protowire_Hash {
    get {return _contextHash ?? Protowire_Hash()}
    set {_contextHash = newValue}
  }
  /// Returns true if `contextHash` has been explicitly set.
  var hasContextHash: Bool {return self._contextHash != nil}
  /// Clears the value of `contextHash`. Subsequent reads from it will return its default value.
  mutating func clearContextHash() {self._contextHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Protowire_Hash? = nil
  fileprivate var _contextHash: Protowire_Hash? = nil
}

struct Protowire_IbdBlockLocatorHighestHashMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var highestHash: Protowire_Hash {
    get {return _highestHash ?? Protowire_Hash()}
    set {_highestHash = newValue}
  }
  /// Returns true if `highestHash` has been explicitly set.
  var hasHighestHash: Bool {return self._highestHash != nil}
  /// Clears the value of `highestHash`. Subsequent reads from it will return its default value.
  mutating func clearHighestHash() {self._highestHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _highestHash: Protowire_Hash? = nil
}

struct Protowire_IbdBlockLocatorHighestHashNotFoundMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_BlockHeadersMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeaders: [Protowire_BlockHeader] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestPruningPointAndItsAnticoneMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestNextPruningPointAndItsAnticoneBlocksMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_BlockWithTrustedDataMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_BlockMessage {
    get {return _block ?? Protowire_BlockMessage()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var daaScore: UInt64 = 0

  var daaWindow: [Protowire_DaaBlock] = []

  var ghostdagData: [Protowire_BlockGhostdagDataHashPair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Protowire_BlockMessage? = nil
}

struct Protowire_DaaBlock: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_BlockMessage {
    get {return _storage._block ?? Protowire_BlockMessage()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_uniqueStorage()._block = nil}

  var ghostdagData: Protowire_GhostdagData {
    get {return _storage._ghostdagData ?? Protowire_GhostdagData()}
    set {_uniqueStorage()._ghostdagData = newValue}
  }
  /// Returns true if `ghostdagData` has been explicitly set.
  var hasGhostdagData: Bool {return _storage._ghostdagData != nil}
  /// Clears the value of `ghostdagData`. Subsequent reads from it will return its default value.
  mutating func clearGhostdagData() {_uniqueStorage()._ghostdagData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protowire_DaaBlockV4: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Protowire_BlockHeader {
    get {return _storage._header ?? Protowire_BlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  var ghostdagData: Protowire_GhostdagData {
    get {return _storage._ghostdagData ?? Protowire_GhostdagData()}
    set {_uniqueStorage()._ghostdagData = newValue}
  }
  /// Returns true if `ghostdagData` has been explicitly set.
  var hasGhostdagData: Bool {return _storage._ghostdagData != nil}
  /// Clears the value of `ghostdagData`. Subsequent reads from it will return its default value.
  mutating func clearGhostdagData() {_uniqueStorage()._ghostdagData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protowire_BlockGhostdagDataHashPair: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Protowire_Hash {
    get {return _hash ?? Protowire_Hash()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var ghostdagData: Protowire_GhostdagData {
    get {return _ghostdagData ?? Protowire_GhostdagData()}
    set {_ghostdagData = newValue}
  }
  /// Returns true if `ghostdagData` has been explicitly set.
  var hasGhostdagData: Bool {return self._ghostdagData != nil}
  /// Clears the value of `ghostdagData`. Subsequent reads from it will return its default value.
  mutating func clearGhostdagData() {self._ghostdagData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: Protowire_Hash? = nil
  fileprivate var _ghostdagData: Protowire_GhostdagData? = nil
}

struct Protowire_GhostdagData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blueScore: UInt64 = 0

  var blueWork: Data = Data()

  var selectedParent: Protowire_Hash {
    get {return _selectedParent ?? Protowire_Hash()}
    set {_selectedParent = newValue}
  }
  /// Returns true if `selectedParent` has been explicitly set.
  var hasSelectedParent: Bool {return self._selectedParent != nil}
  /// Clears the value of `selectedParent`. Subsequent reads from it will return its default value.
  mutating func clearSelectedParent() {self._selectedParent = nil}

  var mergeSetBlues: [Protowire_Hash] = []

  var mergeSetReds: [Protowire_Hash] = []

  var bluesAnticoneSizes: [Protowire_BluesAnticoneSizes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selectedParent: Protowire_Hash? = nil
}

struct Protowire_BluesAnticoneSizes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blueHash: Protowire_Hash {
    get {return _blueHash ?? Protowire_Hash()}
    set {_blueHash = newValue}
  }
  /// Returns true if `blueHash` has been explicitly set.
  var hasBlueHash: Bool {return self._blueHash != nil}
  /// Clears the value of `blueHash`. Subsequent reads from it will return its default value.
  mutating func clearBlueHash() {self._blueHash = nil}

  var anticoneSize: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blueHash: Protowire_Hash? = nil
}

struct Protowire_DoneBlocksWithTrustedDataMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_PruningPointsMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var headers: [Protowire_BlockHeader] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RequestPruningPointProofMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_PruningPointProofMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var headers: [Protowire_PruningPointProofHeaderArray] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_PruningPointProofHeaderArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var headers: [Protowire_BlockHeader] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_ReadyMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_BlockWithTrustedDataV4Message: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_BlockMessage {
    get {return _block ?? Protowire_BlockMessage()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var daaWindowIndices: [UInt64] = []

  var ghostdagDataIndices: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Protowire_BlockMessage? = nil
}

struct Protowire_TrustedDataMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var daaWindow: [Protowire_DaaBlockV4] = []

  var ghostdagData: [Protowire_BlockGhostdagDataHashPair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protowire"

extension Protowire_RequestAddressesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestAddressesMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}includeAllSubnetworks\0\u{1}subnetworkId\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeAllSubnetworks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subnetworkID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.includeAllSubnetworks != false {
      try visitor.visitSingularBoolField(value: self.includeAllSubnetworks, fieldNumber: 1)
    }
    try { if let v = self._subnetworkID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestAddressesMessage, rhs: Protowire_RequestAddressesMessage) -> Bool {
    if lhs.includeAllSubnetworks != rhs.includeAllSubnetworks {return false}
    if lhs._subnetworkID != rhs._subnetworkID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_AddressesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddressesMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addressList\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.addressList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addressList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_AddressesMessage, rhs: Protowire_AddressesMessage) -> Bool {
    if lhs.addressList != rhs.addressList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NetAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetAddress"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{2}\u{2}ip\0\u{1}port\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ip) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularBytesField(value: self.ip, fieldNumber: 3)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NetAddress, rhs: Protowire_NetAddress) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_SubnetworkId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubnetworkId"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bytes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_SubnetworkId, rhs: Protowire_SubnetworkId) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_TransactionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{1}inputs\0\u{1}outputs\0\u{1}lockTime\0\u{1}subnetworkId\0\u{1}gas\0\u{2}\u{2}payload\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lockTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._subnetworkID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 3)
    }
    if self.lockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockTime, fieldNumber: 4)
    }
    try { if let v = self._subnetworkID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_TransactionMessage, rhs: Protowire_TransactionMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.lockTime != rhs.lockTime {return false}
    if lhs._subnetworkID != rhs._subnetworkID {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_TransactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionInput"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}previousOutpoint\0\u{1}signatureScript\0\u{1}sequence\0\u{1}sigOpCount\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._previousOutpoint) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signatureScript) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sigOpCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousOutpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signatureScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.signatureScript, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    if self.sigOpCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.sigOpCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_TransactionInput, rhs: Protowire_TransactionInput) -> Bool {
    if lhs._previousOutpoint != rhs._previousOutpoint {return false}
    if lhs.signatureScript != rhs.signatureScript {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.sigOpCount != rhs.sigOpCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_Outpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Outpoint"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}transactionId\0\u{1}index\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transactionID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_Outpoint, rhs: Protowire_Outpoint) -> Bool {
    if lhs._transactionID != rhs._transactionID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_TransactionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionId"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bytes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_TransactionId, rhs: Protowire_TransactionId) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_ScriptPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScriptPublicKey"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}script\0\u{1}version\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.script) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.script.isEmpty {
      try visitor.visitSingularBytesField(value: self.script, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_ScriptPublicKey, rhs: Protowire_ScriptPublicKey) -> Bool {
    if lhs.script != rhs.script {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_TransactionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionOutput"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}scriptPublicKey\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scriptPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try { if let v = self._scriptPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_TransactionOutput, rhs: Protowire_TransactionOutput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs._scriptPublicKey != rhs._scriptPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}header\0\u{1}transactions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockMessage, rhs: Protowire_BlockMessage) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{2}\u{2}hashMerkleRoot\0\u{1}acceptedIdMerkleRoot\0\u{1}utxoCommitment\0\u{1}timestamp\0\u{1}bits\0\u{1}nonce\0\u{1}daaScore\0\u{1}blueWork\0\u{2}\u{2}parents\0\u{1}blueScore\0\u{1}pruningPoint\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hashMerkleRoot) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._acceptedIDMerkleRoot) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._utxoCommitment) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.bits) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.daaScore) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.blueWork) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.parents) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._pruningPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._hashMerkleRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._acceptedIDMerkleRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._utxoCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if self.bits != 0 {
      try visitor.visitSingularUInt32Field(value: self.bits, fieldNumber: 7)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 8)
    }
    if self.daaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.daaScore, fieldNumber: 9)
    }
    if !self.blueWork.isEmpty {
      try visitor.visitSingularBytesField(value: self.blueWork, fieldNumber: 10)
    }
    if !self.parents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parents, fieldNumber: 12)
    }
    if self.blueScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 13)
    }
    try { if let v = self._pruningPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockHeader, rhs: Protowire_BlockHeader) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.parents != rhs.parents {return false}
    if lhs._hashMerkleRoot != rhs._hashMerkleRoot {return false}
    if lhs._acceptedIDMerkleRoot != rhs._acceptedIDMerkleRoot {return false}
    if lhs._utxoCommitment != rhs._utxoCommitment {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.bits != rhs.bits {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.daaScore != rhs.daaScore {return false}
    if lhs.blueWork != rhs.blueWork {return false}
    if lhs._pruningPoint != rhs._pruningPoint {return false}
    if lhs.blueScore != rhs.blueScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockLevelParents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockLevelParents"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parentHashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.parentHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parentHashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parentHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockLevelParents, rhs: Protowire_BlockLevelParents) -> Bool {
    if lhs.parentHashes != rhs.parentHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_Hash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hash"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bytes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_Hash, rhs: Protowire_Hash) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestBlockLocatorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestBlockLocatorMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}highHash\0\u{1}limit\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._highHash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._highHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestBlockLocatorMessage, rhs: Protowire_RequestBlockLocatorMessage) -> Bool {
    if lhs._highHash != rhs._highHash {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockLocatorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockLocatorMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockLocatorMessage, rhs: Protowire_BlockLocatorMessage) -> Bool {
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestHeadersMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestHeadersMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lowHash\0\u{1}highHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lowHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._highHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lowHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._highHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestHeadersMessage, rhs: Protowire_RequestHeadersMessage) -> Bool {
    if lhs._lowHash != rhs._lowHash {return false}
    if lhs._highHash != rhs._highHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestNextHeadersMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestNextHeadersMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestNextHeadersMessage, rhs: Protowire_RequestNextHeadersMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_DoneHeadersMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoneHeadersMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_DoneHeadersMessage, rhs: Protowire_DoneHeadersMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestRelayBlocksMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestRelayBlocksMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestRelayBlocksMessage, rhs: Protowire_RequestRelayBlocksMessage) -> Bool {
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestTransactionsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestTransactionsMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ids\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestTransactionsMessage, rhs: Protowire_RequestTransactionsMessage) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_TransactionNotFoundMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionNotFoundMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_TransactionNotFoundMessage, rhs: Protowire_TransactionNotFoundMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_InvRelayBlockMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvRelayBlockMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_InvRelayBlockMessage, rhs: Protowire_InvRelayBlockMessage) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_InvTransactionsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvTransactionsMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ids\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_InvTransactionsMessage, rhs: Protowire_InvTransactionsMessage) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nonce\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PingMessage, rhs: Protowire_PingMessage) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PongMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PongMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nonce\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PongMessage, rhs: Protowire_PongMessage) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_VerackMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerackMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_VerackMessage, rhs: Protowire_VerackMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_VersionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}protocolVersion\0\u{1}services\0\u{1}timestamp\0\u{1}address\0\u{1}id\0\u{1}userAgent\0\u{2}\u{2}disableRelayTx\0\u{1}subnetworkId\0\u{1}network\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.services) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.disableRelayTx) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._subnetworkID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.protocolVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.protocolVersion, fieldNumber: 1)
    }
    if self.services != 0 {
      try visitor.visitSingularUInt64Field(value: self.services, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 5)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 6)
    }
    if self.disableRelayTx != false {
      try visitor.visitSingularBoolField(value: self.disableRelayTx, fieldNumber: 8)
    }
    try { if let v = self._subnetworkID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_VersionMessage, rhs: Protowire_VersionMessage) -> Bool {
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.services != rhs.services {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._address != rhs._address {return false}
    if lhs.id != rhs.id {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.disableRelayTx != rhs.disableRelayTx {return false}
    if lhs._subnetworkID != rhs._subnetworkID {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RejectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RejectMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RejectMessage, rhs: Protowire_RejectMessage) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestPruningPointUTXOSetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestPruningPointUTXOSetMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pruningPointHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pruningPointHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pruningPointHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestPruningPointUTXOSetMessage, rhs: Protowire_RequestPruningPointUTXOSetMessage) -> Bool {
    if lhs._pruningPointHash != rhs._pruningPointHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PruningPointUtxoSetChunkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PruningPointUtxoSetChunkMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}outpointAndUtxoEntryPairs\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outpointAndUtxoEntryPairs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outpointAndUtxoEntryPairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outpointAndUtxoEntryPairs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PruningPointUtxoSetChunkMessage, rhs: Protowire_PruningPointUtxoSetChunkMessage) -> Bool {
    if lhs.outpointAndUtxoEntryPairs != rhs.outpointAndUtxoEntryPairs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_OutpointAndUtxoEntryPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutpointAndUtxoEntryPair"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}outpoint\0\u{1}utxoEntry\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._utxoEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._utxoEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_OutpointAndUtxoEntryPair, rhs: Protowire_OutpointAndUtxoEntryPair) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs._utxoEntry != rhs._utxoEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_UtxoEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxoEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}amount\0\u{1}scriptPublicKey\0\u{1}blockDaaScore\0\u{1}isCoinbase\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scriptPublicKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.blockDaaScore) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isCoinbase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
    }
    try { if let v = self._scriptPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.blockDaaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockDaaScore, fieldNumber: 3)
    }
    if self.isCoinbase != false {
      try visitor.visitSingularBoolField(value: self.isCoinbase, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_UtxoEntry, rhs: Protowire_UtxoEntry) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs._scriptPublicKey != rhs._scriptPublicKey {return false}
    if lhs.blockDaaScore != rhs.blockDaaScore {return false}
    if lhs.isCoinbase != rhs.isCoinbase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestNextPruningPointUtxoSetChunkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestNextPruningPointUtxoSetChunkMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestNextPruningPointUtxoSetChunkMessage, rhs: Protowire_RequestNextPruningPointUtxoSetChunkMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_DonePruningPointUtxoSetChunksMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DonePruningPointUtxoSetChunksMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_DonePruningPointUtxoSetChunksMessage, rhs: Protowire_DonePruningPointUtxoSetChunksMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestIBDBlocksMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestIBDBlocksMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestIBDBlocksMessage, rhs: Protowire_RequestIBDBlocksMessage) -> Bool {
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_UnexpectedPruningPointMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnexpectedPruningPointMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_UnexpectedPruningPointMessage, rhs: Protowire_UnexpectedPruningPointMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_IbdBlockLocatorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IbdBlockLocatorMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}targetHash\0\u{1}blockLocatorHashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._targetHash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blockLocatorHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockLocatorHashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockLocatorHashes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_IbdBlockLocatorMessage, rhs: Protowire_IbdBlockLocatorMessage) -> Bool {
    if lhs._targetHash != rhs._targetHash {return false}
    if lhs.blockLocatorHashes != rhs.blockLocatorHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestIBDChainBlockLocatorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestIBDChainBlockLocatorMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lowHash\0\u{1}highHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lowHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._highHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lowHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._highHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestIBDChainBlockLocatorMessage, rhs: Protowire_RequestIBDChainBlockLocatorMessage) -> Bool {
    if lhs._lowHash != rhs._lowHash {return false}
    if lhs._highHash != rhs._highHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_IbdChainBlockLocatorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IbdChainBlockLocatorMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blockLocatorHashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blockLocatorHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockLocatorHashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockLocatorHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_IbdChainBlockLocatorMessage, rhs: Protowire_IbdChainBlockLocatorMessage) -> Bool {
    if lhs.blockLocatorHashes != rhs.blockLocatorHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestAnticoneMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestAnticoneMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blockHash\0\u{1}contextHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contextHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contextHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestAnticoneMessage, rhs: Protowire_RequestAnticoneMessage) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._contextHash != rhs._contextHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_IbdBlockLocatorHighestHashMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IbdBlockLocatorHighestHashMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}highestHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._highestHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._highestHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_IbdBlockLocatorHighestHashMessage, rhs: Protowire_IbdBlockLocatorHighestHashMessage) -> Bool {
    if lhs._highestHash != rhs._highestHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_IbdBlockLocatorHighestHashNotFoundMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IbdBlockLocatorHighestHashNotFoundMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_IbdBlockLocatorHighestHashNotFoundMessage, rhs: Protowire_IbdBlockLocatorHighestHashNotFoundMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockHeadersMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHeadersMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blockHeaders\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blockHeaders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockHeaders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockHeadersMessage, rhs: Protowire_BlockHeadersMessage) -> Bool {
    if lhs.blockHeaders != rhs.blockHeaders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestPruningPointAndItsAnticoneMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestPruningPointAndItsAnticoneMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestPruningPointAndItsAnticoneMessage, rhs: Protowire_RequestPruningPointAndItsAnticoneMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestNextPruningPointAndItsAnticoneBlocksMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestNextPruningPointAndItsAnticoneBlocksMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestNextPruningPointAndItsAnticoneBlocksMessage, rhs: Protowire_RequestNextPruningPointAndItsAnticoneBlocksMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockWithTrustedDataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockWithTrustedDataMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}block\0\u{1}daaScore\0\u{1}daaWindow\0\u{1}ghostdagData\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.daaScore) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.daaWindow) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ghostdagData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.daaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.daaScore, fieldNumber: 2)
    }
    if !self.daaWindow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.daaWindow, fieldNumber: 3)
    }
    if !self.ghostdagData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ghostdagData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockWithTrustedDataMessage, rhs: Protowire_BlockWithTrustedDataMessage) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.daaScore != rhs.daaScore {return false}
    if lhs.daaWindow != rhs.daaWindow {return false}
    if lhs.ghostdagData != rhs.ghostdagData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_DaaBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaaBlock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}ghostdagData\0\u{1}block\0")

  fileprivate class _StorageClass {
    var _block: Protowire_BlockMessage? = nil
    var _ghostdagData: Protowire_GhostdagData? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
      _ghostdagData = source._ghostdagData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._ghostdagData) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._block) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._ghostdagData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_DaaBlock, rhs: Protowire_DaaBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        if _storage._ghostdagData != rhs_storage._ghostdagData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_DaaBlockV4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaaBlockV4"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}header\0\u{1}ghostdagData\0")

  fileprivate class _StorageClass {
    var _header: Protowire_BlockHeader? = nil
    var _ghostdagData: Protowire_GhostdagData? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _ghostdagData = source._ghostdagData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._ghostdagData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._ghostdagData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_DaaBlockV4, rhs: Protowire_DaaBlockV4) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._ghostdagData != rhs_storage._ghostdagData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockGhostdagDataHashPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockGhostdagDataHashPair"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hash\0\u{1}ghostdagData\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ghostdagData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ghostdagData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockGhostdagDataHashPair, rhs: Protowire_BlockGhostdagDataHashPair) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._ghostdagData != rhs._ghostdagData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GhostdagData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GhostdagData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blueScore\0\u{1}blueWork\0\u{1}selectedParent\0\u{1}mergeSetBlues\0\u{1}mergeSetReds\0\u{1}bluesAnticoneSizes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blueWork) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selectedParent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mergeSetBlues) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.mergeSetReds) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.bluesAnticoneSizes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blueScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 1)
    }
    if !self.blueWork.isEmpty {
      try visitor.visitSingularBytesField(value: self.blueWork, fieldNumber: 2)
    }
    try { if let v = self._selectedParent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.mergeSetBlues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeSetBlues, fieldNumber: 4)
    }
    if !self.mergeSetReds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeSetReds, fieldNumber: 5)
    }
    if !self.bluesAnticoneSizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bluesAnticoneSizes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GhostdagData, rhs: Protowire_GhostdagData) -> Bool {
    if lhs.blueScore != rhs.blueScore {return false}
    if lhs.blueWork != rhs.blueWork {return false}
    if lhs._selectedParent != rhs._selectedParent {return false}
    if lhs.mergeSetBlues != rhs.mergeSetBlues {return false}
    if lhs.mergeSetReds != rhs.mergeSetReds {return false}
    if lhs.bluesAnticoneSizes != rhs.bluesAnticoneSizes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BluesAnticoneSizes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BluesAnticoneSizes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blueHash\0\u{1}anticoneSize\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blueHash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.anticoneSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blueHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.anticoneSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.anticoneSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BluesAnticoneSizes, rhs: Protowire_BluesAnticoneSizes) -> Bool {
    if lhs._blueHash != rhs._blueHash {return false}
    if lhs.anticoneSize != rhs.anticoneSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_DoneBlocksWithTrustedDataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoneBlocksWithTrustedDataMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_DoneBlocksWithTrustedDataMessage, rhs: Protowire_DoneBlocksWithTrustedDataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PruningPointsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PruningPointsMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}headers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PruningPointsMessage, rhs: Protowire_PruningPointsMessage) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RequestPruningPointProofMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestPruningPointProofMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RequestPruningPointProofMessage, rhs: Protowire_RequestPruningPointProofMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PruningPointProofMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PruningPointProofMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}headers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PruningPointProofMessage, rhs: Protowire_PruningPointProofMessage) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PruningPointProofHeaderArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PruningPointProofHeaderArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}headers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PruningPointProofHeaderArray, rhs: Protowire_PruningPointProofHeaderArray) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_ReadyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadyMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_ReadyMessage, rhs: Protowire_ReadyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockWithTrustedDataV4Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockWithTrustedDataV4Message"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}block\0\u{1}daaWindowIndices\0\u{1}ghostdagDataIndices\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.daaWindowIndices) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.ghostdagDataIndices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.daaWindowIndices.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.daaWindowIndices, fieldNumber: 2)
    }
    if !self.ghostdagDataIndices.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.ghostdagDataIndices, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockWithTrustedDataV4Message, rhs: Protowire_BlockWithTrustedDataV4Message) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.daaWindowIndices != rhs.daaWindowIndices {return false}
    if lhs.ghostdagDataIndices != rhs.ghostdagDataIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_TrustedDataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedDataMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}daaWindow\0\u{1}ghostdagData\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.daaWindow) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ghostdagData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.daaWindow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.daaWindow, fieldNumber: 1)
    }
    if !self.ghostdagData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ghostdagData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_TrustedDataMessage, rhs: Protowire_TrustedDataMessage) -> Bool {
    if lhs.daaWindow != rhs.daaWindow {return false}
    if lhs.ghostdagData != rhs.ghostdagData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
