// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// RPC-related types. Request messages, response messages, and dependant types.
///
/// Clients are expected to build RequestMessages and wrap them in KaspadMessage. (see messages.proto)
///
/// Having received a RequestMessage, (wrapped in a KaspadMessage) the RPC server will respond with a
/// ResponseMessage (likewise wrapped in a KaspadMessage) respective to the original RequestMessage.
///
/// **IMPORTANT:** This API is a work in progress and is subject to break between versions.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// RPCError represents a generic non-internal error.
///
/// Receivers of any ResponseMessage are expected to check whether its error field is not null.
struct Protowire_RPCError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcBlock: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Protowire_RpcBlockHeader {
    get {return _storage._header ?? Protowire_RpcBlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  var transactions: [Protowire_RpcTransaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  var verboseData: Protowire_RpcBlockVerboseData {
    get {return _storage._verboseData ?? Protowire_RpcBlockVerboseData()}
    set {_uniqueStorage()._verboseData = newValue}
  }
  /// Returns true if `verboseData` has been explicitly set.
  var hasVerboseData: Bool {return _storage._verboseData != nil}
  /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
  mutating func clearVerboseData() {_uniqueStorage()._verboseData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protowire_RpcBlockHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var parents: [Protowire_RpcBlockLevelParents] = []

  var hashMerkleRoot: String = String()

  var acceptedIDMerkleRoot: String = String()

  var utxoCommitment: String = String()

  var timestamp: Int64 = 0

  var bits: UInt32 = 0

  var nonce: UInt64 = 0

  var daaScore: UInt64 = 0

  var blueWork: String = String()

  var pruningPoint: String = String()

  var blueScore: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcBlockLevelParents: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parentHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcBlockVerboseData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: String = String()

  var difficulty: Double = 0

  var selectedParentHash: String = String()

  var transactionIds: [String] = []

  var isHeaderOnly: Bool = false

  var blueScore: UInt64 = 0

  var childrenHashes: [String] = []

  var mergeSetBluesHashes: [String] = []

  var mergeSetRedsHashes: [String] = []

  var isChainBlock: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var inputs: [Protowire_RpcTransactionInput] = []

  var outputs: [Protowire_RpcTransactionOutput] = []

  var lockTime: UInt64 = 0

  var subnetworkID: String = String()

  var gas: UInt64 = 0

  var payload: String = String()

  var verboseData: Protowire_RpcTransactionVerboseData {
    get {return _verboseData ?? Protowire_RpcTransactionVerboseData()}
    set {_verboseData = newValue}
  }
  /// Returns true if `verboseData` has been explicitly set.
  var hasVerboseData: Bool {return self._verboseData != nil}
  /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
  mutating func clearVerboseData() {self._verboseData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _verboseData: Protowire_RpcTransactionVerboseData? = nil
}

struct Protowire_RpcTransactionInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var previousOutpoint: Protowire_RpcOutpoint {
    get {return _previousOutpoint ?? Protowire_RpcOutpoint()}
    set {_previousOutpoint = newValue}
  }
  /// Returns true if `previousOutpoint` has been explicitly set.
  var hasPreviousOutpoint: Bool {return self._previousOutpoint != nil}
  /// Clears the value of `previousOutpoint`. Subsequent reads from it will return its default value.
  mutating func clearPreviousOutpoint() {self._previousOutpoint = nil}

  var signatureScript: String = String()

  var sequence: UInt64 = 0

  var sigOpCount: UInt32 = 0

  var verboseData: Protowire_RpcTransactionInputVerboseData {
    get {return _verboseData ?? Protowire_RpcTransactionInputVerboseData()}
    set {_verboseData = newValue}
  }
  /// Returns true if `verboseData` has been explicitly set.
  var hasVerboseData: Bool {return self._verboseData != nil}
  /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
  mutating func clearVerboseData() {self._verboseData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousOutpoint: Protowire_RpcOutpoint? = nil
  fileprivate var _verboseData: Protowire_RpcTransactionInputVerboseData? = nil
}

struct Protowire_RpcScriptPublicKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var scriptPublicKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcTransactionOutput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: UInt64 = 0

  var scriptPublicKey: Protowire_RpcScriptPublicKey {
    get {return _scriptPublicKey ?? Protowire_RpcScriptPublicKey()}
    set {_scriptPublicKey = newValue}
  }
  /// Returns true if `scriptPublicKey` has been explicitly set.
  var hasScriptPublicKey: Bool {return self._scriptPublicKey != nil}
  /// Clears the value of `scriptPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearScriptPublicKey() {self._scriptPublicKey = nil}

  var verboseData: Protowire_RpcTransactionOutputVerboseData {
    get {return _verboseData ?? Protowire_RpcTransactionOutputVerboseData()}
    set {_verboseData = newValue}
  }
  /// Returns true if `verboseData` has been explicitly set.
  var hasVerboseData: Bool {return self._verboseData != nil}
  /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
  mutating func clearVerboseData() {self._verboseData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scriptPublicKey: Protowire_RpcScriptPublicKey? = nil
  fileprivate var _verboseData: Protowire_RpcTransactionOutputVerboseData? = nil
}

struct Protowire_RpcOutpoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var index: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcUtxoEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: UInt64 = 0

  var scriptPublicKey: Protowire_RpcScriptPublicKey {
    get {return _scriptPublicKey ?? Protowire_RpcScriptPublicKey()}
    set {_scriptPublicKey = newValue}
  }
  /// Returns true if `scriptPublicKey` has been explicitly set.
  var hasScriptPublicKey: Bool {return self._scriptPublicKey != nil}
  /// Clears the value of `scriptPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearScriptPublicKey() {self._scriptPublicKey = nil}

  var blockDaaScore: UInt64 = 0

  var isCoinbase: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scriptPublicKey: Protowire_RpcScriptPublicKey? = nil
}

struct Protowire_RpcTransactionVerboseData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var hash: String = String()

  var mass: UInt64 = 0

  var blockHash: String = String()

  var blockTime: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcTransactionInputVerboseData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_RpcTransactionOutputVerboseData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scriptPublicKeyType: String = String()

  var scriptPublicKeyAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetCurrentNetworkRequestMessage requests the network kaspad is currently running against.
///
/// Possible networks are: Mainnet, Testnet, Simnet, Devnet
struct Protowire_GetCurrentNetworkRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetCurrentNetworkResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentNetwork: String = String()

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// SubmitBlockRequestMessage requests to submit a block into the DAG.
/// Blocks are generally expected to have been generated using the getBlockTemplate call.
///
/// See: GetBlockTemplateRequestMessage
struct Protowire_SubmitBlockRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_RpcBlock {
    get {return _block ?? Protowire_RpcBlock()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var allowNonDaablocks: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Protowire_RpcBlock? = nil
}

struct Protowire_SubmitBlockResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rejectReason: Protowire_SubmitBlockResponseMessage.RejectReason = .none

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RejectReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case blockInvalid // = 1
    case isInIbd // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .blockInvalid
      case 2: self = .isInIbd
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .blockInvalid: return 1
      case .isInIbd: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Protowire_SubmitBlockResponseMessage.RejectReason] = [
      .none,
      .blockInvalid,
      .isInIbd,
    ]

  }

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlockTemplateRequestMessage requests a current block template.
/// Callers are expected to solve the block template and submit it using the submitBlock call
///
/// See: SubmitBlockRequestMessage
struct Protowire_GetBlockTemplateRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which kaspa address should the coinbase block reward transaction pay into
  var payAddress: String = String()

  var extraData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetBlockTemplateResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_RpcBlock {
    get {return _block ?? Protowire_RpcBlock()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  /// Whether kaspad thinks that it's synced.
  /// Callers are discouraged (but not forbidden) from solving blocks when kaspad is not synced.
  /// That is because when kaspad isn't in sync with the rest of the network there's a high
  /// chance the block will never be accepted, thus the solving effort would have been wasted.
  var isSynced: Bool = false

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Protowire_RpcBlock? = nil
  fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyBlockAddedRequestMessage registers this connection for blockAdded notifications.
///
/// See: BlockAddedNotificationMessage
struct Protowire_NotifyBlockAddedRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyBlockAddedResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// BlockAddedNotificationMessage is sent whenever a blocks has been added (NOT accepted)
/// into the DAG.
///
/// See: NotifyBlockAddedRequestMessage
struct Protowire_BlockAddedNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_RpcBlock {
    get {return _block ?? Protowire_RpcBlock()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Protowire_RpcBlock? = nil
}

/// GetPeerAddressesRequestMessage requests the list of known kaspad addresses in the
/// current network. (mainnet, testnet, etc.)
struct Protowire_GetPeerAddressesRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetPeerAddressesResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [Protowire_GetPeerAddressesKnownAddressMessage] = []

  var bannedAddresses: [Protowire_GetPeerAddressesKnownAddressMessage] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_GetPeerAddressesKnownAddressMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSelectedTipHashRequestMessage requests the hash of the current virtual's
/// selected parent.
struct Protowire_GetSelectedTipHashRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetSelectedTipHashResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selectedTipHash: String = String()

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetMempoolEntryRequestMessage requests information about a specific transaction
/// in the mempool.
struct Protowire_GetMempoolEntryRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction's TransactionID.
  var txID: String = String()

  var includeOrphanPool: Bool = false

  var filterTransactionPool: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetMempoolEntryResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Protowire_MempoolEntry {
    get {return _entry ?? Protowire_MempoolEntry()}
    set {_entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return self._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {self._entry = nil}

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entry: Protowire_MempoolEntry? = nil
  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetMempoolEntriesRequestMessage requests information about all the transactions
/// currently in the mempool.
struct Protowire_GetMempoolEntriesRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var includeOrphanPool: Bool = false

  var filterTransactionPool: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetMempoolEntriesResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Protowire_MempoolEntry] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_MempoolEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fee: UInt64 = 0

  var transaction: Protowire_RpcTransaction {
    get {return _transaction ?? Protowire_RpcTransaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {self._transaction = nil}

  var isOrphan: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transaction: Protowire_RpcTransaction? = nil
}

/// GetConnectedPeerInfoRequestMessage requests information about all the p2p peers
/// currently connected to this kaspad.
struct Protowire_GetConnectedPeerInfoRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetConnectedPeerInfoResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infos: [Protowire_GetConnectedPeerInfoMessage] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_GetConnectedPeerInfoMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var address: String = String()

  /// How long did the last ping/pong exchange take
  var lastPingDuration: Int64 = 0

  /// Whether this kaspad initiated the connection
  var isOutbound: Bool = false

  var timeOffset: Int64 = 0

  var userAgent: String = String()

  /// The protocol version that this peer claims to support
  var advertisedProtocolVersion: UInt32 = 0

  /// The timestamp of when this peer connected to this kaspad
  var timeConnected: Int64 = 0

  /// Whether this peer is the IBD peer (if IBD is running)
  var isIbdPeer: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AddPeerRequestMessage adds a peer to kaspad's outgoing connection list.
/// This will, in most cases, result in kaspad connecting to said peer.
struct Protowire_AddPeerRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  /// Whether to keep attempting to connect to this peer after disconnection
  var isPermanent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_AddPeerResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// SubmitTransactionRequestMessage submits a transaction to the mempool
struct Protowire_SubmitTransactionRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: Protowire_RpcTransaction {
    get {return _transaction ?? Protowire_RpcTransaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {self._transaction = nil}

  var allowOrphan: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transaction: Protowire_RpcTransaction? = nil
}

struct Protowire_SubmitTransactionResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction ID of the submitted transaction
  var transactionID: String = String()

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyVirtualSelectedParentChainChangedRequestMessage registers this connection for virtualSelectedParentChainChanged notifications.
///
/// See: VirtualSelectedParentChainChangedNotificationMessage
struct Protowire_NotifyVirtualSelectedParentChainChangedRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var includeAcceptedTransactionIds: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyVirtualSelectedParentChainChangedResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// VirtualSelectedParentChainChangedNotificationMessage is sent whenever the DAG's selected parent
/// chain had changed.
///
/// See: NotifyVirtualSelectedParentChainChangedRequestMessage
struct Protowire_VirtualSelectedParentChainChangedNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The chain blocks that were removed, in high-to-low order
  var removedChainBlockHashes: [String] = []

  /// The chain blocks that were added, in low-to-high order
  var addedChainBlockHashes: [String] = []

  /// Will be filled only if `includeAcceptedTransactionIds = true` in the notify request.
  var acceptedTransactionIds: [Protowire_AcceptedTransactionIds] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetBlockRequestMessage requests information about a specific block
struct Protowire_GetBlockRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the requested block
  var hash: String = String()

  /// Whether to include transaction data in the response
  var includeTransactions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetBlockResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Protowire_RpcBlock {
    get {return _block ?? Protowire_RpcBlock()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Protowire_RpcBlock? = nil
  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetSubnetworkRequestMessage requests information about a specific subnetwork
///
/// Currently unimplemented
struct Protowire_GetSubnetworkRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subnetworkID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetSubnetworkResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gasLimit: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetVirtualSelectedParentChainFromBlockRequestMessage requests the virtual selected
/// parent chain from some startHash to this kaspad's current virtual
struct Protowire_GetVirtualSelectedParentChainFromBlockRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startHash: String = String()

  var includeAcceptedTransactionIds: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_AcceptedTransactionIds: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var acceptingBlockHash: String = String()

  var acceptedTransactionIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetVirtualSelectedParentChainFromBlockResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The chain blocks that were removed, in high-to-low order
  var removedChainBlockHashes: [String] = []

  /// The chain blocks that were added, in low-to-high order
  var addedChainBlockHashes: [String] = []

  /// The transactions accepted by each block in addedChainBlockHashes.
  /// Will be filled only if `includeAcceptedTransactionIds = true` in the request.
  var acceptedTransactionIds: [Protowire_AcceptedTransactionIds] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlocksRequestMessage requests blocks between a certain block lowHash up to this
/// kaspad's current virtual.
struct Protowire_GetBlocksRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowHash: String = String()

  var includeBlocks: Bool = false

  var includeTransactions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetBlocksResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHashes: [String] = []

  var blocks: [Protowire_RpcBlock] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlockCountRequestMessage requests the current number of blocks in this kaspad.
/// Note that this number may decrease as pruning occurs.
struct Protowire_GetBlockCountRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetBlockCountResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockCount: UInt64 = 0

  var headerCount: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlockDagInfoRequestMessage requests general information about the current state
/// of this kaspad's DAG.
struct Protowire_GetBlockDagInfoRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetBlockDagInfoResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkName: String = String()

  var blockCount: UInt64 = 0

  var headerCount: UInt64 = 0

  var tipHashes: [String] = []

  var difficulty: Double = 0

  var pastMedianTime: Int64 = 0

  var virtualParentHashes: [String] = []

  var pruningPointHash: String = String()

  var virtualDaaScore: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_ResolveFinalityConflictRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var finalityBlockHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_ResolveFinalityConflictResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_NotifyFinalityConflictsRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyFinalityConflictsResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_FinalityConflictNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var violatingBlockHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_FinalityConflictResolvedNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var finalityBlockHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ShutDownRequestMessage shuts down this kaspad.
struct Protowire_ShutDownRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_ShutDownResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetHeadersRequestMessage requests headers between the given startHash and the
/// current virtual, up to the given limit.
struct Protowire_GetHeadersRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startHash: String = String()

  var limit: UInt64 = 0

  var isAscending: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetHeadersResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var headers: [String] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyUtxosChangedRequestMessage registers this connection for utxoChanged notifications
/// for the given addresses.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: UtxosChangedNotificationMessage
struct Protowire_NotifyUtxosChangedRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Leave empty to get all updates
  var addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyUtxosChangedResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// UtxosChangedNotificationMessage is sent whenever the UTXO index had been updated.
///
/// See: NotifyUtxosChangedRequestMessage
struct Protowire_UtxosChangedNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var added: [Protowire_UtxosByAddressesEntry] = []

  var removed: [Protowire_UtxosByAddressesEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_UtxosByAddressesEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var outpoint: Protowire_RpcOutpoint {
    get {return _outpoint ?? Protowire_RpcOutpoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var utxoEntry: Protowire_RpcUtxoEntry {
    get {return _utxoEntry ?? Protowire_RpcUtxoEntry()}
    set {_utxoEntry = newValue}
  }
  /// Returns true if `utxoEntry` has been explicitly set.
  var hasUtxoEntry: Bool {return self._utxoEntry != nil}
  /// Clears the value of `utxoEntry`. Subsequent reads from it will return its default value.
  mutating func clearUtxoEntry() {self._utxoEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Protowire_RpcOutpoint? = nil
  fileprivate var _utxoEntry: Protowire_RpcUtxoEntry? = nil
}

/// StopNotifyingUtxosChangedRequestMessage unregisters this connection for utxoChanged notifications
/// for the given addresses.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: UtxosChangedNotificationMessage
struct Protowire_StopNotifyingUtxosChangedRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_StopNotifyingUtxosChangedResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetUtxosByAddressesRequestMessage requests all current UTXOs for the given kaspad addresses
///
/// This call is only available when this kaspad was started with `--utxoindex`
struct Protowire_GetUtxosByAddressesRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetUtxosByAddressesResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Protowire_UtxosByAddressesEntry] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBalanceByAddressRequest returns the total balance in unspent transactions towards a given address
/// 
/// This call is only available when this kaspad was started with `--utxoindex`
struct Protowire_GetBalanceByAddressRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetBalanceByAddressResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var balance: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_GetBalancesByAddressesRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_BalancesByAddressEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var balance: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_GetBalancesByAddressesResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Protowire_BalancesByAddressEntry] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetVirtualSelectedParentBlueScoreRequestMessage requests the blue score of the current selected parent
/// of the virtual block.
struct Protowire_GetVirtualSelectedParentBlueScoreRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetVirtualSelectedParentBlueScoreResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blueScore: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyVirtualSelectedParentBlueScoreChangedRequestMessage registers this connection for
/// virtualSelectedParentBlueScoreChanged notifications.
///
/// See: VirtualSelectedParentBlueScoreChangedNotificationMessage
struct Protowire_NotifyVirtualSelectedParentBlueScoreChangedRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyVirtualSelectedParentBlueScoreChangedResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// VirtualSelectedParentBlueScoreChangedNotificationMessage is sent whenever the blue score
/// of the virtual's selected parent changes.
///
/// See NotifyVirtualSelectedParentBlueScoreChangedRequestMessage
struct Protowire_VirtualSelectedParentBlueScoreChangedNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var virtualSelectedParentBlueScore: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NotifyVirtualDaaScoreChangedRequestMessage registers this connection for
/// virtualDaaScoreChanged notifications.
///
/// See: VirtualDaaScoreChangedNotificationMessage
struct Protowire_NotifyVirtualDaaScoreChangedRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyVirtualDaaScoreChangedResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// VirtualDaaScoreChangedNotificationMessage is sent whenever the DAA score
/// of the virtual changes.
///
/// See NotifyVirtualDaaScoreChangedRequestMessage
struct Protowire_VirtualDaaScoreChangedNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var virtualDaaScore: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NotifyPruningPointUTXOSetOverrideRequestMessage registers this connection for
/// pruning point UTXO set override notifications.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: NotifyPruningPointUTXOSetOverrideResponseMessage
struct Protowire_NotifyPruningPointUTXOSetOverrideRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyPruningPointUTXOSetOverrideResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// PruningPointUTXOSetOverrideNotificationMessage is sent whenever the UTXO index
/// resets due to pruning point change via IBD.
///
/// See NotifyPruningPointUTXOSetOverrideRequestMessage
struct Protowire_PruningPointUTXOSetOverrideNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// StopNotifyingPruningPointUTXOSetOverrideRequestMessage unregisters this connection for
/// pruning point UTXO set override notifications.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: PruningPointUTXOSetOverrideNotificationMessage
struct Protowire_StopNotifyingPruningPointUTXOSetOverrideRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_StopNotifyingPruningPointUTXOSetOverrideResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// BanRequestMessage bans the given ip.
struct Protowire_BanRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_BanResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// UnbanRequestMessage unbans the given ip.
struct Protowire_UnbanRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_UnbanResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// GetInfoRequestMessage returns info about the node.
struct Protowire_GetInfoRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetInfoResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var p2PID: String = String()

  var mempoolSize: UInt64 = 0

  var serverVersion: String = String()

  var isUtxoIndexed: Bool = false

  var isSynced: Bool = false

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_EstimateNetworkHashesPerSecondRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var windowSize: UInt32 = 0

  var startHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_EstimateNetworkHashesPerSecondResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkHashesPerSecond: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyNewBlockTemplateRequestMessage registers this connection for
/// NewBlockTemplate notifications.
///
/// See: NewBlockTemplateNotificationMessage
struct Protowire_NotifyNewBlockTemplateRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_NotifyNewBlockTemplateResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

/// NewBlockTemplateNotificationMessage is sent whenever a new updated block template is
/// available for miners.
///
/// See NotifyNewBlockTemplateRequestMessage
struct Protowire_NewBlockTemplateNotificationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_MempoolEntryByAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var sending: [Protowire_MempoolEntry] = []

  var receiving: [Protowire_MempoolEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetMempoolEntriesByAddressesRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [String] = []

  var includeOrphanPool: Bool = false

  var filterTransactionPool: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetMempoolEntriesByAddressesResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Protowire_MempoolEntryByAddress] = []

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

struct Protowire_GetCoinSupplyRequestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protowire_GetCoinSupplyResponseMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// note: this is a hard coded maxSupply, actual maxSupply is expected to deviate by upto -5%, but cannot be measured exactly.
  var maxSompi: UInt64 = 0

  var circulatingSompi: UInt64 = 0

  var error: Protowire_RPCError {
    get {return _error ?? Protowire_RPCError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Protowire_RPCError? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protowire"

extension Protowire_RPCError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCError"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RPCError, rhs: Protowire_RPCError) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcBlock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}header\0\u{1}transactions\0\u{1}verboseData\0")

  fileprivate class _StorageClass {
    var _header: Protowire_RpcBlockHeader? = nil
    var _transactions: [Protowire_RpcTransaction] = []
    var _verboseData: Protowire_RpcBlockVerboseData? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _transactions = source._transactions
      _verboseData = source._verboseData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._transactions) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._verboseData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 2)
      }
      try { if let v = _storage._verboseData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcBlock, rhs: Protowire_RpcBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        if _storage._verboseData != rhs_storage._verboseData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcBlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcBlockHeader"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{2}\u{2}hashMerkleRoot\0\u{1}acceptedIdMerkleRoot\0\u{1}utxoCommitment\0\u{1}timestamp\0\u{1}bits\0\u{1}nonce\0\u{1}daaScore\0\u{1}blueWork\0\u{2}\u{2}parents\0\u{1}blueScore\0\u{1}pruningPoint\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hashMerkleRoot) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.acceptedIDMerkleRoot) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.utxoCommitment) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.bits) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.daaScore) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.blueWork) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.parents) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.pruningPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.hashMerkleRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.hashMerkleRoot, fieldNumber: 3)
    }
    if !self.acceptedIDMerkleRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.acceptedIDMerkleRoot, fieldNumber: 4)
    }
    if !self.utxoCommitment.isEmpty {
      try visitor.visitSingularStringField(value: self.utxoCommitment, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if self.bits != 0 {
      try visitor.visitSingularUInt32Field(value: self.bits, fieldNumber: 7)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 8)
    }
    if self.daaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.daaScore, fieldNumber: 9)
    }
    if !self.blueWork.isEmpty {
      try visitor.visitSingularStringField(value: self.blueWork, fieldNumber: 10)
    }
    if !self.parents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parents, fieldNumber: 12)
    }
    if self.blueScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 13)
    }
    if !self.pruningPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.pruningPoint, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcBlockHeader, rhs: Protowire_RpcBlockHeader) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.parents != rhs.parents {return false}
    if lhs.hashMerkleRoot != rhs.hashMerkleRoot {return false}
    if lhs.acceptedIDMerkleRoot != rhs.acceptedIDMerkleRoot {return false}
    if lhs.utxoCommitment != rhs.utxoCommitment {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.bits != rhs.bits {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.daaScore != rhs.daaScore {return false}
    if lhs.blueWork != rhs.blueWork {return false}
    if lhs.pruningPoint != rhs.pruningPoint {return false}
    if lhs.blueScore != rhs.blueScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcBlockLevelParents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcBlockLevelParents"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parentHashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.parentHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parentHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parentHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcBlockLevelParents, rhs: Protowire_RpcBlockLevelParents) -> Bool {
    if lhs.parentHashes != rhs.parentHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcBlockVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcBlockVerboseData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hash\0\u{2}\u{a}difficulty\0\u{2}\u{2}selectedParentHash\0\u{1}transactionIds\0\u{1}isHeaderOnly\0\u{1}blueScore\0\u{1}childrenHashes\0\u{1}mergeSetBluesHashes\0\u{1}mergeSetRedsHashes\0\u{1}isChainBlock\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.selectedParentHash) }()
      case 14: try { try decoder.decodeRepeatedStringField(value: &self.transactionIds) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.isHeaderOnly) }()
      case 16: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
      case 17: try { try decoder.decodeRepeatedStringField(value: &self.childrenHashes) }()
      case 18: try { try decoder.decodeRepeatedStringField(value: &self.mergeSetBluesHashes) }()
      case 19: try { try decoder.decodeRepeatedStringField(value: &self.mergeSetRedsHashes) }()
      case 20: try { try decoder.decodeSingularBoolField(value: &self.isChainBlock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.difficulty.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 11)
    }
    if !self.selectedParentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.selectedParentHash, fieldNumber: 13)
    }
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 14)
    }
    if self.isHeaderOnly != false {
      try visitor.visitSingularBoolField(value: self.isHeaderOnly, fieldNumber: 15)
    }
    if self.blueScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 16)
    }
    if !self.childrenHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.childrenHashes, fieldNumber: 17)
    }
    if !self.mergeSetBluesHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mergeSetBluesHashes, fieldNumber: 18)
    }
    if !self.mergeSetRedsHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mergeSetRedsHashes, fieldNumber: 19)
    }
    if self.isChainBlock != false {
      try visitor.visitSingularBoolField(value: self.isChainBlock, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcBlockVerboseData, rhs: Protowire_RpcBlockVerboseData) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.difficulty != rhs.difficulty {return false}
    if lhs.selectedParentHash != rhs.selectedParentHash {return false}
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.isHeaderOnly != rhs.isHeaderOnly {return false}
    if lhs.blueScore != rhs.blueScore {return false}
    if lhs.childrenHashes != rhs.childrenHashes {return false}
    if lhs.mergeSetBluesHashes != rhs.mergeSetBluesHashes {return false}
    if lhs.mergeSetRedsHashes != rhs.mergeSetRedsHashes {return false}
    if lhs.isChainBlock != rhs.isChainBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{1}inputs\0\u{1}outputs\0\u{1}lockTime\0\u{1}subnetworkId\0\u{1}gas\0\u{2}\u{2}payload\0\u{1}verboseData\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lockTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subnetworkID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._verboseData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 3)
    }
    if self.lockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockTime, fieldNumber: 4)
    }
    if !self.subnetworkID.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetworkID, fieldNumber: 5)
    }
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 8)
    }
    try { if let v = self._verboseData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcTransaction, rhs: Protowire_RpcTransaction) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.lockTime != rhs.lockTime {return false}
    if lhs.subnetworkID != rhs.subnetworkID {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._verboseData != rhs._verboseData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcTransactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcTransactionInput"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}previousOutpoint\0\u{1}signatureScript\0\u{1}sequence\0\u{1}verboseData\0\u{1}sigOpCount\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._previousOutpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signatureScript) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._verboseData) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.sigOpCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousOutpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signatureScript.isEmpty {
      try visitor.visitSingularStringField(value: self.signatureScript, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    try { if let v = self._verboseData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.sigOpCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.sigOpCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcTransactionInput, rhs: Protowire_RpcTransactionInput) -> Bool {
    if lhs._previousOutpoint != rhs._previousOutpoint {return false}
    if lhs.signatureScript != rhs.signatureScript {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.sigOpCount != rhs.sigOpCount {return false}
    if lhs._verboseData != rhs._verboseData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcScriptPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcScriptPublicKey"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{1}scriptPublicKey\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scriptPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.scriptPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptPublicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcScriptPublicKey, rhs: Protowire_RpcScriptPublicKey) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.scriptPublicKey != rhs.scriptPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcTransactionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcTransactionOutput"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}amount\0\u{1}scriptPublicKey\0\u{1}verboseData\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scriptPublicKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._verboseData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
    }
    try { if let v = self._scriptPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._verboseData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcTransactionOutput, rhs: Protowire_RpcTransactionOutput) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs._scriptPublicKey != rhs._scriptPublicKey {return false}
    if lhs._verboseData != rhs._verboseData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcOutpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcOutpoint"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}transactionId\0\u{1}index\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcOutpoint, rhs: Protowire_RpcOutpoint) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcUtxoEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcUtxoEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}amount\0\u{1}scriptPublicKey\0\u{1}blockDaaScore\0\u{1}isCoinbase\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scriptPublicKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.blockDaaScore) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isCoinbase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
    }
    try { if let v = self._scriptPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.blockDaaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockDaaScore, fieldNumber: 3)
    }
    if self.isCoinbase != false {
      try visitor.visitSingularBoolField(value: self.isCoinbase, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcUtxoEntry, rhs: Protowire_RpcUtxoEntry) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs._scriptPublicKey != rhs._scriptPublicKey {return false}
    if lhs.blockDaaScore != rhs.blockDaaScore {return false}
    if lhs.isCoinbase != rhs.isCoinbase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcTransactionVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcTransactionVerboseData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}transactionId\0\u{1}hash\0\u{2}\u{2}mass\0\u{2}\u{8}blockHash\0\u{2}\u{2}blockTime\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.mass) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.blockHash) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self.blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    if self.mass != 0 {
      try visitor.visitSingularUInt64Field(value: self.mass, fieldNumber: 4)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 12)
    }
    if self.blockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockTime, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcTransactionVerboseData, rhs: Protowire_RpcTransactionVerboseData) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.mass != rhs.mass {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.blockTime != rhs.blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcTransactionInputVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcTransactionInputVerboseData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcTransactionInputVerboseData, rhs: Protowire_RpcTransactionInputVerboseData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_RpcTransactionOutputVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcTransactionOutputVerboseData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{5}scriptPublicKeyType\0\u{1}scriptPublicKeyAddress\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularStringField(value: &self.scriptPublicKeyType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.scriptPublicKeyAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scriptPublicKeyType.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptPublicKeyType, fieldNumber: 5)
    }
    if !self.scriptPublicKeyAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptPublicKeyAddress, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_RpcTransactionOutputVerboseData, rhs: Protowire_RpcTransactionOutputVerboseData) -> Bool {
    if lhs.scriptPublicKeyType != rhs.scriptPublicKeyType {return false}
    if lhs.scriptPublicKeyAddress != rhs.scriptPublicKeyAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetCurrentNetworkRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCurrentNetworkRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetCurrentNetworkRequestMessage, rhs: Protowire_GetCurrentNetworkRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetCurrentNetworkResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCurrentNetworkResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}currentNetwork\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currentNetwork) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currentNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.currentNetwork, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetCurrentNetworkResponseMessage, rhs: Protowire_GetCurrentNetworkResponseMessage) -> Bool {
    if lhs.currentNetwork != rhs.currentNetwork {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_SubmitBlockRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitBlockRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}block\0\u{1}allowNonDAABlocks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowNonDaablocks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.allowNonDaablocks != false {
      try visitor.visitSingularBoolField(value: self.allowNonDaablocks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_SubmitBlockRequestMessage, rhs: Protowire_SubmitBlockRequestMessage) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.allowNonDaablocks != rhs.allowNonDaablocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_SubmitBlockResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitBlockResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rejectReason\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.rejectReason) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.rejectReason != .none {
      try visitor.visitSingularEnumField(value: self.rejectReason, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_SubmitBlockResponseMessage, rhs: Protowire_SubmitBlockResponseMessage) -> Bool {
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_SubmitBlockResponseMessage.RejectReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}BLOCK_INVALID\0\u{1}IS_IN_IBD\0")
}

extension Protowire_GetBlockTemplateRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockTemplateRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payAddress\0\u{1}extraData\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.payAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.extraData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.payAddress, fieldNumber: 1)
    }
    if !self.extraData.isEmpty {
      try visitor.visitSingularStringField(value: self.extraData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockTemplateRequestMessage, rhs: Protowire_GetBlockTemplateRequestMessage) -> Bool {
    if lhs.payAddress != rhs.payAddress {return false}
    if lhs.extraData != rhs.extraData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockTemplateResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockTemplateResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}isSynced\0\u{1}block\0\u{2}e\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isSynced) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isSynced != false {
      try visitor.visitSingularBoolField(value: self.isSynced, fieldNumber: 2)
    }
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockTemplateResponseMessage, rhs: Protowire_GetBlockTemplateResponseMessage) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.isSynced != rhs.isSynced {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyBlockAddedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyBlockAddedRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyBlockAddedRequestMessage, rhs: Protowire_NotifyBlockAddedRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyBlockAddedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyBlockAddedResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyBlockAddedResponseMessage, rhs: Protowire_NotifyBlockAddedResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BlockAddedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockAddedNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}block\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BlockAddedNotificationMessage, rhs: Protowire_BlockAddedNotificationMessage) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetPeerAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPeerAddressesRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetPeerAddressesRequestMessage, rhs: Protowire_GetPeerAddressesRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetPeerAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPeerAddressesResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0\u{1}bannedAddresses\0\u{2}f\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bannedAddresses) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
    }
    if !self.bannedAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bannedAddresses, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetPeerAddressesResponseMessage, rhs: Protowire_GetPeerAddressesResponseMessage) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.bannedAddresses != rhs.bannedAddresses {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetPeerAddressesKnownAddressMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPeerAddressesKnownAddressMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Addr\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetPeerAddressesKnownAddressMessage, rhs: Protowire_GetPeerAddressesKnownAddressMessage) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetSelectedTipHashRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSelectedTipHashRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetSelectedTipHashRequestMessage, rhs: Protowire_GetSelectedTipHashRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetSelectedTipHashResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSelectedTipHashResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}selectedTipHash\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.selectedTipHash) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.selectedTipHash.isEmpty {
      try visitor.visitSingularStringField(value: self.selectedTipHash, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetSelectedTipHashResponseMessage, rhs: Protowire_GetSelectedTipHashResponseMessage) -> Bool {
    if lhs.selectedTipHash != rhs.selectedTipHash {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetMempoolEntryRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolEntryRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}txId\0\u{1}includeOrphanPool\0\u{1}filterTransactionPool\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeOrphanPool) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.filterTransactionPool) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
    }
    if self.includeOrphanPool != false {
      try visitor.visitSingularBoolField(value: self.includeOrphanPool, fieldNumber: 2)
    }
    if self.filterTransactionPool != false {
      try visitor.visitSingularBoolField(value: self.filterTransactionPool, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetMempoolEntryRequestMessage, rhs: Protowire_GetMempoolEntryRequestMessage) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.includeOrphanPool != rhs.includeOrphanPool {return false}
    if lhs.filterTransactionPool != rhs.filterTransactionPool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetMempoolEntryResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolEntryResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entry\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetMempoolEntryResponseMessage, rhs: Protowire_GetMempoolEntryResponseMessage) -> Bool {
    if lhs._entry != rhs._entry {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetMempoolEntriesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}includeOrphanPool\0\u{1}filterTransactionPool\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeOrphanPool) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.filterTransactionPool) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeOrphanPool != false {
      try visitor.visitSingularBoolField(value: self.includeOrphanPool, fieldNumber: 1)
    }
    if self.filterTransactionPool != false {
      try visitor.visitSingularBoolField(value: self.filterTransactionPool, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetMempoolEntriesRequestMessage, rhs: Protowire_GetMempoolEntriesRequestMessage) -> Bool {
    if lhs.includeOrphanPool != rhs.includeOrphanPool {return false}
    if lhs.filterTransactionPool != rhs.filterTransactionPool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetMempoolEntriesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetMempoolEntriesResponseMessage, rhs: Protowire_GetMempoolEntriesResponseMessage) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_MempoolEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MempoolEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fee\0\u{2}\u{2}transaction\0\u{1}isOrphan\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isOrphan) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 1)
    }
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.isOrphan != false {
      try visitor.visitSingularBoolField(value: self.isOrphan, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_MempoolEntry, rhs: Protowire_MempoolEntry) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.isOrphan != rhs.isOrphan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetConnectedPeerInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectedPeerInfoRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetConnectedPeerInfoRequestMessage, rhs: Protowire_GetConnectedPeerInfoRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetConnectedPeerInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectedPeerInfoResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}infos\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetConnectedPeerInfoResponseMessage, rhs: Protowire_GetConnectedPeerInfoResponseMessage) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetConnectedPeerInfoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectedPeerInfoMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}address\0\u{1}lastPingDuration\0\u{2}\u{3}isOutbound\0\u{1}timeOffset\0\u{1}userAgent\0\u{1}advertisedProtocolVersion\0\u{1}timeConnected\0\u{1}isIbdPeer\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastPingDuration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isOutbound) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.timeOffset) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.advertisedProtocolVersion) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.timeConnected) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isIbdPeer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.lastPingDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.lastPingDuration, fieldNumber: 3)
    }
    if self.isOutbound != false {
      try visitor.visitSingularBoolField(value: self.isOutbound, fieldNumber: 6)
    }
    if self.timeOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.timeOffset, fieldNumber: 7)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 8)
    }
    if self.advertisedProtocolVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.advertisedProtocolVersion, fieldNumber: 9)
    }
    if self.timeConnected != 0 {
      try visitor.visitSingularInt64Field(value: self.timeConnected, fieldNumber: 10)
    }
    if self.isIbdPeer != false {
      try visitor.visitSingularBoolField(value: self.isIbdPeer, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetConnectedPeerInfoMessage, rhs: Protowire_GetConnectedPeerInfoMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.address != rhs.address {return false}
    if lhs.lastPingDuration != rhs.lastPingDuration {return false}
    if lhs.isOutbound != rhs.isOutbound {return false}
    if lhs.timeOffset != rhs.timeOffset {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.advertisedProtocolVersion != rhs.advertisedProtocolVersion {return false}
    if lhs.timeConnected != rhs.timeConnected {return false}
    if lhs.isIbdPeer != rhs.isIbdPeer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_AddPeerRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddPeerRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}isPermanent\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isPermanent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.isPermanent != false {
      try visitor.visitSingularBoolField(value: self.isPermanent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_AddPeerRequestMessage, rhs: Protowire_AddPeerRequestMessage) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.isPermanent != rhs.isPermanent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_AddPeerResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddPeerResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_AddPeerResponseMessage, rhs: Protowire_AddPeerResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_SubmitTransactionRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitTransactionRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}transaction\0\u{1}allowOrphan\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowOrphan) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.allowOrphan != false {
      try visitor.visitSingularBoolField(value: self.allowOrphan, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_SubmitTransactionRequestMessage, rhs: Protowire_SubmitTransactionRequestMessage) -> Bool {
    if lhs._transaction != rhs._transaction {return false}
    if lhs.allowOrphan != rhs.allowOrphan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_SubmitTransactionResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitTransactionResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}transactionId\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_SubmitTransactionResponseMessage, rhs: Protowire_SubmitTransactionResponseMessage) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyVirtualSelectedParentChainChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyVirtualSelectedParentChainChangedRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}includeAcceptedTransactionIds\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeAcceptedTransactionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeAcceptedTransactionIds != false {
      try visitor.visitSingularBoolField(value: self.includeAcceptedTransactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyVirtualSelectedParentChainChangedRequestMessage, rhs: Protowire_NotifyVirtualSelectedParentChainChangedRequestMessage) -> Bool {
    if lhs.includeAcceptedTransactionIds != rhs.includeAcceptedTransactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyVirtualSelectedParentChainChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyVirtualSelectedParentChainChangedResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyVirtualSelectedParentChainChangedResponseMessage, rhs: Protowire_NotifyVirtualSelectedParentChainChangedResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_VirtualSelectedParentChainChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VirtualSelectedParentChainChangedNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}removedChainBlockHashes\0\u{1}acceptedTransactionIds\0\u{1}addedChainBlockHashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.removedChainBlockHashes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedTransactionIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addedChainBlockHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.removedChainBlockHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedChainBlockHashes, fieldNumber: 1)
    }
    if !self.acceptedTransactionIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acceptedTransactionIds, fieldNumber: 2)
    }
    if !self.addedChainBlockHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addedChainBlockHashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_VirtualSelectedParentChainChangedNotificationMessage, rhs: Protowire_VirtualSelectedParentChainChangedNotificationMessage) -> Bool {
    if lhs.removedChainBlockHashes != rhs.removedChainBlockHashes {return false}
    if lhs.addedChainBlockHashes != rhs.addedChainBlockHashes {return false}
    if lhs.acceptedTransactionIds != rhs.acceptedTransactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hash\0\u{2}\u{2}includeTransactions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeTransactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.includeTransactions != false {
      try visitor.visitSingularBoolField(value: self.includeTransactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockRequestMessage, rhs: Protowire_GetBlockRequestMessage) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.includeTransactions != rhs.includeTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}block\0\u{2}e\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockResponseMessage, rhs: Protowire_GetBlockResponseMessage) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetSubnetworkRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSubnetworkRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}subnetworkId\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subnetworkID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subnetworkID.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetworkID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetSubnetworkRequestMessage, rhs: Protowire_GetSubnetworkRequestMessage) -> Bool {
    if lhs.subnetworkID != rhs.subnetworkID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetSubnetworkResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSubnetworkResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}gasLimit\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.gasLimit) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetSubnetworkResponseMessage, rhs: Protowire_GetSubnetworkResponseMessage) -> Bool {
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetVirtualSelectedParentChainFromBlockRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVirtualSelectedParentChainFromBlockRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}startHash\0\u{1}includeAcceptedTransactionIds\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.startHash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeAcceptedTransactionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startHash.isEmpty {
      try visitor.visitSingularStringField(value: self.startHash, fieldNumber: 1)
    }
    if self.includeAcceptedTransactionIds != false {
      try visitor.visitSingularBoolField(value: self.includeAcceptedTransactionIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetVirtualSelectedParentChainFromBlockRequestMessage, rhs: Protowire_GetVirtualSelectedParentChainFromBlockRequestMessage) -> Bool {
    if lhs.startHash != rhs.startHash {return false}
    if lhs.includeAcceptedTransactionIds != rhs.includeAcceptedTransactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_AcceptedTransactionIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcceptedTransactionIds"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}acceptingBlockHash\0\u{1}acceptedTransactionIds\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.acceptingBlockHash) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.acceptedTransactionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acceptingBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.acceptingBlockHash, fieldNumber: 1)
    }
    if !self.acceptedTransactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.acceptedTransactionIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_AcceptedTransactionIds, rhs: Protowire_AcceptedTransactionIds) -> Bool {
    if lhs.acceptingBlockHash != rhs.acceptingBlockHash {return false}
    if lhs.acceptedTransactionIds != rhs.acceptedTransactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetVirtualSelectedParentChainFromBlockResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVirtualSelectedParentChainFromBlockResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}removedChainBlockHashes\0\u{1}acceptedTransactionIds\0\u{1}addedChainBlockHashes\0\u{2}e\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.removedChainBlockHashes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedTransactionIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addedChainBlockHashes) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.removedChainBlockHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedChainBlockHashes, fieldNumber: 1)
    }
    if !self.acceptedTransactionIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acceptedTransactionIds, fieldNumber: 2)
    }
    if !self.addedChainBlockHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addedChainBlockHashes, fieldNumber: 3)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetVirtualSelectedParentChainFromBlockResponseMessage, rhs: Protowire_GetVirtualSelectedParentChainFromBlockResponseMessage) -> Bool {
    if lhs.removedChainBlockHashes != rhs.removedChainBlockHashes {return false}
    if lhs.addedChainBlockHashes != rhs.addedChainBlockHashes {return false}
    if lhs.acceptedTransactionIds != rhs.acceptedTransactionIds {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlocksRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlocksRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lowHash\0\u{1}includeBlocks\0\u{1}includeTransactions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lowHash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeBlocks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeTransactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lowHash.isEmpty {
      try visitor.visitSingularStringField(value: self.lowHash, fieldNumber: 1)
    }
    if self.includeBlocks != false {
      try visitor.visitSingularBoolField(value: self.includeBlocks, fieldNumber: 2)
    }
    if self.includeTransactions != false {
      try visitor.visitSingularBoolField(value: self.includeTransactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlocksRequestMessage, rhs: Protowire_GetBlocksRequestMessage) -> Bool {
    if lhs.lowHash != rhs.lowHash {return false}
    if lhs.includeBlocks != rhs.includeBlocks {return false}
    if lhs.includeTransactions != rhs.includeTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlocksResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlocksResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}blocks\0\u{1}blockHashes\0\u{2}d\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.blockHashes) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    if !self.blockHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockHashes, fieldNumber: 4)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlocksResponseMessage, rhs: Protowire_GetBlocksResponseMessage) -> Bool {
    if lhs.blockHashes != rhs.blockHashes {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockCountRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockCountRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockCountRequestMessage, rhs: Protowire_GetBlockCountRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockCountResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockCountResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blockCount\0\u{1}headerCount\0\u{2}f\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockCount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.headerCount) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockCount, fieldNumber: 1)
    }
    if self.headerCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.headerCount, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockCountResponseMessage, rhs: Protowire_GetBlockCountResponseMessage) -> Bool {
    if lhs.blockCount != rhs.blockCount {return false}
    if lhs.headerCount != rhs.headerCount {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockDagInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockDagInfoRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockDagInfoRequestMessage, rhs: Protowire_GetBlockDagInfoRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBlockDagInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockDagInfoResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}networkName\0\u{1}blockCount\0\u{1}headerCount\0\u{1}tipHashes\0\u{1}difficulty\0\u{1}pastMedianTime\0\u{1}virtualParentHashes\0\u{1}pruningPointHash\0\u{1}virtualDaaScore\0\u{2}_\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockCount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.headerCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.tipHashes) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pastMedianTime) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.virtualParentHashes) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.pruningPointHash) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.virtualDaaScore) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networkName.isEmpty {
      try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 1)
    }
    if self.blockCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockCount, fieldNumber: 2)
    }
    if self.headerCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.headerCount, fieldNumber: 3)
    }
    if !self.tipHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tipHashes, fieldNumber: 4)
    }
    if self.difficulty.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 5)
    }
    if self.pastMedianTime != 0 {
      try visitor.visitSingularInt64Field(value: self.pastMedianTime, fieldNumber: 6)
    }
    if !self.virtualParentHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.virtualParentHashes, fieldNumber: 7)
    }
    if !self.pruningPointHash.isEmpty {
      try visitor.visitSingularStringField(value: self.pruningPointHash, fieldNumber: 8)
    }
    if self.virtualDaaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.virtualDaaScore, fieldNumber: 9)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBlockDagInfoResponseMessage, rhs: Protowire_GetBlockDagInfoResponseMessage) -> Bool {
    if lhs.networkName != rhs.networkName {return false}
    if lhs.blockCount != rhs.blockCount {return false}
    if lhs.headerCount != rhs.headerCount {return false}
    if lhs.tipHashes != rhs.tipHashes {return false}
    if lhs.difficulty != rhs.difficulty {return false}
    if lhs.pastMedianTime != rhs.pastMedianTime {return false}
    if lhs.virtualParentHashes != rhs.virtualParentHashes {return false}
    if lhs.pruningPointHash != rhs.pruningPointHash {return false}
    if lhs.virtualDaaScore != rhs.virtualDaaScore {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_ResolveFinalityConflictRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResolveFinalityConflictRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}finalityBlockHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.finalityBlockHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.finalityBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.finalityBlockHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_ResolveFinalityConflictRequestMessage, rhs: Protowire_ResolveFinalityConflictRequestMessage) -> Bool {
    if lhs.finalityBlockHash != rhs.finalityBlockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_ResolveFinalityConflictResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResolveFinalityConflictResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_ResolveFinalityConflictResponseMessage, rhs: Protowire_ResolveFinalityConflictResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyFinalityConflictsRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyFinalityConflictsRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyFinalityConflictsRequestMessage, rhs: Protowire_NotifyFinalityConflictsRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyFinalityConflictsResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyFinalityConflictsResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyFinalityConflictsResponseMessage, rhs: Protowire_NotifyFinalityConflictsResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_FinalityConflictNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalityConflictNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}violatingBlockHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.violatingBlockHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.violatingBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.violatingBlockHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_FinalityConflictNotificationMessage, rhs: Protowire_FinalityConflictNotificationMessage) -> Bool {
    if lhs.violatingBlockHash != rhs.violatingBlockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_FinalityConflictResolvedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalityConflictResolvedNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}finalityBlockHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.finalityBlockHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.finalityBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.finalityBlockHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_FinalityConflictResolvedNotificationMessage, rhs: Protowire_FinalityConflictResolvedNotificationMessage) -> Bool {
    if lhs.finalityBlockHash != rhs.finalityBlockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_ShutDownRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShutDownRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_ShutDownRequestMessage, rhs: Protowire_ShutDownRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_ShutDownResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShutDownResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_ShutDownResponseMessage, rhs: Protowire_ShutDownResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetHeadersRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeadersRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}startHash\0\u{1}limit\0\u{1}isAscending\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.startHash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAscending) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startHash.isEmpty {
      try visitor.visitSingularStringField(value: self.startHash, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 2)
    }
    if self.isAscending != false {
      try visitor.visitSingularBoolField(value: self.isAscending, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetHeadersRequestMessage, rhs: Protowire_GetHeadersRequestMessage) -> Bool {
    if lhs.startHash != rhs.startHash {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.isAscending != rhs.isAscending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetHeadersResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeadersResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}headers\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.headers) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.headers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.headers, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetHeadersResponseMessage, rhs: Protowire_GetHeadersResponseMessage) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyUtxosChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyUtxosChangedRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyUtxosChangedRequestMessage, rhs: Protowire_NotifyUtxosChangedRequestMessage) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyUtxosChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyUtxosChangedResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyUtxosChangedResponseMessage, rhs: Protowire_NotifyUtxosChangedResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_UtxosChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxosChangedNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}added\0\u{1}removed\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.added) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.added.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.added, fieldNumber: 1)
    }
    if !self.removed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_UtxosChangedNotificationMessage, rhs: Protowire_UtxosChangedNotificationMessage) -> Bool {
    if lhs.added != rhs.added {return false}
    if lhs.removed != rhs.removed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_UtxosByAddressesEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxosByAddressesEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}outpoint\0\u{1}utxoEntry\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._utxoEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._utxoEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_UtxosByAddressesEntry, rhs: Protowire_UtxosByAddressesEntry) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs._utxoEntry != rhs._utxoEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_StopNotifyingUtxosChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopNotifyingUtxosChangedRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_StopNotifyingUtxosChangedRequestMessage, rhs: Protowire_StopNotifyingUtxosChangedRequestMessage) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_StopNotifyingUtxosChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopNotifyingUtxosChangedResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_StopNotifyingUtxosChangedResponseMessage, rhs: Protowire_StopNotifyingUtxosChangedResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetUtxosByAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUtxosByAddressesRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetUtxosByAddressesRequestMessage, rhs: Protowire_GetUtxosByAddressesRequestMessage) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetUtxosByAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUtxosByAddressesResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetUtxosByAddressesResponseMessage, rhs: Protowire_GetUtxosByAddressesResponseMessage) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBalanceByAddressRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBalanceByAddressRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBalanceByAddressRequestMessage, rhs: Protowire_GetBalanceByAddressRequestMessage) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBalanceByAddressResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBalanceByAddressResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}balance\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBalanceByAddressResponseMessage, rhs: Protowire_GetBalanceByAddressResponseMessage) -> Bool {
    if lhs.balance != rhs.balance {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBalancesByAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBalancesByAddressesRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBalancesByAddressesRequestMessage, rhs: Protowire_GetBalancesByAddressesRequestMessage) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BalancesByAddressEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BalancesByAddressEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}balance\0\u{2}f\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BalancesByAddressEntry, rhs: Protowire_BalancesByAddressEntry) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetBalancesByAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBalancesByAddressesResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetBalancesByAddressesResponseMessage, rhs: Protowire_GetBalancesByAddressesResponseMessage) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetVirtualSelectedParentBlueScoreRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVirtualSelectedParentBlueScoreRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetVirtualSelectedParentBlueScoreRequestMessage, rhs: Protowire_GetVirtualSelectedParentBlueScoreRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetVirtualSelectedParentBlueScoreResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVirtualSelectedParentBlueScoreResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}blueScore\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blueScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetVirtualSelectedParentBlueScoreResponseMessage, rhs: Protowire_GetVirtualSelectedParentBlueScoreResponseMessage) -> Bool {
    if lhs.blueScore != rhs.blueScore {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyVirtualSelectedParentBlueScoreChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyVirtualSelectedParentBlueScoreChangedRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyVirtualSelectedParentBlueScoreChangedRequestMessage, rhs: Protowire_NotifyVirtualSelectedParentBlueScoreChangedRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyVirtualSelectedParentBlueScoreChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyVirtualSelectedParentBlueScoreChangedResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyVirtualSelectedParentBlueScoreChangedResponseMessage, rhs: Protowire_NotifyVirtualSelectedParentBlueScoreChangedResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_VirtualSelectedParentBlueScoreChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VirtualSelectedParentBlueScoreChangedNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}virtualSelectedParentBlueScore\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.virtualSelectedParentBlueScore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.virtualSelectedParentBlueScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.virtualSelectedParentBlueScore, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_VirtualSelectedParentBlueScoreChangedNotificationMessage, rhs: Protowire_VirtualSelectedParentBlueScoreChangedNotificationMessage) -> Bool {
    if lhs.virtualSelectedParentBlueScore != rhs.virtualSelectedParentBlueScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyVirtualDaaScoreChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyVirtualDaaScoreChangedRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyVirtualDaaScoreChangedRequestMessage, rhs: Protowire_NotifyVirtualDaaScoreChangedRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyVirtualDaaScoreChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyVirtualDaaScoreChangedResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyVirtualDaaScoreChangedResponseMessage, rhs: Protowire_NotifyVirtualDaaScoreChangedResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_VirtualDaaScoreChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VirtualDaaScoreChangedNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}virtualDaaScore\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.virtualDaaScore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.virtualDaaScore != 0 {
      try visitor.visitSingularUInt64Field(value: self.virtualDaaScore, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_VirtualDaaScoreChangedNotificationMessage, rhs: Protowire_VirtualDaaScoreChangedNotificationMessage) -> Bool {
    if lhs.virtualDaaScore != rhs.virtualDaaScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyPruningPointUTXOSetOverrideRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyPruningPointUTXOSetOverrideRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyPruningPointUTXOSetOverrideRequestMessage, rhs: Protowire_NotifyPruningPointUTXOSetOverrideRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyPruningPointUTXOSetOverrideResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyPruningPointUTXOSetOverrideResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyPruningPointUTXOSetOverrideResponseMessage, rhs: Protowire_NotifyPruningPointUTXOSetOverrideResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_PruningPointUTXOSetOverrideNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PruningPointUTXOSetOverrideNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_PruningPointUTXOSetOverrideNotificationMessage, rhs: Protowire_PruningPointUTXOSetOverrideNotificationMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_StopNotifyingPruningPointUTXOSetOverrideRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopNotifyingPruningPointUTXOSetOverrideRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_StopNotifyingPruningPointUTXOSetOverrideRequestMessage, rhs: Protowire_StopNotifyingPruningPointUTXOSetOverrideRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_StopNotifyingPruningPointUTXOSetOverrideResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopNotifyingPruningPointUTXOSetOverrideResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_StopNotifyingPruningPointUTXOSetOverrideResponseMessage, rhs: Protowire_StopNotifyingPruningPointUTXOSetOverrideResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BanRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ip\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BanRequestMessage, rhs: Protowire_BanRequestMessage) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_BanResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_BanResponseMessage, rhs: Protowire_BanResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_UnbanRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbanRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ip\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_UnbanRequestMessage, rhs: Protowire_UnbanRequestMessage) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_UnbanResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbanResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_UnbanResponseMessage, rhs: Protowire_UnbanResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetInfoRequestMessage, rhs: Protowire_GetInfoRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}p2pId\0\u{1}mempoolSize\0\u{1}serverVersion\0\u{1}isUtxoIndexed\0\u{1}isSynced\0\u{2}c\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.p2PID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mempoolSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isUtxoIndexed) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isSynced) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.p2PID.isEmpty {
      try visitor.visitSingularStringField(value: self.p2PID, fieldNumber: 1)
    }
    if self.mempoolSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.mempoolSize, fieldNumber: 2)
    }
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 3)
    }
    if self.isUtxoIndexed != false {
      try visitor.visitSingularBoolField(value: self.isUtxoIndexed, fieldNumber: 4)
    }
    if self.isSynced != false {
      try visitor.visitSingularBoolField(value: self.isSynced, fieldNumber: 5)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetInfoResponseMessage, rhs: Protowire_GetInfoResponseMessage) -> Bool {
    if lhs.p2PID != rhs.p2PID {return false}
    if lhs.mempoolSize != rhs.mempoolSize {return false}
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.isUtxoIndexed != rhs.isUtxoIndexed {return false}
    if lhs.isSynced != rhs.isSynced {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_EstimateNetworkHashesPerSecondRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateNetworkHashesPerSecondRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}windowSize\0\u{1}startHash\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.windowSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.startHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.windowSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.windowSize, fieldNumber: 1)
    }
    if !self.startHash.isEmpty {
      try visitor.visitSingularStringField(value: self.startHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_EstimateNetworkHashesPerSecondRequestMessage, rhs: Protowire_EstimateNetworkHashesPerSecondRequestMessage) -> Bool {
    if lhs.windowSize != rhs.windowSize {return false}
    if lhs.startHash != rhs.startHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_EstimateNetworkHashesPerSecondResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateNetworkHashesPerSecondResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}networkHashesPerSecond\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.networkHashesPerSecond) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.networkHashesPerSecond != 0 {
      try visitor.visitSingularUInt64Field(value: self.networkHashesPerSecond, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_EstimateNetworkHashesPerSecondResponseMessage, rhs: Protowire_EstimateNetworkHashesPerSecondResponseMessage) -> Bool {
    if lhs.networkHashesPerSecond != rhs.networkHashesPerSecond {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyNewBlockTemplateRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyNewBlockTemplateRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyNewBlockTemplateRequestMessage, rhs: Protowire_NotifyNewBlockTemplateRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NotifyNewBlockTemplateResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyNewBlockTemplateResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}h\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NotifyNewBlockTemplateResponseMessage, rhs: Protowire_NotifyNewBlockTemplateResponseMessage) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_NewBlockTemplateNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewBlockTemplateNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_NewBlockTemplateNotificationMessage, rhs: Protowire_NewBlockTemplateNotificationMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_MempoolEntryByAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MempoolEntryByAddress"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}sending\0\u{1}receiving\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sending) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.receiving) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.sending.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sending, fieldNumber: 2)
    }
    if !self.receiving.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receiving, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_MempoolEntryByAddress, rhs: Protowire_MempoolEntryByAddress) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.sending != rhs.sending {return false}
    if lhs.receiving != rhs.receiving {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetMempoolEntriesByAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesByAddressesRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0\u{1}includeOrphanPool\0\u{1}filterTransactionPool\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeOrphanPool) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.filterTransactionPool) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    if self.includeOrphanPool != false {
      try visitor.visitSingularBoolField(value: self.includeOrphanPool, fieldNumber: 2)
    }
    if self.filterTransactionPool != false {
      try visitor.visitSingularBoolField(value: self.filterTransactionPool, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetMempoolEntriesByAddressesRequestMessage, rhs: Protowire_GetMempoolEntriesByAddressesRequestMessage) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.includeOrphanPool != rhs.includeOrphanPool {return false}
    if lhs.filterTransactionPool != rhs.filterTransactionPool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetMempoolEntriesByAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesByAddressesResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{2}g\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetMempoolEntriesByAddressesResponseMessage, rhs: Protowire_GetMempoolEntriesByAddressesResponseMessage) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetCoinSupplyRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCoinSupplyRequestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetCoinSupplyRequestMessage, rhs: Protowire_GetCoinSupplyRequestMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protowire_GetCoinSupplyResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCoinSupplyResponseMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}maxSompi\0\u{1}circulatingSompi\0\u{2}f\u{f}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxSompi) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.circulatingSompi) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxSompi != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxSompi, fieldNumber: 1)
    }
    if self.circulatingSompi != 0 {
      try visitor.visitSingularUInt64Field(value: self.circulatingSompi, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protowire_GetCoinSupplyResponseMessage, rhs: Protowire_GetCoinSupplyResponseMessage) -> Bool {
    if lhs.maxSompi != rhs.maxSompi {return false}
    if lhs.circulatingSompi != rhs.circulatingSompi {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
